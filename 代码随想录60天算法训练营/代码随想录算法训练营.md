# 算法训练营

3716351504999908608

28期打卡名单：[https://docs.qq.com/sheet/DUFNlSFJUb2tXUmFL?tab=BB08J2](https://docs.qq.com/sheet/DUFNlSFJUb2tXUmFL?tab=BB08J2)

博客以及打卡方式：[https://docs.qq.com/doc/DUEdmb1JCaEtlZWFx](https://docs.qq.com/doc/DUEdmb1JCaEtlZWFx)

每日精华：[https://www.yuque.com/chengxuyuancarl/wnx1np/ktwax2](https://www.yuque.com/chengxuyuancarl/wnx1np/ktwax2)

### 第一章：数组

#### 代码随想录算法训练营第一天 | 704. 二分查找，27. 移除元素

#### ● day 1 任务以及具体安排：[第一章  数组part01](https://docs.qq.com/doc/DUG9UR2ZUc3BjRUdY)  (12.13)

### 第一章 数组part01

#### 今日任务

数组理论基础，704. 二分查找，27. 移除元素

#### 详细布置

#### 数组理论基础

文章链接：[https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html](https://programmercarl.com/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)

题目建议： 了解一下数组基础，以及数组的内存空间地址，数组也没那么简单。

#### 704. 二分查找

题目建议： 大家能把 704 掌握就可以，35.搜索插入位置 和 34. 在排序数组中查找元素的第一个和最后一个位置 ，如果有时间就去看一下，没时间可以先不看，二刷的时候在看。

先把 704写熟练，要熟悉 根据 左闭右开，左闭右闭 两种区间规则 写出来的二分法。

题目链接：[https://leetcode.cn/problems/binary-search/](https://leetcode.cn/problems/binary-search/)

文章讲解：[https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html](https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html)

视频讲解：[https://www.bilibili.com/video/BV1fA4y1o715](https://www.bilibili.com/video/BV1fA4y1o715)

#### 27. 移除元素

题目建议：  暴力的解法，可以锻炼一下我们的代码实现能力，建议先把暴力写法写一遍。 双指针法 是本题的精髓，今日需要掌握，至于拓展题目可以先不看。

题目链接：[https://leetcode.cn/problems/remove-element/](https://leetcode.cn/problems/remove-element/)

文章讲解：[https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html](https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html)

视频讲解：[https://www.bilibili.com/video/BV12A4y1Z7LP](https://www.bilibili.com/video/BV12A4y1Z7LP)

[Just a moment...](https://chat.openai.com/share/858c0bf4-d337-4d0f-928e-e3090c93d230)

---

#### 数组基础

数组是存放在连续内存空间上的相同类型数据的集合（数组在内存中的存储方式）

- 数组下标都是从0开始
- 数组内存空间的地址是连续的

**因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。**

![Image.png](https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%841.png)

在Python中，当你从数组（在Python中通常被称为列表）中删除一个元素时，其它元素会移动来填补这个空位。这与C++中的情况不同，在C++中数组元素不能被删除，只能被覆盖。Python的动态特性允许了这种灵活性。

至于Python和C++在二维数组内存管理方面的差异，有以下几点：

1. **C++：** 在C++中，二维数组是在连续的内存位置中存储的。元素在内存中按顺序排列，使得元素访问直接且可预测。
2. **Python：** Python在内存管理方面的方法与C++截然不同。它不向程序员公开元素的内存地址，寻址完全由虚拟机管理。因此，在Python中，二维数组的元素分配并不一定是连续的。Python中二维数组的每一行都可以位于不同的、非连续的内存地址。

以下是这两种语言在这些方面的对比，以表格形式呈现：

| 方面        | Python     | C++           |
| --------- | ---------- | ------------- |
| 删除数组元素    | 元素移动来填补空位  | 元素不能被删除，只能被覆盖 |
| 二维数组的内存分配 | 非顺序，由虚拟机管理 | 连续，元素在内存中顺序排列 |

Python在管理数组和内存分配方面的灵活性与C++的更静态和可预测的方法有着显著的不同。

---

### [704. 二分查找](https://leetcode.cn/problems/binary-search/)

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。

**示例 1:**

**输入:** `nums` = [-1,0,3,5,9,12], `target` = 9

**输出:** 4

**解释:** 9 出现在 `nums` 中并且下标为 4

**示例 2:**

**输入:** `nums` = [-1,0,3,5,9,12], `target` = 2

**输出:** -1

**解释:** 2 不存在 `nums` 中因此返回 -1

**提示：**

1. 你可以假设 `nums` 中的所有元素是不重复的。
2. `n` 将在 `[1, 10000]`之间。
3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

**解题思路：**

1. **初始化两个指针**：开始时设置两个指针，`left` 设置为0（数组的开始位置），`right` 设置为 `len(nums) - 1`（数组的末尾位置）。
2. **二分查找**：
   - 当 `left <= right` 时：
      - 计算中间索引：`mid = left + (right - left) // 2`。
      - 检查 `mid` 元素是否是目标值。如果是，返回 `mid`。
      - 如果 `mid` 元素小于目标值，将 `left` 指针移动到 `mid + 1`。
      - 如果 `mid` 元素大于目标值，将 `right` 指针移动到 `mid - 1`。
3. **目标值未找到**：如果循环结束还没有返回值，意味着目标值不在数组中。返回 `-1`。

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
      left, right = 0, len(nums)-1

      while left <= right:
        mid = left + (right - left) // 2
        if nums[mid]==target:
          return mid
        elif nums[mid] < target:
          left = mid + 1
        else:
          right = mid - 1

      return -1
```

**视频讲解：**

[手把手带你撕出正确的二分法 | 二分查找法 | 二分搜索法](https://www.youtube.com/watch?v=oxejtPgSlro)

**难点**：

- 首先，while的条件是left < right 还是left ≤ right? 这是如何判断的呢？
- 其次，当left和right极其靠近的时候，mid = left + (right - left) // 2会不会出现越界的情况？
- 最后，当nums[mid] != target时，left和right被赋予的新的值还在搜索区间内吗？

**解答：**

1. `while` **循环的条件（`left < right` vs `left ≤ right`）**:
   - 当使用 `left ≤ right` 作为循环条件时，意味着当 `left` 和 `right` 指向同一个元素时，循环仍然会继续执行。这是为了确保在数组中只有一个元素或者要查找的元素正好位于 `left` 和 `right` 指向的同一个位置时，该元素能被正确处理。
   - 使用 `left < right` 作为循环条件时，意味着当 `left` 和 `right` 相遇时，循环停止。这种情况下，可能需要在循环外额外处理 `left` 和 `right` 相遇的情况。

   通常，选择哪个条件取决于具体问题的需求和如何更新 `left` 和 `right`。在大多数标准的二分查找情况下，使用 `left ≤ right` 是更安全的选择。

2. **是否存在越界问题**:
   - 在二分查找中，计算 `mid` 使用的公式 `mid = left + (right - left) // 2` 避免了越界问题。这种写法比直接使用 `(left + right) // 2` 更安全，尤其是在处理大整数时。
   - 由于 `left` 和 `right` 总是在数组的有效范围内，且 `(right - left)` 不会导致负数，因此 `mid` 也始终会在数组的有效范围内。
3. **更新 `left` 和 `right` 时的搜索区间**:
   - 在 `nums[mid] < target` 的情况下，将 `left` 设置为 `mid + 1`，这意味着 `mid` 和它左边的所有元素都不可能是目标值，因此新的搜索区间是 `[mid + 1, right]`。
   - 在 `nums[mid] > target` 的情况下，将 `right` 设置为 `mid - 1`，这意味着 `mid` 和它右边的所有元素都不可能是目标值，因此新的搜索区间是 `[left, mid - 1]`。
   - 在每次迭代中，搜索区间都在减小，确保了算法的收敛性。

总的来说，二分查找的关键在于正确地维护搜索区间，并确保每一步迭代都在缩小这个区间，同时防止越界。正确更新 `left` 和 `right`，以及适当的循环条件，是实现有效二分查找的基础。

#### **左闭右闭和左闭右开**

在左闭右闭的条件下，while left ≤ right，每次更新nums[mid] < target: left = mid + 1, nums[mid] > target: right = mid - 1

在左闭右开的条件下， while left < right，每次更新nums[mid] < target: left = mid + 1, nums[mid] > target: right = mid

1. **左闭右闭（闭区间）**:
   - 在这种情况下，区间 `[left, right]` 包括 `left` 和 `right` 指向的元素。
   - 当 `nums[mid] < target` 时，说明目标值不在 `mid` 及其左侧，因此下一个搜索区间应从 `mid + 1` 开始。
   - 当 `nums[mid] > target` 时，说明目标值不在 `mid` 及其右侧，因此下一个搜索区间应在 `mid - 1` 结束。
   - 循环条件使用 `left ≤ right`，确保在 `left` 和 `right` 相遇时仍然检查那个位置。

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1  # 定义target在左闭右闭的区间里，[left, right]

        while left <= right:
            middle = left + (right - left) // 2
            
            if nums[middle] > target:
                right = middle - 1  # target在左区间，所以[left, middle - 1]
            elif nums[middle] < target:
                left = middle + 1  # target在右区间，所以[middle + 1, right]
            else:
                return middle  # 数组中找到目标值，直接返回下标
        return -1  # 未找到目标值

# 时间复杂度：O(log n)
# 空间复杂度：O(1)
```

2. **左闭右开（半开区间）**:
   - 在这种情况下，区间 `[left, right)` 包括 `left` 指向的元素但不包括 `right` 指向的元素。
   - 当 `nums[mid] < target` 时，同样的逻辑，下一个搜索区间从 `mid + 1` 开始。
   - 当 `nums[mid] > target` 时，由于区间不包括 `right` 指向的元素，所以当 `nums[mid]` 不是目标值时，下一个搜索区间可以在 `mid` 结束，而不是 `mid - 1`。
   - 循环条件使用 `left < right`，当 `left` 和 `right` 相遇时停止循环，因为右侧界限是开放的。

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums)  # 定义target在左闭右开的区间里，即：[left, right)

        while left < right:  # 因为left == right的时候，在[left, right)是无效的空间，所以使用 <
            middle = left + (right - left) // 2

            if nums[middle] > target:
                right = middle  # target 在左区间，在[left, middle)中
            elif nums[middle] < target:
                left = middle + 1  # target 在右区间，在[middle + 1, right)中
            else:
                return middle  # 数组中找到目标值，直接返回下标
        return -1  # 未找到目标值

# 时间复杂度：O(log n)
# 空间复杂度：O(1)
```

#### 为什么有这种差异？

这两种方法实际上都是合理的，它们只是定义和处理区间的方式不同。在左闭右闭的情况下，我们每次都检查并排除 `mid` 点，因此需要调整 `right` 到 `mid - 1`。而在左闭右开的情况下，由于区间本身就不包括 `right`，因此我们可以直接将 `right` 设置为 `mid`，而不是 `mid - 1`。

---

### [27. 移除元素](https://leetcode.com/problems/remove-element/)

给你一个数组 `nums` 和一个值 `val`，你需要 [**原地**](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95) 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 [**原地**](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95) **修改输入数组**。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**示例 1：**

输入：nums = [3,2,2,3], val = 3

输出：2, nums = [2,2]

解释：函数应该返回新的长度 `2`, 并且 nums 中的前两个元素均为 **2**。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。

**示例 2：**

输入：nums = [0,1,2,2,3,0,4,2], val = 2

输出：5, nums = [0,1,3,0,4]

解释：函数应该返回新的长度 `5`, 并且 nums 中的前五个元素为 `0`, `1`, `3`, `0`, `4`。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。

**提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`

**解题思路：**

可以通过双指针方法解决。基本思路是使用两个指针——一个快指针 `fast` 和一个慢指针 `slow`。快指针用于遍历数组，而慢指针用于指示修改后数组的长度。

1. 初始化两个指针 `slow = 0` 和 `fast = 0`。
2. 遍历数组：
   - 当 `nums[fast] != val` 时，将 `nums[fast]` 的值赋给 `nums[slow]`，并且 `slow` 加一。
   - `fast` 总是加一，继续遍历数组。
3. 遍历结束后，`slow` 指针的位置就是新数组的长度。

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        # 快慢指针
        fast = 0  # 快指针
        slow = 0  # 慢指针
        size = len(nums)
        while fast < size:  # 不加等于是因为，a = size 时，nums[a] 会越界
            # slow 用来收集不等于 val 的值，如果 fast 对应值不等于 val，则把它与 slow 替换
            if nums[fast] != val:
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        return slow
```

#### 视频讲解：

[Leetcode：27. 移除元素，数组中移除元素并不容易！ | 数组理论基础 | 理解双指针法，](https://www.youtube.com/watch?v=98uu0FYPiU8)

难点：

- 理解快慢指针的用法：fast遍历，slow更新数组

解答：

1. **快慢指针的角色和目的**：
   - **快指针（`fast`）**：负责遍历整个数组，检查每一个元素。
   - **慢指针（`slow`）**：指向处理后数组的末尾（即下一个不为 `val` 的元素应放置的位置）。

   这种分工有助于在遍历数组的同时进行原地修改，而不需要额外的空间。

2. **为什么可以修改原数组**：
   - 由于题目允许改变数组元素的顺序，我们可以将不等于 `val` 的元素移到数组的前面，而忽略后面的部分。
   - 当快指针遇到一个不等于 `val` 的元素时，我们就把它复制到慢指针的位置，然后移动慢指针。
3. **快慢指针的移动规则**：
   - 当 `nums[fast] != val` 时，复制 `nums[fast]` 到 `nums[slow]`，并将 `slow` 向前移动一步。
   - 不管 `nums[fast]` 是否等于 `val`，`fast` 指针总是向前移动一步。
4. **理解函数返回值**：
   - 函数返回的是 `slow` 指针的值，它代表了数组中不包含 `val` 的元素的新长度。
   - 数组 `nums` 的前 `slow` 个元素是修改后的数组，后面的元素不需要考虑。
5. **边界条件的处理**：
   - 必须考虑数组为空或者所有元素都等于 `val` 的情况。在这些情况下，慢指针 `slow` 将保持在 0 的位置。

#### 代码随想录算法训练营第二天 | 977.有序数组的平方 ，209.长度最小的子数组 ，59.螺旋矩阵II

#### ● day 2 任务以及具体安排：[第一章  数组part02](https://docs.qq.com/doc/DUGRwWXNOVEpyaVpG) (12.14)

### [第一章  数组part02](https://docs.qq.com/doc/DUGRwWXNOVEpyaVpG?u=c71ed002e4554fee8c262b2a4a4935d8)

977.有序数组的平方 ，209.长度最小的子数组 ，59.螺旋矩阵II ，总结

建议大家先独立做题，然后看视频讲解，然后看文章讲解，然后在重新做一遍题，把题目AC，最后整理成今日当天的博客

拓展题目可以先不做

#### 详细布置

#### 977.有序数组的平方

题目建议： 本题关键在于理解双指针思想

题目链接：[https://leetcode.cn/problems/squares-of-a-sorted-array/](https://leetcode.cn/problems/squares-of-a-sorted-array/)

文章讲解：[https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html](https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html)

视频讲解： [https://www.bilibili.com/video/BV1QB4y1D7ep](https://www.bilibili.com/video/BV1QB4y1D7ep)

#### 209.长度最小的子数组

题目建议： 本题关键在于理解滑动窗口，这个滑动窗口看文字讲解 还挺难理解的，建议大家先看视频讲解。  拓展题目可以先不做。

题目链接：[https://leetcode.cn/problems/minimum-size-subarray-sum/](https://leetcode.cn/problems/minimum-size-subarray-sum/)

文章讲解：[https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html](https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html)

视频讲解：[https://www.bilibili.com/video/BV1tZ4y1q7XE](https://www.bilibili.com/video/BV1tZ4y1q7XE)

#### 59.螺旋矩阵II

题目建议：  本题关键还是在转圈的逻辑，在二分搜索中提到的区间定义，在这里又用上了。

题目链接：[https://leetcode.cn/problems/spiral-matrix-ii/](https://leetcode.cn/problems/spiral-matrix-ii/)

文章讲解：[https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html](https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html)

视频讲解：[https://www.bilibili.com/video/BV1SL4y1N7mV/](https://www.bilibili.com/video/BV1SL4y1N7mV/)

#### 总结

题目建议：希望大家 也做一个自己 对数组专题的总结

文章链接：[https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html](https://programmercarl.com/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93%E7%AF%87.html)

[Just a moment...](https://chat.openai.com/share/100fbc71-c50d-4a5d-8828-fbbdec772846)

---

### [977.有序数组的平方](https://leetcode.com/problems/squares-of-a-sorted-array/)

给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

示例 1：

- 输入：nums = [-4,-1,0,3,10]
- 输出：[0,1,9,16,100]
- 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]

示例 2：

- 输入：nums = [-7,-3,2,3,11]
- 输出：[4,9,9,49,121]

**解题思路：**

1. 创建一个新数组，大小与输入数组 `nums` 相同，用于存放结果。
2. 设置两个指针，`left` 指向数组开头，`right` 指向数组末尾。
3. 遍历数组，每次比较 `nums[left]` 和 `nums[right]` 的平方值：
   - 如果 `nums[left]` 的平方大于 `nums[right]` 的平方，将 `nums[left]` 的平方值放入结果数组的当前位置，并将 `left` 指针向右移动。
   - 否则，将 `nums[right]` 的平方值放入结果数组的当前位置，并将 `right` 指针向左移动。
4. 每次放入一个数后，更新结果数组的索引。
5. 当 `left` 大于 `right` 时，结束循环。

```python
def sortedSquares(nums):
    # 建立一个长度等于原数组的新数组
    n = len(nums)
    result = [0] * n
    # 设定左右指针
    left, right = 0, n - 1
    # 逆序向新数组种更新最大的平方数
    for i in range(n - 1, -1, -1):
        # 比较两端指针对应的绝对值的大小，添加并移动指针
        if abs(nums[left]) > abs(nums[right]):
            result[i] = nums[left] ** 2
            left += 1
        else:
            result[i] = nums[right] ** 2
            right -= 1
    return result

# 测试
print(sortedSquares([-4, -1, 0, 3, 10]))  # [0, 1, 9, 16, 100]
print(sortedSquares([-7, -3, 2, 3, 11]))  # [4, 9, 9, 49, 121]
```

#### 复杂度分析

- 时间复杂度：O(N)，其中 N 是数组 `nums` 的长度。每个元素最多被访问一次。
- 空间复杂度：O(N)，用于存放结果数组。

这种方法充分利用了数组已经排序的特性，通过双指针从两端向中间遍历，可以有效地减少不必要的比较，保证了算法的高效性。

#### 视频讲解：

[Leetcode：977.有序数组的平方，双指针经典题目](https://www.youtube.com/watch?v=9u1qXgHMb7Q&t=2s&ab_channel=%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95)

#### 难点：

1. **处理负数的平方**：由于数组是非递减排序的，数组前半部分可能包含负数，其平方后的值可能大于数组后半部分正数的平方。这一点在实现算法时容易被忽视。
2. **双指针移动条件的选择**：在使用双指针时，正确判断何时移动左指针，何时移动右指针是关键。错误的移动条件会导致结果数组未能正确排序。
3. **结果数组的索引填充**：由于是从两端向中间比较，结果数组应该从末尾开始填充。这与常规的从头开始填充数组的思维习惯不同，容易出错。
4. **边界条件处理**：在循环中正确处理 `left` 和 `right` 指针的边界条件，避免数组越界，是实现这个算法的一个细节点。
5. **优化空间复杂度**：虽然使用一个额外的数组来存储结果是解决问题的直接方法，但在一些特定情况下（例如原地修改数组），需要考虑如何优化空间复杂度。

#### 解答：

- **理解平方后的顺序变化**：了解负数平方后可能比某些正数大这一点，有助于理解为什么从两端开始比较。
- **精确控制双指针逻辑**：确保在每一步比较中正确选择较大的平方数进行排序，并适当移动指针。

![Image.gif](https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif)

- **从后往前填充结果数组**：这样可以保证在每一步都将当前最大的平方数放在正确的位置。
- **注意边界条件**：在实现循环时，注意 `left` 和 `right` 指针不要越界。
- **空间优化**：如果题目要求优化空间复杂度，考虑使用原地算法（如先计算平方然后用双指针排序）。

#### 空间复杂度优化的解法

为了优化空间复杂度，我们可以采用原地排序算法。对于这个特定问题，这意味着我们首先将数组中每个元素平方，然后使用一种排序算法（例如快速排序或归并排序）对数组进行排序。

这种方法虽然不需要额外的空间来存储平方后的结果，但排序过程中可能会使用额外的空间，具体取决于所选的排序算法。例如，归并排序通常需要 O(N) 的空间复杂度，而快速排序的空间复杂度为 O(log N)，但在最坏情况下可能达到 O(N)。

下面是一个使用快速排序的示例代码：

```python
def sortedSquares(nums):
    # 首先对每个元素求平方
    for i in range(len(nums)):
        nums[i] *= nums[i]

    # 快速排序的辅助函数
    def quickSort(left, right):
        if left >= right:
            return

        # 分区操作
        pivot, l, r = nums[left], left, right
        while l < r:
            while l < r and nums[r] >= pivot:
                r -= 1
            nums[l] = nums[r]
            while l < r and nums[l] <= pivot:
                l += 1
            nums[r] = nums[l]
        nums[l] = pivot

        # 递归对左右两部分进行快速排序
        quickSort(left, l - 1)
        quickSort(l + 1, right)

    # 对整个数组进行快速排序
    quickSort(0, len(nums) - 1)
    return nums

# 测试
print(sortedSquares([-4, -1, 0, 3, 10]))  # [0, 1, 9, 16, 100]
print(sortedSquares([-7, -3, 2, 3, 11]))  # [4, 9, 9, 49, 121]
```

#### 代码解释

1. 首先，数组中的每个元素都被平方。
2. 接下来，使用快速排序算法对平方后的数组进行排序。快速排序通过选择一个基准元素并将所有小于基准的元素移动到基准的左边，所有大于基准的元素移动到右边的方式，来实现排序。
3. 快速排序是递归进行的，分别对基准左边和右边的子数组进行相同的操作。

#### 复杂度分析

- 时间复杂度：O(N log N)，其中 N 是数组 `nums` 的长度。平方操作是 O(N)，快速排序平均情况下是 O(N log N)。
- 空间复杂度：O(log N) 到 O(N)，取决于快速排序递归调用的深度。在最佳情况下是 O(log N)，最坏情况下是 O(N)。

---

### [209.长度最小的子数组](https://leetcode.com/problems/minimum-size-subarray-sum/)

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

示例：

- 输入：s = 7, nums = [2,3,1,2,4,3]
- 输出：2
- 解释：子数组 [4,3] 是该条件下的长度最小的子数组。

提示：

- 1 <= target <= 10^9
- 1 <= nums.length <= 10^5
- 1 <= nums[i] <= 10^5

**解题思路：**

1. **初始化两个指针**：`start` 和 `end`，分别代表滑动窗口的起始和结束位置，初始时都指向数组的起始位置。
2. **扩展窗口**：移动 `end` 指针，扩展窗口，直到窗口内元素之和大于等于 `s`。
3. **缩小窗口**：当窗口内元素之和大于等于 `s` 时，移动 `start` 指针，缩小窗口，直到窗口内元素之和小于 `s`。在这一过程中，记录下满足条件的最小窗口长度。
4. **重复步骤 2 和 3**，直到 `end` 指针到达数组末尾。

```python
def minSubArrayLen(s, nums):
    n = len(nums)
    start, end = 0, 0  # 初始化双指针，都指向数组的起始位置
    total = 0  # 初始化窗口内元素总和
    min_length = float('inf')  # 初始化最小长度为无穷大

    while end < n:  # 当end指针未到达数组末尾时
        total += nums[end]  # 将end指针的元素加到总和中
        end += 1  # 移动end指针

        while total >= s:  # 当窗口内元素总和大于等于s时
            min_length = min(min_length, end - start)  # 更新最小长度
            total -= nums[start]  # 从总和中减去start指针的元素
            start += 1  # 移动start指针

    # 如果min_length为初始值，则表示没有找到符合条件的子数组，返回0
    return 0 if min_length == float('inf') else min_length

# 测试
print(minSubArrayLen(7, [2, 3, 1, 2, 4, 3]))  # 输出 2
```

#### 复杂度分析

- 时间复杂度：O(N)，其中 N 是数组 `nums` 的长度。每个元素最多被访问两次，分别是 `end` 指针和 `start` 指针各访问一次。
- 空间复杂度：O(1)，只使用了常数级别的额外空间。

#### 视频讲解

[LeetCode：209.长度最小的子数组 | 拿下滑动窗口！](https://youtu.be/7brhpecjOSY?si=9XERNU926J2eNgas)

#### 疑难点和解决办法

1. **滑动窗口的理解**：理解滑动窗口的概念可能是刚开始遇到的难点。滑动窗口实际上是一种双指针技巧，通过动态调整窗口大小来满足特定条件。
2. **窗口大小的调整**：确定何时扩展窗口、何时缩小窗口是关键。当窗口内元素和小于 `s` 时，需要扩展窗口；当窗口内元素和大于等于 `s` 时，需要尝试缩小窗口以寻找更小的满足条件的窗口。
3. **处理不存在的情况**：当不存在满足条件的子数组时，应返回 0。这可以通过设置最小长度为无穷大，并在最后检查其值来实现。`float('inf')` 是一个非常大的数，表示无穷大。如果在遍历过程中找到了符合条件的子数组，`min_length` 就会被更新为一个实际的长度值；如果没有找到，`min_length` 将保持为 `float('inf')`，这时通过比较可以知道没有找到符合条件的子数组。

---

### [59.螺旋矩阵II](https://leetcode.com/problems/spiral-matrix-ii/)

给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

示例 1：

- 输入: 3
- 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]

![Image.jpg](https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg)

示例 2：

- 输入：n = 1
- 输出：[[1]]

提示：

- `1 <= n <= 20`

#### 解题思路：

1. 初始化一个 n×n 的空矩阵（全部元素为 0）。
2. 使用四个变量表示当前遍历的边界：`top`, `bottom`, `left`, `right`，初始时 `top = 0`, `bottom = n - 1`, `left = 0`, `right = n - 1`。
3. 使用一个变量 `num` 来存储当前要填充的数字，初始值为 1。
4. 按照顺时针方向，依次填充矩阵的上边界、右边界、下边界、左边界。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20220922102236.png)

5. 每填完一边，更新相应的边界，缩小遍历范围。
6. 重复步骤 4 和 5，直到填充完所有元素。

```python
def generateMatrix(n):
    # 初始化一个 n×n 的空矩阵
    matrix = [[0] * n for _ in range(n)]
    # 初始化填充的数字
    num = 1
    # 初始化上下左右边界
    top, bottom, left, right = 0, n - 1, 0, n - 1

    # 当上边界不超过下边界，左边界不超过右边界时继续循环
    while top <= bottom and left <= right:
        # 填充上边界
        for i in range(left, right + 1):
            matrix[top][i] = num
            num += 1
        top += 1  # 上边界下移

        # 填充右边界
        for i in range(top, bottom + 1):
            matrix[i][right] = num
            num += 1
        right -= 1  # 右边界左移

        # 填充下边界
        for i in range(right, left - 1, -1):
            matrix[bottom][i] = num
            num += 1
        bottom -= 1  # 下边界上移

        # 填充左边界
        for i in range(bottom, top - 1, -1):
            matrix[i][left] = num
            num += 1
        left += 1  # 左边界右移

    return matrix

# 测试
print(generateMatrix(3))  # 输出 3x3 螺旋矩阵
```

#### 复杂度分析

- 时间复杂度：O(n^2)，其中 n 是输入的正整数。需要遍历矩阵中的每个元素一次。
- 空间复杂度：O(n^2)，用于存储生成的 n×n 矩阵。

#### 讲解视频

[LeetCode：59.螺旋矩阵II | 《代码随想录》第五题](https://youtu.be/9jVq8z4tKDA?si=P8LhtBENqUJ9lTXM)

#### 疑难点和解决办法

1. **边界控制**：这是实现螺旋矩阵的最大难点。解决办法是使用四个变量 `top`, `bottom`, `left`, `right` 来控制填充的边界，并在每次填充一圈后适当地更新这些边界值。
2. **顺时针填充顺序**：螺旋矩阵的填充顺序是顺时针方向。解决办法是遵循“从左到右 -> 从上到下 -> 从右到左 -> 从下到上”的顺序进行填充。
3. **循环终止条件**：正确判断何时停止填充是关键。解决办法是当 `top` 大于 `bottom` 或 `left` 大于 `right` 时，结束循环。
4. **避免重复填充**：在填充过程中，需要避免重复填充已经填充过的单元格。解决办法是在每次填充完一条边后，更新相应的边界，确保下一次填充不会覆盖之前的值。

### 第二章：链表

#### 代码随想录算法训练营第三天 | 203.移除链表元素， 707.设计链表， 206.反转链表

#### ● day 3 任务以及具体安排：[第二章 链表part01](https://docs.qq.com/doc/DUGdqYWNYeGhlaVR6) (12.15)

## 今日任务

●  链表理论基础

●  203.移除链表元素

●  707.设计链表

●  206.反转链表

## 详细布置

### 链表理论基础

建议：了解一下链接基础，以及链表和数组的区别

文章链接：[https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html](https://programmercarl.com/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)

### 203.移除链表元素

建议： 本题最关键是要理解 虚拟头结点的使用技巧，这个对链表题目很重要。

题目链接/文章讲解/视频讲解：：[https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html](https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html)

### 707.设计链表

建议： 这是一道考察 链表综合操作的题目，不算容易，可以练一练 使用虚拟头结点

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html](https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html)

### 206.反转链表

建议先看我的视频讲解，视频讲解中对 反转链表需要注意的点讲的很清晰了，看完之后大家的疑惑基本都解决了。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html](https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html)

[Just a moment...](https://chat.openai.com/share/dc8ad4dc-44ac-4b82-b68f-6e7569dcbc28)

---

#### 链表理论基础

链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。

链表的入口节点称为链表的头结点也就是head。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194529815.png)

链表的几种类型:

#### 单链表

刚刚说的就是单链表。

#### 双链表

单链表中的指针域只能指向节点的下一个节点。

双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。

双链表 既可以向前查询也可以向后查询。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194559317.png)

#### 循环链表

循环链表，顾名思义，就是链表首尾相连。

循环链表可以用来解决约瑟夫环问题。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194629603.png)

#### 链表的存储方式

了解完链表的类型，再来说一说链表在内存中的存储方式。

数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。

链表是通过指针域的指针链接在内存中各个节点。

所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194613920.png)

这个链表起始节点为2， 终止节点为7， 各个节点分布在内存的不同地址空间上，通过指针串联在一起。

### 链表的定义

单链表：

```python
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
```

### 链表的操作

删除节点

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195114541-20230310121459257.png)

```python
class LinkedList:
    def __init__(self):
        self.head = None

    def is_empty(self):
        # Check if the linked list is empty
        return self.head is None

    def remove(self, data):
        # Remove the first occurrence of an element from the linked list
        if self.head is None:
            raise ValueError("Linked list is empty")
        if self.head.data == data:
            self.head = self.head.next
        else:
            current = self.head
            while current.next is not None and current.next.data != data:
                current = current.next
            if current.next is None:
                raise ValueError("Element not found")
            current.next = current.next.next
```

添加节点

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195134331-20230310121503147.png)

```python
class LinkedList:
    def __init__(self):
        self.head = None

    def is_empty(self):
        # Check if the linked list is empty
        return self.head is None

    def append(self, data):
        # Append an element to the end of the linked list
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
        else:
            current = self.head
            while current.next is not None:
                current = current.next
            current.next = new_node

    def insert(self, data, position):
        # Insert an element at a given position in the linked list
        if position == 0:
            new_node = Node(data)
            new_node.next = self.head
            self.head = new_node
        else:
            current = self.head
            for _ in range(position - 1):
                if current is None:
                    raise IndexError("Position out of range")
                current = current.next
            new_node = Node(data)
            new_node.next = current.next
            current.next = new_node

    def remove(self, data):
        # Remove the first occurrence of an element from the linked list
        if self.head is None:
            raise ValueError("Linked list is empty")
        if self.head.data == data:
            self.head = self.head.next
        else:
            current = self.head
            while current.next is not None and current.next.data != data:
                current = current.next
            if current.next is None:
                raise ValueError("Element not found")
            current.next = current.next.next
```

### 性能分析

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195200276.png)

---

### [203.移除链表元素](https://leetcode.com/problems/remove-linked-list-elements/)

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

**示例 1：**

![Image.jpg](https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg)

**输入：**head = [1,2,6,3,4,5,6], val = 6

**输出：**[1,2,3,4,5]

**示例 2：**

**输入：**head = [], val = 1

**输出：**[]

**示例 3：**

**输入：**head = [7,7,7,7], val = 7

**输出：**[]

**提示：**

- 列表中的节点数目在范围 `[0, 104]` 内
- `1 <= Node.val <= 50`
- `0 <= val <= 50`

#### 解题思路：

1. **创建一个虚拟头节点**：为了方便处理当头节点的值等于 `val` 时的情况，我们可以在原链表的头部添加一个虚拟节点，其 `next` 指向原链表的头节点。
2. **遍历链表**：使用两个指针，`prev` 和 `curr`。`prev` 指向当前考虑的节点的前一个节点，而 `curr` 指向当前考虑的节点。
3. **删除操作**：如果 `curr` 指向的节点值等于 `val`，则将 `prev` 的 `next` 指向 `curr` 的 `next`，从而删除 `curr`。否则，只需移动 `prev`。
4. **返回结果**：返回虚拟头节点的 `next`，这是新链表的头节点。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def removeElements(head, val):
    dummy = ListNode(next=head)  # 创建虚拟头节点
    prev, curr = dummy, head

    while curr:
        if curr.val == val:
            prev.next = curr.next  # 删除 curr 节点
        else:
            prev = curr
        curr = curr.next

    return dummy.next  # 返回虚拟头节点的下一个节点，即新链表的头节点

# 测试用例
head = ListNode(1, ListNode(2, ListNode(6, ListNode(3, ListNode(4, ListNode(5, ListNode(6)))))))
result = removeElements(head, 6)
```

#### 复杂度分析

- **时间复杂度**：O(N)，其中 N 是链表中的节点数量。我们需要遍历链表一次。
- **空间复杂度**：O(1)，我们只使用了常量级的额外空间。

#### 视频讲解：

[LeetCode：203.移除链表元素，203.Remove Linked List Elements | 《代码随想录》链表第一题](https://youtu.be/Y4oQJklHxVo?si=W-qmebSkiU4aDtp9)

#### 难点：

1. 为什么while的条件仅仅是curr不为None？而不是while curr and curr.next? 比如当curr已经是链表的末尾，如果末尾的val等于给定的val，那prev.next = curr.next不会出现问题吗？
2. 为什么return的是dummy.next而不是直接head？在这个过程中head不是已经更新完了吗？

#### 解答：

1. **为什么 `while` 循环的条件是 `curr != None` 而不是 `curr and curr.next`？**

   循环条件 `curr != None` 用于确保我们检查链表中的每个节点。当 `curr` 是链表的最后一个节点时，我们仍然需要检查它的值是否等于 `val`。如果是，则需要将 `prev.next` 指向 `None`（即 `curr.next`），这样就可以正确地移除链表末尾的节点。即使 `curr` 是链表的最后一个节点（`curr.next` 为 `None`），此操作仍然有效，因为它相当于将 `prev.next` 设置为 `None`，这正是我们希望的结果。

2. **为什么返回 `dummy.next` 而不是 `head`？**

   虚拟头节点 `dummy` 的引入是为了简化代码，特别是在处理删除原链表头节点的情况时。如果 `head` 的值等于 `val`，那么 `head` 节点将被删除。在这种情况下，原始的 `head` 已不再是新链表的头节点。虚拟头节点 `dummy` 的 `next` 将指向新链表的真正头节点。因此，我们返回 `dummy.next` 以确保无论原始 `head` 是否被删除，都能正确返回新链表的头节点。

---

### [707.设计链表](https://leetcode.com/problems/design-linked-list/)

你可以选择使用单链表或者双链表，设计并实现自己的链表。

单链表中的节点应该具备两个属性：`val` 和 `next` 。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。

如果是双向链表，则还需要属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点下标从 **0** 开始。

实现 `MyLinkedList` 类：

- `MyLinkedList()` 初始化 `MyLinkedList` 对象。
- `int get(int index)` 获取链表中下标为 `index` 的节点的值。如果下标无效，则返回 `-1` 。
- `void addAtHead(int val)` 将一个值为 `val` 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
- `void addAtTail(int val)` 将一个值为 `val` 的节点追加到链表中作为链表的最后一个元素。
- `void addAtIndex(int index, int val)` 将一个值为 `val` 的节点插入到链表中下标为 `index` 的节点之前。如果 `index` 等于链表的长度，那么该节点会被追加到链表的末尾。如果 `index` 比长度更大，该节点将 **不会插入** 到链表中。
- `void deleteAtIndex(int index)` 如果下标有效，则删除链表中下标为 `index` 的节点。

**示例：**

**输入**

["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"]

[[], [1], [3], [1, 2], [1], [1], [1]]

**输出**

[null, null, null, null, 2, null, 3]

**解释**

MyLinkedList myLinkedList = new MyLinkedList();

myLinkedList.addAtHead(1);

myLinkedList.addAtTail(3);

myLinkedList.addAtIndex(1, 2);    // 链表变为 1->2->3

myLinkedList.get(1);              // 返回 2

myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1->3

myLinkedList.get(1);              // 返回 3

**提示：**

- `0 <= index, val <= 1000`
- 请不要使用内置的 LinkedList 库。
- 调用 `get`、`addAtHead`、`addAtTail`、`addAtIndex` 和 `deleteAtIndex` 的次数不超过 `2000` 。

#### 解题思路：

- `__init__`: 初始化链表对象，创建虚拟头节点和初始大小。
- `get(index)`: 返回链表中第 `index` 个节点的值。如果索引无效，则返回 `-1`。
- `addAtHead(val)`: 在链表头部添加一个节点。
- `addAtTail(val)`: 在链表尾部添加一个节点。
- `addAtIndex(index, val)`: 在链表的指定位置 `index` 插入一个新节点。如果 `index > size`，则不插入节点；如果 `index < 0`，则在头部插入节点。
- `deleteAtIndex(index)`: 如果索引有效，删除链表中的第 `index` 个节点。

```python
class ListNode:
    # 定义链表节点
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class MyLinkedList:
    # 初始化链表
    def __init__(self):
        self.size = 0  # 维护链表的长度
        self.head = ListNode(0)  # 创建虚拟头节点，简化插入和删除操作

    # 获取链表中指定位置的节点值
    def get(self, index: int) -> int:
        if index < 0 or index >= self.size:
            return -1  # 索引无效时返回-1

        current = self.head
        # 遍历链表以到达指定位置
        for _ in range(index + 1):
            current = current.next
        return current.val

    # 在链表头部添加节点
    def addAtHead(self, val: int) -> None:
        self.addAtIndex(0, val)

    # 在链表尾部添加节点
    def addAtTail(self, val: int) -> None:
        self.addAtIndex(self.size, val)

    # 在链表指定位置添加节点
    def addAtIndex(self, index: int, val: int) -> None:
        if index > self.size:
            return  # 如果索引超出链表长度，则不进行插入

        index = max(0, index)  # 确保索引非负
        self.size += 1
        pred = self.head
        # 移动到指定位置的前一个节点
        for _ in range(index):
            pred = pred.next

        # 创建新节点并执行插入操作
        to_add = ListNode(val)
        to_add.next = pred.next
        pred.next = to_add

    # 删除链表中指定位置的节点
    def deleteAtIndex(self, index: int) -> None:
        if index < 0 or index >= self.size:
            return  # 如果索引无效，则不进行删除

        self.size -= 1
        pred = self.head
        # 移动到指定位置的前一个节点
        for _ in range(index):
            pred = pred.next

        # 删除操作
        pred.next = pred.next.next
```

#### 复杂度分析

- 对于 `addAtHead` 和 `addAtTail` 方法，时间复杂度为 O(1)。
- 对于 `get`、`addAtIndex` 和 `deleteAtIndex` 方法，时间复杂度最坏情况下为 O(N)，其中 N 是链表的长度。这是因为在最坏情况下，这些操作可能需要遍历整个链表。

#### 视频讲解：

[LeetCode：707. Design Linked List（设计链表），帮你把链表操作学个通透！](https://youtu.be/6DQ9dqyCCK8?si=Pn6saiwej5ZBrd2A)

### 可能的错误和疑难点

1. **处理边界条件**：在实现链表时，特别需要注意边界条件的处理，比如索引超出链表长度、删除或添加时的特殊情况处理等。
2. **虚拟头节点的使用**：使用虚拟头节点可以简化很多操作，尤其是在链表头部进行添加和删除操作时。如果不使用虚拟头节点，则需要分别处理这些情况。
3. **索引的有效性检查**：在 `get`、`deleteAtIndex`、`addAtIndex` 等方法中，都需要检查给定的索引是否有效。这是防止数组越界错误的关键步骤。
4. **链表长度的维护**：在添加和删除节点时，要正确更新链表的长度 `size`。这对于避免无效操作和确保索引有效性检查的准确性至关重要。
5. **指针操作的准确性**：在链表中执行添加和删除操作时，需要正确地更新节点的 `next` 指针。错误的指针操作可能导致链表断裂或形成循环链表。

---

### [206.反转链表](https://leetcode.com/problems/reverse-linked-list/)

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例 1：**

**输入**：head = [1,2,3,4,5]

**输出：**[5,4,3,2,1]

**示例 2:**

输入：head = [1,2]

**输出：**[2,1]

**示例 3：**

输入：head = []

**输出：**[]

**提示：**

- 链表中节点的数目范围是 `[0, 5000]`
- `-5000 <= Node.val <= 5000`

进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

### 迭代方法

#### 解题步骤

1. 初始化两个指针 `prev` 和 `curr`。`prev` 初始化为 `None`，`curr` 初始化为链表的头节点 `head`。
2. 遍历链表。在每个迭代中，暂时保存 `curr` 的下一个节点（因为在操作过程中会丢失）。
3. 将 `curr` 的 `next` 指向 `prev`，实现反转。
4. 移动 `prev` 和 `curr`。将 `prev` 移动到 `curr`，将 `curr` 移动到下一个节点。
5. 当 `curr` 为 `None` 时，链表遍历完成，返回新链表的头节点 `prev`。

#### 代码实现及注释

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseList(head):
    prev = None  # 初始化前驱节点为 None
    curr = head  # 当前节点为头节点

    while curr:
        next = curr.next  # 暂存下一个节点
        curr.next = prev  # 反转指针
        prev = curr  # 前驱节点前移
        curr = next  # 当前节点前移

    return prev  # 新的头节点是最后的前驱节点
```

### 递归方法

#### 解题步骤

1. 判断基准情况：如果 `head` 为 `None` 或 `head.next` 为 `None`，直接返回 `head`。
2. 递归地反转 `head.next` 指向的链表。
3. 将 `head.next`（即反转后链表的尾节点）的 `next` 指向 `head`，实现反转。
4. 将 `head` 的 `next` 设置为 `None`，防止链表循环。
5. 返回新链表的头节点，即递归调用的返回值。

#### 代码实现及注释

```python
def reverseListRecursive(head):
    if not head or not head.next:  # 基准情况
        return head

    p = reverseListRecursive(head.next)  # 递归反转
    head.next.next = head  # 反转指针
    head.next = None  # 避免链表循环

    return p  # 返回新的头节点
```

### 疑难点总结

1. **指针丢失**：在迭代方法中，如果不先保存 `curr.next`，反转指针后将无法访问后续节点。
2. **递归终止条件**：递归方法中需要正确设置终止条件，防止出现无限递归的情况。
3. **递归调用栈**：递归方法使用的栈空间与链表长度成正比，对于非常长的链表可能会导致栈溢出。
4. **新链表头节点的确定**：无论是迭代还是递归方法，都需要正确返回新链表的头节点。

这两种方法都有各自的优势：迭代方法空间效率高，递归方法代码更简洁。在面对实际问题时，可以根据具体情况选择合适的方法。

#### 视频讲解：

[帮你拿下反转链表 | LeetCode：206.反转链表 | 206. Reverse Linked List | 双指针法 | 递归法](https://youtu.be/nc4xpiOC4SA?si=A-rXsGmaUNTBKsJX)

#### 代码随想录算法训练营第四天 | 24. 两两交换链表中的节点， 19.删除链表的倒数第N个节点， 面试题 02.07. 链表相交， 142.环形链表II

#### ● day 4 任务以及具体安排：[第二章 链表part02](https://docs.qq.com/doc/DUFNjYUxYRHRVWklp) (12.16)

# 第二章 链表part02

●  day 1 任务以及具体安排：[https://docs.qq.com/doc/DUG9UR2ZUc3BjRUdY](https://docs.qq.com/doc/DUG9UR2ZUc3BjRUdY)

●  day 2 任务以及具体安排：[https://docs.qq.com/doc/DUGRwWXNOVEpyaVpG](https://docs.qq.com/doc/DUGRwWXNOVEpyaVpG)

●  day 3 任务以及具体安排：[https://docs.qq.com/doc/DUGdqYWNYeGhlaVR6](https://docs.qq.com/doc/DUGdqYWNYeGhlaVR6)

#### 今日任务

●  24. 两两交换链表中的节点

●  19.删除链表的倒数第N个节点

●  面试题 02.07. 链表相交

●  142.环形链表II

●  总结

#### 详细布置

#### 24. 两两交换链表中的节点

用虚拟头结点，这样会方便很多。

本题链表操作就比较复杂了，建议大家先看视频，视频里我讲解了注意事项，为什么需要temp保存临时节点。

题目链接/文章讲解/视频讲解： [https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html](https://programmercarl.com/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html)

#### 19.删除链表的倒数第N个节点

双指针的操作，要注意，删除第N个节点，那么我们当前遍历的指针一定要指向 第N个节点的前一个节点，建议先看视频。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html](https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html)

#### 面试题 02.07. 链表相交

本题没有视频讲解，大家注意 数值相同，不代表指针相同。

题目链接/文章讲解：[https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html](https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html)

#### 142.环形链表II

算是链表比较有难度的题目，需要多花点时间理解 确定环和找环入口，建议先看视频。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html](https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html)

[Just a moment...](https://chat.openai.com/share/14709780-cacf-4a30-8809-0b0b63375d9f)

---

### [24. 两两交换链表中的节点](https://leetcode.com/problems/swap-nodes-in-pairs/)

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

**示例 1：**

输入：head = [1,2,3,4]

**输出：**[2,1,4,3]

**示例 2：**

输入：head = []

**输出：**[]

**示例 3：**

输入：head = [1]

**输出：**[1]

**提示：**

- 链表中节点的数目在范围 `[0, 100]` 内
- `0 <= Node.val <= 100`

#### 递归解法

#### 解题思路：

1. **基本操作**：交换当前头两个节点。
2. **递归调用**：对后续节点进行同样的操作。
3. **终止条件**：当到达链表末尾或只剩一个节点时，递归结束。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def swapPairs(head):
    # 递归终止条件：链表为空或只有一个节点
    if not head or not head.next:
        return head

    # 交换节点
    first_node = head
    second_node = head.next

    # 递归交换后续节点，并更新当前节点的下一节点
    first_node.next = swapPairs(second_node.next)
    second_node.next = first_node

    # 返回新的头节点
    return second_node
```

#### 疑难点：

- 递归方法可能会有理解上的困难，尤其是如何处理链表节点的链接和断开。
- 需要理解递归的终止条件。

#### 迭代解法

#### 解题思路：

1. **创建哨兵节点**：哨兵节点指向原始头节点，简化边界情况处理。
2. **遍历链表**：每次交换两个相邻节点。
3. **更新指针**：保持三个指针（前一节点、当前节点、下一节点）的正确引用。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def swapPairs(head):
    dummy = ListNode(0)
    dummy.next = head
    prev_node = dummy
    # dummy → 1 → 2 → 3 → 4
    #   ↑     ↑
    # prev   head

    # 当前节点和下一节点都不为空时继续遍历
    while head and head.next:
        first_node = head
        second_node = head.next
          # dummy → 1 → 2 → 3 → 4
          #   ↑     ↑   ↑
          # prev   1st 2nd

        # 交换两个节点
        prev_node.next = second_node
        first_node.next = second_node.next
        second_node.next = first_node
        # dummy → 2 → 1 → 3 → 4
        #   ↑     ↑   ↑
        # prev   2nd 1st

        # 更新指针
        prev_node = first_node
        head = first_node.next
        # dummy → 2 → 1 → 3 → 4
        #                 ↑   ↑
        #               prev head

    return dummy.next
```

#### 疑难点：

- 迭代方法需要维护额外的指针（如 `prev_node`）以保持链表的正确连接。
- 在节点交换过程中，正确地更新各个指针的指向是关键。

#### 两两交换链表中节点的可视化

当然可以。为了帮助您更好地理解“两两交换链表中的节点”这个问题的迭代解法，我将通过文字和箭头对每一步进行可视化。考虑链表 `[1, 2, 3, 4]`，我们希望交换得到 `[2, 1, 4, 3]`。

1. **初始化状态**:
   - 创建一个哨兵（dummy）节点指向链表的头节点。
   - `prev_node` 指向 dummy，`head` 指向第一个节点 1。

```other
dummy → 1 → 2 → 3 → 4
 ↑
prev_node
head
```

2. **第一次循环**:
   - 设 `first_node` 为 1，`second_node` 为 2。
   - 交换 1 和 2，将 `prev_node` 的 `next` 指向 2，然后将 1 的 `next` 指向 3（即 `second_node.next`）。
   - 更新 `second_node` 的 `next` 指向 1。

```other
dummy → 2 → 1 → 3 → 4
           ↑
          prev_node
           ↑
          head
```

   - 更新 `prev_node` 到 1，`head` 到 3。

```other
dummy → 2 → 1 → 3 → 4
               ↑   ↑
          prev_node head
```

3. **第二次循环**:
   - 设 `first_node` 为 3，`second_node` 为 4。
   - 交换 3 和 4，将 `prev_node` 的 `next` 指向 4，然后将 3 的 `next` 指向 `None`（即 `second_node.next`）。
   - 更新 `second_node` 的 `next` 指向 3。

```other
dummy → 2 → 1 → 4 → 3
                   ↑
                  prev_node
                   ↑
                  head
```

   - 循环结束，因为 `head`（现在指向 3）的 `next` 是 `None`。
4. **最终链表**:
   - 返回 `dummy.next`，也就是新链表的头节点，现在链表变成了 `[2, 1, 4, 3]`。

```other
dummy → 2 → 1 → 4 → 3
```

这个过程中，每一步都小心地更新了相关指针，确保了链表的结构在交换节点时保持不变。希望这个解释有助于您更好地理解这个算法。如果您还有其他疑问，欢迎继续提问！

#### 复杂度分析

对于两种方法：

- 时间复杂度：O(N)，其中 N 是链表中的节点数量。
- 空间复杂度：递归方法为 O(N)（递归栈空间），迭代方法为 O(1)。

#### 视频讲解：

[帮你把链表细节学清楚！ | LeetCode:24. Swap Nodes in Pairs | 24. 两两交换链表中的节点](https://youtu.be/GI1Ghz7Lej0?si=4bOAhb3Au1SjpJnu)

---

### [19.删除链表的倒数第N个节点](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**示例 1：**

输入：head = [1,2,3,4,5], n = 2

**输出：**[1,2,3,5]

**示例 2：**

输入：head = [1], n = 1

**输出：**[]

**示例 3：**

输入：head = [1,2], n = 1

**输出：**[1]

**提示：**

- 链表中结点的数目为 `sz`
- `1 <= sz <= 30`
- `0 <= Node.val <= 100`
- `1 <= n <= sz`

进阶：你能尝试使用一趟扫描实现吗？

#### **算法步骤**

1. **初始化哨兵节点：创建一个哨兵节点（dummy node），并让它指向链表头部。这有助于简化头节点可能被删除的边界情况。**
2. **设置快慢指针：初始化两个指针，快指针（fast）和慢指针（slow），让它们都指向哨兵节点。**
3. **移动快指针：先将快指针向前移动 N+1 步。**
4. **同时移动快慢指针：同时移动快慢指针，直到快指针指向链表末尾的 null。此时，慢指针指向要删除节点的前一个节点。**
5. **删除节点：更改慢指针的 `next` 指针，使其指向要删除节点的下一个节点。**
6. **返回结果：返回哨兵节点的下一个节点，即更新后的链表头节点。**

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def removeNthFromEnd(self, head, n):
        dummy = ListNode(0, head)
        slow = fast = dummy

        # 将快指针向前移动 n+1 步
        for _ in range(n + 1):
            fast = fast.next

        # 同时移动快慢指针
        while fast:
            slow = slow.next
            fast = fast.next

        # 删除倒数第 n 个节点
        slow.next = slow.next.next

        return dummy.next

# 示例 1
head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))
n = 2
result = Solution().removeNthFromEnd(head, n)
# 应输出 [1, 2, 3, 5]

# 示例 2
head = ListNode(1)
n = 1
result = Solution().removeNthFromEnd(head, n)
# 应输出 []

# 示例 3
head = ListNode(1, ListNode(2))
n = 1
result = Solution().removeNthFromEnd(head, n)
# 应输出 [1]
```

#### 复杂度分析

- 时间复杂度：O(L)，其中 L 是链表的长度。我们只需要一趟遍历。
- 空间复杂度：O(1)，我们只需要常量级的额外空间。

#### 视频讲解

[链表遍历学清楚！ | LeetCode：19. Remove Nth Node From End of List | 19.删除链表倒数第N个节点](https://youtu.be/oMzRxtXvDbA?si=7VB-7Y-_CKT8DoRq)

---

### [面试题 02.07. 链表相交](https://leetcode.com/problems/intersection-of-two-linked-lists/)

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交：

![Image.png](https://assets.leetcode.com/uploads/2021/03/05/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

**示例 1：**

![Image.png](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3

输出：Intersected at '8'

解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。

从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。

在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

**示例 2：**

![Image.png](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)

输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1

输出：Intersected at '2'

解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。

从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。

在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。

**示例 3：**

![Image.png](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)

输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2

输出：null

解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。

由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。

这两个链表不相交，因此返回 null 。

**提示：**

- `listA` 中节点数目为 `m`
- `listB` 中节点数目为 `n`
- `0 <= m, n <= 3 * 104`
- `1 <= Node.val <= 105`
- `0 <= skipA <= m`
- `0 <= skipB <= n`
- 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`
- 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA + 1] == listB[skipB + 1]`

进阶：你能否设计一个时间复杂度 `O(n)` 、仅用 `O(1)` 内存的解决方案？

#### 算法思路

1. **创建两个指针**：分别指向两个链表的头节点 headA 和 headB。
2. **同时遍历两个链表**：当任一指针达到链表末尾时，将其重置到另一个链表的头节点。这样做的目的是平衡两个链表的长度差。
3. **寻找交点**：如果两个链表相交，那么这两个指针最终会在相交点相遇。如果不相交，它们会同时到达各自链表的末尾（即都指向 null）。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        if not headA or not headB:
            return None

        pointerA, pointerB = headA, headB

        while pointerA is not pointerB:
            # 当指针到达链表末尾时，切换到另一个链表的头节点
            pointerA = pointerA.next if pointerA else headB
            pointerB = pointerB.next if pointerB else headA

        return pointerA
```

#### 算法解释

- **两个指针**：在两个链表上移动，如果一个链表较长，则较短的链表的指针会先到达末尾。此时，将其移动到另一个链表的头部继续遍历。这样可以保证两个指针遍历的总长度相同。
- **寻找交点**：如果链表相交，两个指针最终会在相交点相遇。如果不相交，它们会同时指向 null。

#### 复杂度分析

- **时间复杂度**：O(N + M)，其中 N 和 M 是两个链表的长度。最坏情况下，每个指针遍历两个链表各一次。
- **空间复杂度**：O(1)，只使用了常量级别的额外空间。

#### 讲解文章：

[代码随想录](https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html#%E6%80%9D%E8%B7%AF)

---

### [142.环形链表II](https://leetcode.com/problems/linked-list-cycle-ii/)

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

**示例 1：**

![Image.png](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

输入：head = [3,2,0,-4], pos = 1

输出：返回索引为 1 的链表节点

解释：链表中有一个环，其尾部连接到第二个节点。

**示例 2：**

![Image.png](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png)

输入：head = [1,2], pos = 0

输出：返回索引为 0 的链表节点

解释：链表中有一个环，其尾部连接到第一个节点。

**示例 3：**

![Image.png](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png)

输入：head = [1], pos = -1

输出：返回 null

解释：链表中没有环。

**提示：**

- 链表中节点的数目范围在范围 `[0, 104]` 内
- `-105 <= Node.val <= 105`
- `pos` 的值为 `-1` 或者链表中的一个有效索引

进阶：你是否可以使用 `O(1)` 空间解决此题？

#### 算法思路

1. **使用两个指针**：一个快指针（每次移动两步）和一个慢指针（每次移动一步）。
2. **检测环**：如果链表中存在环，那么快指针和慢指针最终会相遇。
3. **找到环的入口**：
   - 当快慢指针首次相遇时，将快指针重置回头节点。
   - 然后，快指针和慢指针都改为每次移动一步。
   - 当快慢指针再次相遇时，它们位于环的入口。

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        if not head:
            return None

        slow, fast = head, head
        # 使用快慢指针检测环
        while fast and fast.next:
            slow = slow.next      # 慢指针每次移动一步
            fast = fast.next.next # 快指针每次移动两步

            # 当快慢指针相遇时，表示链表有环
            if slow == fast:
                fast = head
                # 将快指针重置到头节点，然后快慢指针同速前进
                while fast != slow:
                    fast = fast.next
                    slow = slow.next
                # 当快慢指针再次相遇时，即为环的入口
                return slow

        # 如果没有环，返回 None
        return None
```

#### 算法解释

- 当快慢指针首次相遇时，快指针已经比慢指针多走了环的长度的整数倍。
- 重置快指针到头节点，并让它和慢指针都以同样的速度移动，它们最终会在环的入口相遇。

#### 复杂度分析

- **时间复杂度**：O(N)，其中 N 是链表中的节点数量。最坏的情况是，我们需要遍历整个链表才能找到环的入口。
- **空间复杂度**：O(1)，我们只使用了两个指针，因此空间复杂度为常数级。

#### 视频讲解：

[把环形链表讲清楚！ 如何判断环形链表？如何找到环形链表的入口？ LeetCode：142. Linked List Cycle II （142. 环形链表 II）](https://youtu.be/ZJDClARjgDI?si=2NUYsfZsfhWfhwKz)

![Image.gif](https://code-thinking.cdn.bcebos.com/gifs/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II%EF%BC%88%E6%B1%82%E5%85%A5%E5%8F%A3%EF%BC%89.gif)

#### 疑难点和易错点

1. **快慢指针的初始化**：快慢指针都应该从头节点开始。错误的初始化位置可能导致错误的结果。
2. **检测环的存在**：当快指针或者快指针的下一个节点为 null 时，表示链表无环。这是循环的终止条件。
3. **快慢指针再次相遇的位置即为环的入口**：这是基于数学上的证明。当快慢指针第一次相遇时，假设慢指针走了 k 步，则快指针走了 2k 步，也就是说快指针比慢指针多走了 k 步，这 k 步就是环的长度的倍数。因此，当我们将快指针重新置于头节点，然后快慢指针都一步步前进时，它们最终会在环的入口相遇。
4. **循环条件的编写**：循环应当在 `fast` 和 `fast.next` 都不为 null 的情况下继续，以避免访问 null 节点的 `next` 属性，这可能会导致运行时错误。

### 第三章：哈希表

#### 代码随想录算法训练营第六天 | 242.有效的字母异位词， 349. 两个数组的交集， 202. 快乐数， 1. 两数之和

#### ● day 6 任务以及具体安排：[第三章 哈希表part01](https://docs.qq.com/doc/DUEtFSGdreWRuR2p4) (12.18)

# 第三章 哈希表part01

#### 今日任务

●  哈希表理论基础

●  242.有效的字母异位词

●  349. 两个数组的交集

●  202. 快乐数

●  1. 两数之和

#### 详细布置

#### 哈希表理论基础

建议：大家要了解哈希表的内部实现原理，哈希函数，哈希碰撞，以及常见哈希表的区别，数组，set 和map。

什么时候想到用哈希法，当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。  这句话很重要，大家在做哈希表题目都要思考这句话。

文章讲解：[https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html](https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)

#### 242.有效的字母异位词

建议： 这道题目，大家可以感受到 数组 用来做哈希表 给我们带来的遍历之处。

题目链接/文章讲解/视频讲解： [https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html](https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html)

#### 349. 两个数组的交集

建议：本题就开始考虑 什么时候用set 什么时候用数组，本题其实是使用set的好题，但是后来力扣改了题目描述和 测试用例，添加了 0 <= nums1[i], nums2[i] <= 1000 条件，所以使用数组也可以了，不过建议大家忽略这个条件。 尝试去使用set。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html](https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html)

#### 202. 快乐数

建议：这道题目也是set的应用，其实和上一题差不多，就是 套在快乐数一个壳子

题目链接/文章讲解：[https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html](https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html)

#### 1. 两数之和

建议：本题虽然是 力扣第一题，但是还是挺难的，也是 代码随想录中 数组，set之后，使用map解决哈希问题的第一题。

建议大家先看视频讲解，然后尝试自己写代码，在看文章讲解，加深印象。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html](https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html)

[Just a moment...](https://chat.openai.com/share/9728fd5b-61dd-4cf0-898d-4e54f55dc40f)

---

#### 哈希表理论基础

哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素，如下图所示：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104234805168.png)

那么哈希表能解决什么问题呢，**一般哈希表都是用来快速判断一个元素是否出现集合里。**

例如要查询一个名字是否在这所学校里。

要枚举的话时间复杂度是O(n)，但如果使用哈希表的话， 只需要O(1)就可以做到。

我们只需要初始化把这所学校里学生的名字都存在哈希表里，在查询的时候通过索引直接就可以知道这位同学在不在这所学校里了。

将学生姓名映射到哈希表上就涉及到了**hash function ，也就是哈希函数**。

#### 哈希函数

哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。

哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/2021010423484818.png)

#### 哈希碰撞

如图所示，小李和小王都映射到了索引下标 1 的位置，**这一现象叫做哈希碰撞**。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/2021010423494884.png)

一般哈希碰撞有两种解决方法， 拉链法和线性探测法。

#### 拉链法

刚刚小李和小王在索引1的位置发生了冲突，发生冲突的元素都被存储在链表中。 这样我们就可以通过索引找到小李和小王了

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235015226.png)

其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。

#### 线性探测法

使用线性探测法，一定要保证tableSize大于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。

例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235109950.png)

其实关于哈希碰撞还有非常多的细节，感兴趣的同学可以再好好研究一下，这里我就不再赘述了。

#### 常见的三种哈希结构

当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。

- 数组
- set （集合）
- map(映射)

这里数组就没啥可说的了，我们来看一下set。

在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：

| 集合                 | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率     | 增删效率     |
| ------------------ | ---- | ---- | -------- | ------ | -------- | -------- |
| std::set           | 红黑树  | 有序   | 否        | 否      | O(log n) | O(log n) |
| std::multiset      | 红黑树  | 有序   | 是        | 否      | O(logn)  | O(logn)  |
| std::unordered_set | 哈希表  | 无序   | 否        | 否      | O(1)     | O(1)     |

std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。

| 映射                 | 底层实现 | 是否有序  | 数值是否可以重复 | 能否更改数值  | 查询效率     | 增删效率     |
| ------------------ | ---- | ----- | -------- | ------- | -------- | -------- |
| std::map           | 红黑树  | key有序 | key不可重复  | key不可修改 | O(logn)  | O(logn)  |
| std::multimap      | 红黑树  | key有序 | key可重复   | key不可修改 | O(log n) | O(log n) |
| std::unordered_map | 哈希表  | key无序 | key不可重复  | key不可修改 | O(1)     | O(1)     |

std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。

当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。

那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。

其他语言例如：java里的HashMap ，TreeMap 都是一样的原理。可以灵活贯通。

虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。

这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？

实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235134572.png)

#### 总结

总结一下，**当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法**。

但是哈希法也是**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。

如果在做面试题目的时候遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法！

---

### [242.有效的字母异位词](https://leetcode.com/problems/valid-anagram/)

给定两个字符串 `_s_` 和 `_t_` ，编写一个函数来判断 `_t_` 是否是 `_s_` 的字母异位词。

注意：若 `_s_` 和 `_t_` 中每个字符出现的次数都相同，则称 `_s_` 和 `_t_` 互为字母异位词。

**示例 1:**

**输入:** *s* = "anagram", *t* = "nagaram"

**输出:** true

**示例 2:**

**输入:** *s* = "rat", *t* = "car"

**输出:** false

**提示:**

- `1 <= s.length, t.length <= 5 * 104`
- `s` 和 `t` 仅包含小写字母

**进阶:** 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？

#### 方法 1：哈希表

我们可以使用哈希表（字典）来计数每个字符的出现次数。

1. 遍历字符串 *s* ，记录每个字符出现的次数。
2. 遍历字符串 *t* ，减少哈希表中相应字符的计数。
3. 如果任何时候计数变为负数，或者在遍历完 *t* 后，哈希表中还有非零值，那么 *s* 和 *t* 不是异位词。

Python 代码示例：

```python
def isAnagram(s, t):
    if len(s) != len(t):
        return False
    
    count = {}
    for char in s:
        count[char] = count.get(char, 0) + 1
    
    for char in t:
        if char not in count or count[char] == 0:
            return False
        count[char] -= 1
    
    return all(value == 0 for value in count.values())
```

#### 方法 2：排序

将两个字符串都按照字母顺序排序，然后比较它们是否相等。

1. 对 *s* 和 *t* 进行排序。
2. 比较排序后的字符串是否相等。

Python 代码示例：

```python
def isAnagram(s, t):
    return sorted(s) == sorted(t)
```

#### 进阶问题：Unicode 字符

如果字符串包含 Unicode 字符，我们仍然可以使用哈希表的方法来计数。但是，由于 Unicode 字符集比 ASCII 大得多，我们可能需要一个更高效的数据结构，例如默认字典（`collections.defaultdict`）或计数器（`collections.Counter`）。

Python 代码示例（使用 `collections.Counter`）：

```python
from collections import Counter

def isAnagram(s, t):
    return Counter(s) == Counter(t)
```

在所有这些方法中，哈希表方法在处理大字符集时最为灵活和高效。排序方法在字符串较短时简单有效，但在字符串较长时效率较低。对于大多数情况，哈希表方法是首选。

#### 视频讲解：

[学透哈希表，数组使用有技巧！| Leetcode:242. Valid Anagram | 有效的字母异位词](https://youtu.be/i1xH4AugmLI?si=D1HdWKm1xFikkCzT)

---

### [349. 两个数组的交集](https://leetcode.com/problems/intersection-of-two-arrays/)

给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。

**示例 1：**

输入：nums1 = [1,2,2,1], nums2 = [2,2]

**输出：**[2]

**示例 2：**

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]

**输出：**[9,4]

**解释：**[4,9] 也是可通过的

**提示：**

- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 1000`

要解决 LeetCode 349. 两个数组的交集问题，我们可以使用哈希表来解决。基本思路是使用两个集合（Set）来存储两个数组中的元素，然后找出它们的交集。集合自然地去除了重复元素，并且可以方便地进行交集运算。

#### 方法 1：使用集合

1. 将 `nums1` 和 `nums2` 转换为集合，去除重复元素。
2. 使用集合的交集操作找出共同元素。

Python 代码示例：

```python
def intersection(nums1, nums2):
    set1 = set(nums1)
    set2 = set(nums2)
    return list(set1 & set2)
```

#### 方法 2：排序和双指针

如果不能使用额外的数据结构，我们可以使用排序和双指针方法。

1. 首先对两个数组进行排序。
2. 使用两个指针分别遍历两个数组。
3. 如果两个指针指向的元素相同，则将其加入结果中，并移动两个指针；如果不相同，移动较小元素对应的指针。

Python 代码示例：

```python
def intersection(nums1, nums2):
    nums1.sort()
    nums2.sort()
    i, j = 0, 0
    result = set()

    while i < len(nums1) and j < len(nums2):
        if nums1[i] == nums2[j]:
            result.add(nums1[i])
            i += 1
            j += 1
        elif nums1[i] < nums2[j]:
            i += 1
        else:
            j += 1

    return list(result)
```

在这两种方法中，使用集合的方法在大多数情况下更为简单和直接。如果有额外的限制，如不能使用额外的数据结构，那么排序和双指针方法是一个很好的选择。

#### 视频讲解：

[学透哈希表，set使用有技巧！Leetcode:349. Intersection of Two Arrays | 两个数组的交集](https://youtu.be/VBEMhny9TEk?si=dFjQzQY2nEzwBtBk)

---

### [202. 快乐数](https://leetcode.com/problems/happy-number/)

编写一个算法来判断一个数 `n` 是不是快乐数。

**「快乐数」** 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。

如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。

**示例 1：**

输入：n = 19

输出：true

**解释：** 1^2 + 9^2 = 82

8^2 + 2^2 = 68

6^2 + 8^2 = 100

1^2 + 0^2 + 0^2 = 1

**示例 2：**

输入：n = 2

输出：false

**提示：**

- `1 <= n <= 231 - 1`

#### 解题思路：

要判断一个数是否是快乐数，我们可以使用“快慢指针”方法来检测是否存在循环。这个方法是基于两个事实：

1. 如果 `n` 是一个快乐数，最终会达到 1。
2. 如果 `n` 不是一个快乐数，最终会进入一个循环。

#### 方法：哈希表

1. **初始化哈希表**：用来存储每一步计算得到的平方和。
2. **计算平方和**：定义一个函数，计算并返回一个数字每个位上的数字的平方和。
3. **检测循环**：在每一步计算中，检查当前的平方和是否已经出现在哈希表中。
   - 如果出现了，表示我们进入了无限循环，因此不是快乐数。
   - 如果平方和为 1，表示找到了快乐数。
4. **更新哈希表**：如果没有进入无限循环也没有得到 1，那么将当前的平方和添加到哈希表中，继续计算下一步的平方和。

```python
def isHappy(n):
    def getSquareSum(number):
        """计算数字每位的平方和"""
        total_sum = 0
        while number > 0:
            number, digit = divmod(number, 10)
            total_sum += digit ** 2
        return total_sum

    seen = set()  # 初始化哈希表来存储平方和

    while n != 1 and n not in seen:
        seen.add(n)  # 将当前数添加到哈希表中
        n = getSquareSum(n)  # 计算下一个平方和

    return n == 1

# 测试
print(isHappy(19))  # True
print(isHappy(2))   # False

# 精简版本
 def isHappy(self, n: int) -> bool:
     seen = set()
     while n != 1:
         n = sum(int(i) ** 2 for i in str(n))
         if n in seen:
             return False
         seen.add(n)
     return True
```

#### 疑难点和易错点

1. **无限循环检测**：最容易出错的地方是没有正确检测到无限循环。如果我们错过了检测，程序可能会进入死循环。
2. **哈希表的使用**：正确使用哈希表来存储已经计算过的平方和是关键。如果重复计算了平方和，可能会错过检测循环的机会。
3. **边界条件处理**：在开始时，需要判断 `n` 是否为 1，如果是，直接返回 `True`。同样，当 `n` 进入循环时，应该返回 `False`。这两种情况都需要准确处理。

#### 方法：快慢指针

1. 创建两个指针，一个每次移动一步（慢指针），另一个每次移动两步（快指针）。
2. 如果 `n` 是一个快乐数，快指针最终将等于 1。
3. 如果 `n` 不是一个快乐数，快慢指针最终会相遇（进入同一个循环）。

Python 代码示例：

```python
def isHappy(n):
    def getNext(number):
        total_sum = 0
        while number > 0:
            number, digit = divmod(number, 10)
            total_sum += digit ** 2
        return total_sum

    slow = n
    fast = getNext(n)
    
    while fast != 1 and slow != fast:
        slow = getNext(slow)
        fast = getNext(getNext(fast))
    
    return fast == 1

# 测试
print(isHappy(19))  # True
print(isHappy(2))   # False
```

在这个方法中，我们不断地计算数字的平方和，直到找到循环或者数字变成 1。这是一个有效的方法来判断一个数是否为快乐数。

[代码随想录](https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html#%E6%80%9D%E8%B7%AF)

---

### 1. 两数之和

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** `target`  的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 1：**

输入：nums = [2,7,11,15], target = 9

**输出：**[0,1]

解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

**示例 2：**

输入：nums = [3,2,4], target = 6

**输出：**[1,2]

**示例 3：**

输入：nums = [3,3], target = 6

**输出：**[0,1]

**提示：**

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **只会存在一个有效答案**

**进阶：**你可以想出一个时间复杂度小于 `O(n2)` 的算法吗？

#### 解题步骤

1. **初始化哈希表**：用来存储已遍历过的元素及其索引。
2. **遍历数组**：对于数组中的每个元素 `num` 和它的索引 `i`：
   - 计算 `complement = target - num`（配对元素）。
   - 检查 `complement` 是否在哈希表中：
      - 如果在，返回当前索引 `i` 和 `complement` 的索引。
      - 如果不在，将 `num` 和索引 `i` 添加到哈希表中。
3. **返回结果**：如果找到有效答案，返回两个索引；否则返回空列表或异常。

```python
def twoSum(nums, target):
    num_to_index = {}  # 初始化哈希表

    for i, num in enumerate(nums):
        complement = target - num
        if complement in num_to_index:
            return [num_to_index[complement], i]  # 找到配对，返回索引
        num_to_index[num] = i  # 将元素和索引加入哈希表

    return []  # 没有找到有效答案

# 测试
print(twoSum([2,7,11,15], 9))  # [0, 1]
print(twoSum([3,2,4], 6))      # [1, 2]
print(twoSum([3,3], 6))        # [0, 1]
```

#### 疑难点和易错点

1. **哈希表的使用**：哈希表用于快速查找，这是减少时间复杂度的关键。
2. **检查配对元素**：在将一个元素添加到哈希表之前，先检查其配对元素是否已经存在。
3. **处理相同元素**：由于题目假设每种输入只对应一个答案，因此不需要考虑相同元素重复使用的情况。
4. **边界条件**：考虑数组长度小于 2 的情况。

#### 视频讲解

[梦开始的地方，Leetcode:1. Two Sum | 两数之和，学透哈希表，map使用有技巧！](https://youtu.be/7i61hQb6BZA?si=BV6Ze4ke8wox52rq)

#### 代码随想录算法训练营第七天 | 454.四数相加II， 383. 赎金信， 15. 三数之和， 18. 四数之和

#### ● day 7 任务以及具体安排：[第三章 哈希表part02](https://docs.qq.com/doc/DUElCb1NyTVpXa0Jj) (12.19)

#### 第三章 哈希表part02

#### 今日任务

●  454.四数相加II

●  383. 赎金信

●  15. 三数之和

●  18. 四数之和

●  总结

#### 详细布置

#### 454.四数相加II

建议：本题是 使用map 巧妙解决的问题，好好体会一下 哈希法 如何提高程序执行效率，降低时间复杂度，当然使用哈希法 会提高空间复杂度，但一般来说我们都是舍空间 换时间， 工业开发也是这样。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html](https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html)

#### 383. 赎金信

建议：本题 和 242.有效的字母异位词 是一个思路 ，算是拓展题

题目链接/文章讲解：[https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html](https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html)

#### 15. 三数之和

建议：本题虽然和 两数之和 很像，也能用哈希法，但用哈希法会很麻烦，双指针法才是正解，可以先看视频理解一下 双指针法的思路，文章中讲解的，没问题 哈希法很麻烦。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html](https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html)

#### 18. 四数之和

建议： 要比较一下，本题和 454.四数相加II 的区别，为什么 454.四数相加II 会简单很多，这个想明白了，对本题理解就深刻了。 本题 思路整体和 三数之和一样的，都是双指针，但写的时候 有很多小细节，需要注意，建议先看视频。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html](https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html)

[Just a moment...](https://chat.openai.com/share/a6b1bb22-98f9-4df7-93e3-c718fedd9514)

---

### [454.四数相加II](https://leetcode.com/problems/4sum-ii/)

给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：

- `0 <= i, j, k, l < n`
- `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`

**示例 1：**

输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]

输出：2

**解释：**

两个元组如下：

1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0

**示例 2：**

输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]

输出：1

**提示：**

- `n == nums1.length`
- `n == nums2.length`
- `n == nums3.length`
- `n == nums4.length`
- `1 <= n <= 200`
- `-228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228`

#### 解题步骤：

1. **创建哈希表**：我们将使用一个哈希表来存储来自`nums1`和`nums2`的数对的和及其出现的频率。
2. **填充哈希表**：
   - 遍历`nums1`和`nums2`。
   - 对于每一对数`(a, b)`，其中`a`来自`nums1`，`b`来自`nums2`，计算它们的和`sum = a + b`。
   - 将这个和存储在哈希表中，如果这个和已经在哈希表中存在，则增加其计数。
3. **计算补数**：
   - 初始化一个计数变量为0。
   - 遍历`nums3`和`nums4`。
   - 对于每一对数`(c, d)`，计算它们的补数`complement = -(c + d)`。
   - 如果这个补数在哈希表中存在，这意味着存在来自`nums1`和`nums2`的四元组可以与来自`nums3`和`nums4`的这对数形成和为零。
   - 将哈希表中补数的频率加到计数中。
4. **返回计数**：现在计数中保存的是总共可以形成和为零的四元组的数量。

```python
def fourSumCount(nums1, nums2, nums3, nums4):
    hash_map = {}
    count = 0

    # 使用nums1和nums2填充哈希表
    for a in nums1:
        for b in nums2:
            sum_ab = a + b
            hash_map[sum_ab] = hash_map.get(sum_ab, 0) + 1

    # 从nums3和nums4中计算补数
    for c in nums3:
        for d in nums4:
            complement = -(c + d)
            count += hash_map.get(complement, 0)

    return count
```

#### 时间复杂度分析：

- **O(n^2)**：两个嵌套循环用于填充哈希表和计算补数，都是O(n^2)的时间复杂度，其中n是输入数组的长度。

#### 空间复杂度分析：

- **O(n^2)**：在最坏的情况下，哈希表可能会存储多达n^2个不同的和。

#### 视频讲解：

[学透哈希表，map使用有技巧！LeetCode：454.四数相加II | 454. 4Sum II](https://youtu.be/7yUeF-nivls?si=fDVetQh_3ILASTVR)

---

### [383. 赎金信](https://leetcode.com/problems/ransom-note/)

给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。

如果可以，返回 `true` ；否则返回 `false` 。

`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。

**示例 1：**

输入：ransomNote = "a", magazine = "b"

输出：false

**示例 2：**

输入：ansomNote = "aa", magazine = "ab"

输出：false

**示例 3：**

输入：ransomNote = "aa", magazine = "aab"

输出：true

**提示：**

- `1 <= ransomNote.length, magazine.length <= 105`
- `ransomNote` 和 `magazine` 由小写英文字母组成

#### 解题步骤：

1. **创建并填充哈希表**：遍历`magazine`，对于每个字符，增加其在哈希表中的计数。
2. **检查ransomNote**：遍历`ransomNote`，对于每个字符，检查它是否在哈希表中，且次数大于0。
   - 如果字符存在且次数大于0，减少该字符在哈希表中的计数。
   - 如果字符不存在或次数为0，返回`false`。
3. **返回结果**：如果能够遍历完`ransomNote`且所有字符都满足条件，则返回`true`；否则返回`false`。

```python
def canConstruct(ransomNote, magazine):
    char_count = {}

    # 填充哈希表
    for char in magazine:
        char_count[char] = char_count.get(char, 0) + 1

    # 检查ransomNote
    for char in ransomNote:
        if char_count.get(char, 0) <= 0:
            return False
        char_count[char] -= 1

    return True
```

#### 时间复杂度分析：

- **O(N+M)**：其中N是`magazine`的长度，M是`ransomNote`的长度。我们需要分别遍历这两个字符串来填充哈希表和检查字符。

#### 空间复杂度分析：

- **O(1)**：虽然我们使用了哈希表，但由于输入限定为小写英文字母，哈希表的最大大小为26，因此可以认为是常数空间复杂度。

---

### [15. 三数之和](https://leetcode.com/problems/3sum/)

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请

你返回所有和为 `0` 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

**示例 1：**

输入：nums = [-1,0,1,2,-1,-4]

**输出：**[[-1,-1,2],[-1,0,1]]

**解释：**

nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。

nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。

nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。

不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。

注意，输出的顺序和三元组的顺序并不重要。

**示例 2：**

输入：nums = [0,1,1]

**输出：**[]

解释：唯一可能的三元组和不为 0 。

**示例 3：**

输入：nums = [0,0,0]

**输出：**[[0,0,0]]

解释：唯一可能的三元组和为 0 。

**提示：**

- `3 <= nums.length <= 3000`
- `-105 <= nums[i] <= 105`

#### 解题步骤：

1. **排序**：首先对数组进行排序。这样做的目的是为了方便后续操作，并且能够有效地避免重复元组的生成。
2. **遍历数组**：遍历排序后的数组，对于每一个元素`nums[i]`：
   - 如果`nums[i]`大于0，则后面不可能有三个数加和等于0，直接结束遍历。
   - 如果`i > 0`且`nums[i] == nums[i-1]`，则跳过此次循环以避免重复。
3. **双指针查找**：对于当前元素`nums[i]`，使用两个指针`left`和`right`，分别指向`i+1`和数组的最后一个元素。检查`nums[i] + nums[left] + nums[right]`的和：
   - 如果和为0，记录这个三元组，并移动`left`和`right`指针，同时跳过所有重复的元素。
   - 如果和小于0，增加`left`指针。
   - 如果和大于0，减少`right`指针。
4. **返回结果**：返回所有找到的满足条件的三元组。

```python
def threeSum(nums):
    nums.sort()  # 对数组进行排序
    result = []  # 用于存储结果的列表

    for i in range(len(nums)):
        if nums[i] > 0:
            break  # 如果当前数字大于0，则三数之和不可能为0，结束循环
        if i > 0 and nums[i] == nums[i - 1]:
            continue  # 跳过重复元素，避免重复的三元组

        left, right = i + 1, len(nums) - 1  # 使用双指针
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            if total < 0:
                left += 1  # 三数之和小于0，左指针右移
            elif total > 0:
                right -= 1  # 三数之和大于0，右指针左移
            else:
                result.append([nums[i], nums[left], nums[right]])  # 记录结果
                while left < right and nums[left] == nums[left + 1]:
                    left += 1  # 跳过重复元素
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1  # 跳过重复元素
                left += 1
                right -= 1

    return result  # 返回结果列表
```

#### 时间复杂度分析：

- **O(N^2)**：其中N是数组`nums`的长度。外层循环遍历一次数组，双指针在内层循环中最多遍历整个数组一次。

#### 空间复杂度分析：

- **O(logN)**：排序所需的空间复杂度为O(logN)。注意，这取决于具体的排序算法实现。

#### 视频教程：

[梦破碎的地方！| LeetCode：15.三数之和 | 15. 3Sum](https://youtu.be/9qXeWyMk5W4?si=idzhSVFfrX2Fjkgn)

---

### [18. 四数之和](https://leetcode.com/problems/4sum/)

给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：

- `0 <= a, b, c, d < n`
- `a`、`b`、`c` 和 `d` **互不相同**
- `nums[a] + nums[b] + nums[c] + nums[d] == target`

你可以按 **任意顺序** 返回答案 。

**示例 1：**

输入：nums = [1,0,-1,0,-2,2], target = 0

**输出：**[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]

**示例 2：**

输入：nums = [2,2,2,2,2], target = 8

**输出：**[[2,2,2,2]]

**提示：**

- `1 <= nums.length <= 200`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`

#### 解题步骤：

1. **排序**：首先对数组进行排序。
2. **遍历数组**：使用两层循环固定前两个数`nums[i]`和`nums[j]`。在固定的过程中，为了避免重复的四元组，需要跳过重复的元素。
3. **双指针查找**：对于当前固定的两个数，使用两个指针`left`和`right`，分别指向`j+1`和数组的最后一个元素。检查四数之和`nums[i] + nums[j] + nums[left] + nums[right]`与`target`的关系：
   - 如果和等于`target`，记录这个四元组，然后移动`left`和`right`指针，跳过所有重复的元素。
   - 如果和小于`target`，增加`left`指针。
   - 如果和大于`target`，减少`right`指针。
4. **返回结果**：返回所有找到的满足条件的四元组。

```python
def fourSum(nums, target):
    nums.sort()  # 对数组进行排序
    result = []  # 用于存储结果的列表

    # 外层循环，固定第一个数
    for i in range(len(nums) - 3):
        if i > 0 and nums[i] == nums[i - 1]:
            continue  # 跳过重复元素，避免重复的四元组

        # 第二层循环，固定第二个数
        for j in range(i + 1, len(nums) - 2):
            if j > i + 1 and nums[j] == nums[j - 1]:
                continue  # 跳过重复元素，避免重复的四元组

            left, right = j + 1, len(nums) - 1  # 双指针初始化
            while left < right:
                total = nums[i] + nums[j] + nums[left] + nums[right]
                if total < target:
                    left += 1  # 三数之和小于目标值，左指针右移
                elif total > target:
                    right -= 1  # 三数之和大于目标值，右指针左移
                else:
                    result.append([nums[i], nums[j], nums[left], nums[right]])  # 记录结果
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1  # 跳过重复元素
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1  # 跳过重复元素
                    left += 1
                    right -= 1

    return result  # 返回结果列表
```

#### 时间复杂度分析：

- **O(N^3)**：其中N是数组`nums`的长度。外层和第二层循环共同遍历了数组，而内层双指针在最坏情况下可能遍历整个数组。

#### 空间复杂度分析：

- **O(logN)**：排序所需的空间复杂度为O(logN)。注意，这取决于具体的排序算法实现。

#### 视频讲解：

[难在去重和剪枝！| LeetCode：18. 四数之和 | 4sum](https://youtu.be/OUN-YsRTXBI?si=89lKSc56OFS-YnQC)

### 第四章：字符串

#### 代码随想录算法训练营第八天 | 344.反转字符串， 541. 反转字符串II， 卡码网：54.替换数字，151.翻转字符串里的单词，  卡码网：55.右旋转字符串

#### ● day 8 任务以及具体安排：[第四章 字符串part01](https://docs.qq.com/doc/DUGdsY2JFaFhDRVZH) (12.20)

#### 第四章 字符串part01

#### 今日任务

●  344.反转字符串

●  541. 反转字符串II

●  卡码网：54.替换数字

●  151.翻转字符串里的单词

●  卡码网：55.右旋转字符串

#### 详细布置

#### 344.反转字符串

建议： 本题是字符串基础题目，就是考察 reverse 函数的实现，同时也明确一下 平时刷题什么时候用 库函数，什么时候 不用库函数

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html](https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html)

#### 541. 反转字符串II

建议：本题又进阶了，自己先去独立做一做，然后在看题解，对代码技巧会有很深的体会。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html](https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html)

#### 卡码网：54.替换数字

建议：对于线性数据结构，填充或者删除，后序处理会高效的多。好好体会一下。

题目链接/文章讲解：[https://programmercarl.com/kama54.%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97.html](https://programmercarl.com/kama54.%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97.html)

#### 151.翻转字符串里的单词

建议：这道题目基本把 刚刚做过的字符串操作 都覆盖了，不过就算知道解题思路，本题代码并不容易写，要多练一练。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html](https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html)

#### 卡码网：55.右旋转字符串

建议：题解中的解法如果没接触过的话，应该会想不到

题目链接/文章讲解：

[代码随想录](https://programmercarl.com/kama55.%E5%8F%B3%E6%97%8B%E5%AD%97%E7%AC%A6%E4%B8%B2.html)

[Just a moment...](https://chat.openai.com/share/bbd63db5-6711-4ab9-8e5a-97a730997794)

---

### [344.反转字符串](https://leetcode.com/problems/reverse-string/)

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。

不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)修改输入数组**、使用 O(1) 的额外空间解决这一问题。

**示例 1：**

输入：s = ["h","e","l","l","o"]

**输出：**["o","l","l","e","h"]

**示例 2：**

输入：s = ["H","a","n","n","a","h"]

**输出：**["h","a","n","n","a","H"]

**提示：**

- `1 <= s.length <= 105`
- `s[i]` 都是 [ASCII](https://baike.baidu.com/item/ASCII) 码表中的可打印字符

#### 解题思路

1. **题目分析**：题目要求原地反转字符数组，即不使用额外的数组空间，并且要求空间复杂度为 O(1)。
2. **解题方法**：使用双指针法，一个指针从数组开始，另一个从数组末尾开始，交换这两个指针所指向的字符，然后移动指针直到两指针相遇或交错。

#### 算法步骤

1. 初始化两个指针：`left = 0`，`right = len(s) - 1`。
2. 当 `left < right` 时，交换 `s[left]` 和 `s[right]`。
3. 将 `left` 向右移动一位，将 `right` 向左移动一位。
4. 重复步骤 2 和 3，直到 `left >= right`。

```python
def reverseString(s):
    left, right = 0, len(s) - 1
    while left < right:
        s[left], s[right] = s[right], s[left]
        left += 1
        right -= 1

# 示例
s1 = ["h","e","l","l","o"]
reverseString(s1)
print(s1)  # 输出：["o","l","l","e","h"]

s2 = ["H","a","n","n","a","h"]
reverseString(s2)
print(s2)  # 输出：["h","a","n","n","a","H"]

def reverseString(self, s: List[str]) -> None:
    stack = []
    for char in s:
        stack.append(char)
    for i in range(len(s)):
        s[i] = stack.pop()
```

#### 时间复杂度

- 时间复杂度：O(N)，其中 N 是数组的长度。只需要遍历数组的一半。
- 空间复杂度：O(1)，只使用了常数级别的额外空间。

#### 视频讲解

[字符串基础操作！ | LeetCode：344.反转字符串 344. Reverse String](https://youtu.be/aRDPtK8sx5g?si=U71qNoapvzkJ33YD)

---

### [541. 反转字符串II](https://leetcode.com/problems/reverse-string-ii/)

给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。

**示例 1：**

输入：s = "abcdefg", k = 2

**输出：**"bacdfeg"

**示例 2：**

输入：s = "abcd", k = 2

**输出：**"bacd"

**提示：**

- `1 <= s.length <= 104`
- `s` 仅由小写英文组成
- `1 <= k <= 104`

#### 解题思路

1. **周期性处理**：考虑到每 2k 个字符为一个周期，在这个周期中只反转前 k 个字符。
2. **边界条件处理**：需要特别注意字符串的末尾，它可能不足一个完整的周期。

#### 算法步骤

1. 遍历字符串，步长为 2k，即每次处理一个周期。
2. 对于每个周期，反转其前 k 个字符。如果周期内的字符数不足 k，则反转所有字符。
3. 注意检查字符串的末尾，以处理边界情况。

```python
def reverseStr(s, k):
    s = list(s)
    for i in range(0, len(s), 2*k):
        s[i:i + k] = reversed(s[i:i + k])
    return ''.join(s)

# 示例
print(reverseStr("abcdefg", 2))  # 输出："bacdfeg"
print(reverseStr("abcd", 2))     # 输出："bacd"
```

#### 时间复杂度

- 时间复杂度：O(N)，其中 N 是字符串的长度。每个字符都被访问一次。
- 空间复杂度：O(N)，用于将字符串转换为字符数组。

#### 注意点

- 在实现时，首先将字符串转换为字符数组，因为 Python 中的字符串是不可变的，而数组可以原地修改。
- `reversed()` 函数返回的是一个反转后的迭代器，需要通过 `list()` 或者 `''.join()` 转换为数组或字符串。

这种方法有效地利用了字符串的周期性特点，并处理了所有的边界情况。

#### 视频讲解

[字符串操作进阶！ | LeetCode：541. 反转字符串II | 541. Reverse String II](https://youtu.be/4-6vQ9kBYmk?si=3q3mqikfMVVLuDnk)

---

### 卡码网：54.替换数字

给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。

例如，对于输入字符串 "a1b2c3"，函数应该将其转换为 "anumberbnumbercnumber"。

对于输入字符串 "a5b"，函数应该将其转换为 "anumberb"

输入：一个字符串 s,s 仅包含小写字母和数字字符。

输出：打印一个新的字符串，其中每个数字字符都被替换为了number

样例输入：a1b2c3

样例输出：anumberbnumbercnumber

数据范围：1 <= s.length < 10000。

#### 算法步骤

1. 初始化一个空字符串 `result` 用于存储最终结果。
2. 遍历字符串 `s` 中的每个字符 `c`。
   - 如果 `c` 是一个数字（可以通过 `c.isdigit()` 判断），则在 `result` 中添加字符串 "number"。
   - 否则（即 `c` 是字母），将 `c` 直接添加到 `result` 中。
3. 返回 `result` 作为最终结果。

```python
def replaceDigits(s):
    result = ""
    for c in s:
        if c.isdigit():
            result += "number"
        else:
            result += c
    return result

# 示例
print(replaceDigits("a1b2c3"))  # 输出："anumberbnumbercnumber"
print(replaceDigits("a5b"))     # 输出："anumberb"
```

#### 时间复杂度

- 时间复杂度：O(N)，其中 N 是字符串 `s` 的长度。我们需要遍历整个字符串一次。
- 空间复杂度：O(N)，用于存储新字符串。在最坏情况下（字符串全部由数字组成），新字符串的长度可能是原字符串长度的几倍。

#### 注意点

- 在实际编码过程中，注意字符串的拼接可能会导致额外的时间开销。在一些语言中（如 Python），字符串拼接操作的效率较低，可能需要考虑使用更高效的字符串构建方法，如 Python 中的 `str.join()` 或 `StringBuffer` / `StringBuilder`（在 Java 中）。
- 考虑到题目的数据范围，此方法对于常见的输入长度是有效的。

---

### 151.翻转字符串里的单词

给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。

**单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。

返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。

注意：输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

**示例 1：**

输入：s = "`the sky is blue`"

**输出：**"`blue is sky the`"

**示例 2：**

输入：s = "  hello world  "

**输出：**"world hello"

解释：反转后的字符串中不能存在前导空格和尾随空格。

**示例 3：**

输入：s = "a good   example"

**输出：**"example good a"

解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。

**提示：**

- `1 <= s.length <= 104`
- `s` 包含英文大小写字母、数字和空格 `' '`
- `s` 中 **至少存在一个** 单词

#### 解题步骤

1. **去除多余空格**：由于输入字符串可能包含前导空格、尾随空格或单词间多个空格，首先需要去除这些多余的空格。
2. **分割单词**：将处理后的字符串按空格分割，得到单词列表。
3. **反转单词列表**：将单词列表反转。
4. **拼接字符串**：将反转后的单词列表重新拼接成字符串，单词之间用一个空格分隔。

```python
def reverseWords(s):
    # 分割单词并去除多余空格
    words = s.split()
    # 反转单词列表
    words.reverse()
    # 拼接字符串
    return ' '.join(words)

# 示例
print(reverseWords("the sky is blue"))          # 输出："blue is sky the"
print(reverseWords("  hello world  "))         # 输出："world hello"
print(reverseWords("a good   example"))        # 输出："example good a"

def reverseWords(self, s: str) -> str:
    s_list = s.split()
    left, right = 0, len(s_list)-1

    while left < right:
        s_list[left], s_list[right] = s_list[right], s_list[left]
        left += 1
        right -= 1

    return ' '.join(s_list)
```

#### 时间复杂度

- 时间复杂度：O(N)，其中 N 是字符串的长度。分割和反转操作的时间复杂度都是线性的。
- 空间复杂度：O(N)，用于存储分割后的单词列表。

#### 注意点

- 一定要注意去除字符串中的多余空格，这是符合题目要求的关键。
- Python 的 `split()` 方法在分割字符串时会自动去除多余的空格，这使得实现变得简洁。
- 在一些其他语言中，可能需要手动处理多余的空格，例如使用正则表达式等方法。

---

### 卡码网：55.右旋转字符串

字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。

例如，对于输入字符串 "abcdefg" 和整数 2，函数应该将其转换为 "fgabcde"。

输入：输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。

输出：输出共一行，为进行了右旋转操作后的字符串。

样例输入：

```other
2
abcdefg
```

样例输出：

```other
fgabcde
```

数据范围：1 <= k < 10000, 1 <= s.length < 10000;

为了让本题更有意义，提升一下本题难度：**不能申请额外空间，只能在本串上操作**。

要解决这个问题，我们可以使用一种称为“三次反转”的方法。首先，将整个字符串反转，然后分别反转前 k 个字符和剩余的字符。这样做的好处是，我们不需要申请额外的空间来完成这个操作，只需要在原字符串上操作即可。

#### 算法步骤

1. **反转整个字符串**：这是第一次反转，目的是将末尾的 k 个字符移动到字符串开头。
2. **反转字符串的前 k 个字符**：这是第二次反转，恢复这 k 个字符的原始顺序。
3. **反转字符串的剩余部分**：这是第三次反转，恢复除了前 k 个字符以外的部分的原始顺序。

```python
def rotateRight(s, k):
    # 定义一个辅助函数用于反转字符串中的指定部分
    def reverseSubstring(start, end):
        while start < end:
            s[start], s[end] = s[end], s[start]
            start += 1
            end -= 1

    n = len(s)
    s = list(s)  # 将字符串转换为字符数组，以便原地修改
    k = k % n  # 处理 k 大于字符串长度的情况
    reverseSubstring(0, n - 1)  # 反转整个字符串
    reverseSubstring(0, k - 1)  # 反转前 k 个字符
    reverseSubstring(k, n - 1)  # 反转剩余部分

    return ''.join(s)

# 示例
print(rotateRight("abcdefg", 2))  # 输出："fgabcde"
```

#### 时间复杂度

- 时间复杂度：O(N)，其中 N 是字符串的长度。虽然进行了三次反转，但每个字符最多被访问两次。
- 空间复杂度：O(1)，不考虑输入和输出的空间占用，所有操作都是在原字符串上进行的。

#### 注意点

- 由于在原字符串上操作，我们首先将字符串转换为字符数组（在 Python 中），以便原地修改字符。
- 需要处理 k 大于字符串长度的情况，这可以通过取模操作 (`k % n`) 来实现。
- 此方法不需要额外的空间来存储字符，符合题目要求。

#### 代码随想录算法训练营第九天 | 28. 实现 strStr()， 459.重复的子字符串

#### ● day 9 任务以及具体安排：[第四章 字符串part02](https://docs.qq.com/doc/DUHVXSnZNaXpVUHN4) (12.21)

#### 第四章 字符串part02

今日任务

● 28. 实现 strStr()

● 459.重复的子字符串

● 字符串总结

● 双指针回顾

#### 详细布置

#### 28. 实现 strStr()  （本题可以跳过）

因为KMP算法很难，大家别奢求 一次就把kmp全理解了，大家刚学KMP一定会有各种各样的疑问，先留着，别期望立刻啃明白，第一遍了解大概思路，二刷的时候，再看KMP会 好懂很多。

或者说大家可以放弃一刷可以不看KMP，今天来回顾一下之前的算法题目就可以。

因为大家 算法能力还没到，细扣 很难的算法，会把自己绕进去，就算别人给解释，只会激发出更多的问题和疑惑。所以大家先了解大体过程，知道这么回事， 等自己有 算法基础和思维了，在看多看几遍视频，慢慢就理解了。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html](https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html)

#### 459.重复的子字符串  （本题可以跳过）

本题算是KMP算法的一个应用，不过 对KMP了解不够熟练的话，理解本题就难很多。

我的建议是 KMP和本题，一刷的时候 ，可以适当放过，了解怎么回事就行，二刷的时候再来硬啃

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html](https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html)

#### 字符串总结

比较简单，大家读一遍就行

题目链接/文章讲解：[https://programmercarl.com/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93.html](https://programmercarl.com/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%80%BB%E7%BB%93.html)

#### 双指针回顾

此时我们已经做过10到双指针的题目了，来一起回顾一下，大家自己也总结一下双指针的心得

文章讲解：[https://programmercarl.com/%E5%8F%8C%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93.html](https://programmercarl.com/%E5%8F%8C%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93.html)

[Just a moment...](https://chat.openai.com/share/621eab24-a85c-4e0b-a3c2-f92a61aca5ea)

[Naive algorithm for Pattern Searching - GeeksforGeeks](https://www.geeksforgeeks.org/naive-algorithm-for-pattern-searching/)

[KMP Algorithm for Pattern Searching - GeeksforGeeks](https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/)

---

### [28. 实现 strStr()](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/)

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回  `-1` 。

**示例 1：**

输入：haystack = "sadbutsad", needle = "sad"

输出：0

**解释：**"sad" 在下标 0 和 6 处匹配。

第一个匹配项的下标是 0 ，所以返回 0 。

**示例 2：**

输入：haystack = "leetcode", needle = "leeto"

**输出：**-1

**解释：**"leeto" 没有在 "leetcode" 中出现，所以返回 -1 。

**提示：**

- `1 <= haystack.length, needle.length <= 104`
- `haystack` 和 `needle` 仅由小写英文字符组成

#### 方法一：暴力匹配

暴力匹配是最直接的方法，它通过遍历 `haystack` 来匹配 `needle` 的每个字符。

```python
def strStr(haystack, needle):
    n, m = len(haystack), len(needle)
    for i in range(n - m + 1):
        if haystack[i:i + m] == needle:
            return i
    return -1
```

#### 复杂度分析

- 时间复杂度：O((N - M) * M)，其中 N 是 `haystack` 的长度，M 是 `needle` 的长度。最坏情况下，我们需要遍历 `haystack` 中的每个长度为 M 的子串并比较。
- 空间复杂度：O(1)。

#### 方法二：KMP算法

#### KMP算法科普

KMP算法是一种用于字符串搜索的高效算法，它通过避免字符串匹配过程中的不必要比较来提高效率。核心思想在于，当出现不匹配时，可以利用已经匹配的部分信息，确定下一次比较的位置。

#### KMP算法的关键：最长相同前后缀（LSP）

在KMP算法中，我们需要预先计算一个名为“最长相同前后缀”的数组（Longest Suffix Prefix，简称LSP）。对于字符串 `needle` 的每个子串，LSP 数组记录该子串的最长相同前后缀的长度。举个例子，字符串 "abab" 的最长相同前后缀是 "ab"，其长度为2。

#### 如何构建LSP数组？

1. 初始化LSP数组，长度与 `needle` 相同，所有值初始化为0。
2. 遍历 `needle`，使用两个指针i和j比较字符：
   - 当 `needle[i] == needle[j]`，意味着我们找到了一个更长的相同前后缀，所以 `lsp[i] = j + 1`，然后两个指针都向前移动。
   - 当 `needle[i] != needle[j]`，需要回溯。j回溯到 `lsp[j - 1]`，这是因为更短的相同前后缀可能有助于找到匹配。

KMP (Knuth-Morris-Pratt) 算法是一种高效的字符串匹配算法，可以在 O(N + M) 的时间内解决问题。KMP 算法通过计算一个 "部分匹配表" 来减少比较的次数。

```python
def strStr(haystack, needle):
    def kmp_process(needle):
        """ 构建LSP数组 """
        l = len(needle)
        lsp = [0] * l  # 初始化LSP数组
        j = 0
        for i in range(1, l):
            while j > 0 and needle[i] != needle[j]:  # 回溯
                j = lsp[j - 1]
            if needle[i] == needle[j]:  # 找到相同前后缀
                j += 1
                lsp[i] = j
        return lsp

    if not needle:
        return 0

    lsp = kmp_process(needle)
    j = 0
    for i in range(len(haystack)):
        while j > 0 and haystack[i] != needle[j]:  # 回溯
            j = lsp[j - 1]
        if haystack[i] == needle[j]:
            j += 1
        if j == len(needle):  # 完整匹配
            return i - len(needle) + 1
    return -1
```

#### 复杂度分析

- 时间复杂度：O(N + M)，其中 N 是 `haystack` 的长度，M 是 `needle` 的长度。主要时间花费在预处理 `needle` 以生成 lsp 数组和进行实际的匹配上。
- 空间复杂度：O(M)，M 是 `needle` 的长度，用于存储 lsp 数组。

这两种方法各有优缺点。暴力匹配实现简单，但在最坏情况下可能较慢；而KMP算法更复杂，但通常更高效。针对不同的应用场景和性能要求，可以选择合适的方法。

#### KMP算法视频讲解

[帮你把KMP算法学个通透！（理论篇）](https://youtu.be/S3ckBIJG6fo?si=-F2vS_CygKG24WGi)

---

### [459.重复的子字符串](https://leetcode.com/problems/repeated-substring-pattern/)

给定一个非空的字符串 `s` ，检查是否可以通过由它的一个子串重复多次构成。

**示例 1:**

**输入:** s = "abab"

**输出:** true

**解释:** 可由子串 "ab" 重复两次构成。

**示例 2:**

**输入:** s = "aba"

**输出:** false

**示例 3:**

**输入:** s = "abcabcabcabc"

**输出:** true

**解释:** 可由子串 "abc" 重复四次构成。 (或子串 "abcabc" 重复两次构成。)

**提示：**

- `1 <= s.length <= 104`
- `s` 由小写英文字母组成

#### 方法一：字符串拼接查找

#### 解题思路

- **拼接字符串**：首先，将输入字符串 `s` 复制并拼接一次，形成新的字符串 `ss`（即 `s + s`）。
- **移除第一个和最后一个字符**：然后，从新字符串 `ss` 中移除第一个和最后一个字符，得到字符串 `s'`。
- **在 `s'` 中查找原字符串**：最后，检查原字符串 `s` 是否在 `s'` 中出现。如果 `s` 在 `s'` 中，则意味着 `s` 可以由它的一个子串重复多次构成。

```python
def repeatedSubstringPattern(s):
    return s in (s + s)[1:-1]

# 示例测试
print(repeatedSubstringPattern("abab"))       # True
print(repeatedSubstringPattern("aba"))        # False
print(repeatedSubstringPattern("abcabcabcabc"))  # True
```

#### 解释

这种方法的原理基于这样一个事实：如果字符串 `s` 可以由其子串重复多次构成，那么 `s` 必定是某个更长字符串（即 `s + s`）的一部分，并且这个更长的字符串去掉首尾各一个字符后，仍然包含 `s`。

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 是字符串 `s` 的长度。主要时间花费在字符串的拼接和子字符串的查找上。
- 空间复杂度：O(n)，用于存储拼接后的字符串。

#### 方法二：KMP 算法

#### 解题思路

1. **构建 LSP 数组**：首先，我们对输入字符串 `s` 构建一个 LSP 数组。
2. **利用 LSP 数组的性质**：如果 `s` 由它的一个子串重复多次构成，那么 LSP 数组的最后一个值（`lsp[len(s) - 1]`）会不等于0，并且这个值会是重复子串长度的整数倍。

```python
def repeatedSubstringPattern(s):
    def kmp_process(string):
        """ 构建 LSP 数组 """
        lsp = [0] * len(string)
        j = 0
        for i in range(1, len(string)):
            while j > 0 and string[i] != string[j]:
                j = lsp[j - 1]
            if string[i] == string[j]:
                j += 1
                lsp[i] = j
        return lsp

    lsp = kmp_process(s)
    lsp_val = lsp[-1]  # LSP 数组的最后一个值
    # 如果 lsp_val 不为 0 并且 s 的长度能够被 (长度 - lsp_val) 整除，则为重复子串
    return lsp_val != 0 and len(s) % (len(s) - lsp_val) == 0

# 示例测试
print(repeatedSubstringPattern("abab"))       # True
print(repeatedSubstringPattern("aba"))        # False
print(repeatedSubstringPattern("abcabcabcabc"))  # True
```

#### 复杂度分析

- 时间复杂度：O(n)，其中 n 是字符串 `s` 的长度。这是因为 KMP 算法的时间复杂度是线性的。
- 空间复杂度：O(n)，用于存储 LSP 数组。

这种方法利用了 KMP 算法的 LSP 数组来高效地解决问题。通过检查 LSP 数组的最后一个值，我们可以确定字符串是否由其子串重复构成。

#### 视频讲解

[帮你把KMP算法学个通透！（求next数组代码篇）](https://youtu.be/t6xa2p6fFS8?si=wpyWpqvIUpxC31es)

---

### Naïve Algorithm for Pattern Searching

```python
def search(pat, txt):
    M = len(pat)
    N = len(txt)
 
    # A loop to slide pat[] one by one */
    for i in range(N - M + 1):
        j = 0
 
        # For current index i, check
        # for pattern match */
        while(j < M):
            if (txt[i + j] != pat[j]):
                break
            j += 1
 
        if (j == M):
            print("Pattern found at index ", i)
 
 
# Driver's Code
if __name__ == '__main__':
    txt = "AABAACAADAABAAABAA"
    pat = "AABA"
     
    # Function call
    search(pat, txt)
```

### KMP Algorithm for Pattern Searching

```python
def KMPSearch(pat, txt):
    M = len(pat)
    N = len(txt)
 
    # create lps[] that will hold the longest prefix suffix
    # values for pattern
    lps = [0]*M
    j = 0  # index for pat[]
 
    # Preprocess the pattern (calculate lps[] array)
    computeLPSArray(pat, M, lps)
 
    i = 0  # index for txt[]
    while (N - i) >= (M - j):
        if pat[j] == txt[i]:
            i += 1
            j += 1
 
        if j == M:
            print("Found pattern at index " + str(i-j))
            j = lps[j-1]
 
        # mismatch after j matches
        elif i < N and pat[j] != txt[i]:
            # Do not match lps[0..lps[j-1]] characters,
            # they will match anyway
            if j != 0:
                j = lps[j-1]
            else:
                i += 1
 
 
# Function to compute LPS array
def computeLPSArray(pat, M, lps):
    len = 0  # length of the previous longest prefix suffix
 
    lps[0] = 0  # lps[0] is always 0
    i = 1
 
    # the loop calculates lps[i] for i = 1 to M-1
    while i < M:
        if pat[i] == pat[len]:
            len += 1
            lps[i] = len
            i += 1
        else:
            # This is tricky. Consider the example.
            # AAACAAAA and i = 7. The idea is similar
            # to search step.
            if len != 0:
                len = lps[len-1]
 
                # Also, note that we do not increment i here
            else:
                lps[i] = 0
                i += 1
 
 
# Driver code
if __name__ == '__main__':
    txt = "ABABDABACDABABCABAB"
    pat = "ABABCABAB"
    KMPSearch(pat, txt)
```

### 第五章：栈与队列

#### 代码随想录算法训练营第十天 | 232.用栈实现队列， 225. 用队列实现栈

#### ● day 10 任务以及具体安排： [第五章 栈与队列part01](https://docs.qq.com/doc/DUElqeHh3cndDbW1Q) (12.22)

#### 第五章 栈与队列part01

今日任务：

●  理论基础

●  232.用栈实现队列

●  225. 用队列实现栈

#### 理论基础

了解一下 栈与队列的内部实现机智，文中是以C++为例讲解的。

文章讲解：[https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html](https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)

#### 232.用栈实现队列

大家可以先看视频，了解一下模拟的过程，然后写代码会轻松很多。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html](https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html)

#### 225. 用队列实现栈

可以大家惯性思维，以为还要两个队列来模拟栈，其实只用一个队列就可以模拟栈了。

建议大家掌握一个队列的方法，更简单一些，可以先看视频讲解

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html](https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html)

[Just a moment...](https://chat.openai.com/share/474bb535-05f6-4e79-b85b-4fd24eb45ad4)

---

#### 栈与队列理论基础

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235346563.png)

那么我这里再列出四个关于栈的问题，大家可以思考一下。以下是以C++为例，使用其他编程语言的同学也对应思考一下，自己使用的编程语言里栈和队列是什么样的。

1. C++中stack 是容器么？
2. 我们使用的stack是属于哪个版本的STL？
3. 我们使用的STL中stack是如何实现的？
4. stack 提供迭代器来遍历stack空间么？

相信这四个问题并不那么好回答， 因为一些同学使用数据结构会停留在非常表面上的应用，稍稍往深一问，就会有好像懂，好像也不懂的感觉。

有的同学可能仅仅知道有栈和队列这么个数据结构，却不知道底层实现，也不清楚所使用栈和队列和STL是什么关系。

所以这里我再给大家扫一遍基础知识，

首先大家要知道 栈和队列是STL（C++标准库）里面的两个数据结构。

C++标准库是有多个版本的，要知道我们使用的STL是哪个版本，才能知道对应的栈和队列的实现原理。

那么来介绍一下，三个最为普遍的STL版本：

1. HP STL 其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。
2. P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。
3. SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。

接下来介绍的栈和队列也是SGI STL里面的数据结构， 知道了使用版本，才知道对应的底层实现。

来说一说栈，栈先进后出，如图所示：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235434905.png)

栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。

**栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。**

所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。

那么问题来了，STL 中栈是用什么容器实现的？

从下图中可以看出，栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235459376.png)

**我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。**

deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。

**SGI STL中 队列底层实现缺省情况下一样使用deque实现的。**

我们也可以指定vector为栈的底层实现，初始化语句如下

```python
std::stack<int, std::vector<int> > third;  // 使用vector为底层容器的栈
```

刚刚讲过栈的特性，对应的队列的情况是一样的。

队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, **SGI STL中队列一样是以deque为缺省情况下的底部结构。**

也可以指定list 为起底层实现，初始化queue的语句如下：

```python
std::queue<int, std::list<int>> third; // 定义以list为底层容器的队列
```

**所以STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。**

我这里讲的都是C++ 语言中的情况， 使用其他语言的同学也要思考栈与队列的底层实现问题， 不要对数据结构的使用浅尝辄止，而要深挖其内部原理，才能夯实基础。

---

### [232.用栈实现队列](https://leetcode.com/problems/implement-queue-using-stacks/)

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：

- `void push(int x)` 将元素 x 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`

**说明：**

- 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

**示例 1：**

**输入：**

["MyQueue", "push", "push", "peek", "pop", "empty"]

[[], [1], [2], [], [], []]

**输出：**

[null, null, null, 1, 1, false]

**解释：**

MyQueue myQueue = new MyQueue();

myQueue.push(1); // queue is: [1]

myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)

myQueue.peek(); // return 1

myQueue.pop(); // return 1, queue is [2]

myQueue.empty(); // return false

**提示：**

- `1 <= x <= 9`
- 最多调用 `100` 次 `push`、`pop`、`peek` 和 `empty`
- 假设所有操作都是有效的 （例如，一个空的队列不会调用 `pop` 或者 `peek` 操作）

**进阶：**

- 你能否实现每个操作均摊时间复杂度为 `O(1)` 的队列？换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间。

#### 解题思路：

为了实现一个先入先出（FIFO）的队列，我们可以使用两个栈，`stack_in` 和 `stack_out`。其中 `stack_in` 用于入队操作（`push`），`stack_out` 用于出队操作（`pop`、`peek`）。在出队操作时，如果 `stack_out` 为空，则需要将 `stack_in` 中的所有元素转移至 `stack_out`，以确保队列的先入先出特性。

```python
class MyQueue:

    def __init__(self):
        self.stack_in = []   # 用于入队操作
        self.stack_out = []  # 用于出队操作

    def push(self, x: int) -> None:
        # 直接将元素加入 stack_in
        self.stack_in.append(x)

    def pop(self) -> int:
        # 当 stack_out 为空时，将 stack_in 中的所有元素转移至 stack_out
        if not self.stack_out:
            while self.stack_in:
                self.stack_out.append(self.stack_in.pop())
        return self.stack_out.pop()

    def peek(self) -> int:
        # 与 pop 方法类似，但只是返回 stack_out 的顶部元素，不进行删除
        if not self.stack_out:
            while self.stack_in:
                self.stack_out.append(self.stack_in.pop())
        return self.stack_out[-1]

    def empty(self) -> bool:
        # 当两个栈都为空时，队列为空
        return not self.stack_in and not self.stack_out
```

---

### [225. 用队列实现栈](https://leetcode.com/problems/implement-stack-using-queues/)

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。

实现 `MyStack` 类：

- `void push(int x)` 将元素 x 压入栈顶。
- `int pop()` 移除并返回栈顶元素。
- `int top()` 返回栈顶元素。
- `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。

**注意：**

- 你只能使用队列的基本操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。
- 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。

**示例：**

**输入：**

["MyStack", "push", "push", "top", "pop", "empty"]

[[], [1], [2], [], [], []]

**输出：**

[null, null, null, 2, 2, false]

**解释：**

MyStack myStack = new MyStack();

myStack.push(1);

myStack.push(2);

myStack.top(); // 返回 2

myStack.pop(); // 返回 2

myStack.empty(); // 返回 False

**提示：**

- `1 <= x <= 9`
- 最多调用`100` 次 `push`、`pop`、`top` 和 `empty`
- 每次调用 `pop` 和 `top` 都保证栈不为空

**进阶：**你能否仅用一个队列来实现栈。

#### 解题思路

为了实现一个后入先出（LIFO）的栈，我们可以使用两个队列。在这种实现中，一个队列用于存储栈的所有元素（称为 `queue_main`），而另一个队列（称为 `queue_helper`）用于实现栈的 `pop` 和 `top` 操作。

实现方法如下：

1. `push` 操作：将元素加入 `queue_main`。
2. `pop` 操作：将 `queue_main` 中的所有元素（除了最后一个元素）转移到 `queue_helper`，然后弹出 `queue_main` 的最后一个元素，并交换两个队列的角色。
3. `top` 操作：与 `pop` 类似，但不弹出最后一个元素，只返回它的值。
4. `empty` 操作：检查 `queue_main` 是否为空。

```python
from collections import deque

class MyStack:

    def __init__(self):
        self.queue_main = deque()  # 主队列，用于存储栈中的元素
        self.queue_helper = deque()  # 辅助队列，用于实现 pop 和 top 操作

    def push(self, x: int) -> None:
        # 将元素添加到主队列的末尾
        self.queue_main.append(x)

    def pop(self) -> int:
        # 将主队列中的元素（除了最后一个）转移到辅助队列
        while len(self.queue_main) > 1:
            self.queue_helper.append(self.queue_main.popleft())
        # 弹出并返回主队列中的最后一个元素
        top_element = self.queue_main.popleft()
        # 交换主队列和辅助队列的角色
        self.queue_main, self.queue_helper = self.queue_helper, self.queue_main
        return top_element

    def top(self) -> int:
        # 与 pop 操作类似，但不弹出最后一个元素，只返回它的值
        while len(self.queue_main) > 1:
            self.queue_helper.append(self.queue_main.popleft())
        # 获取队列的第一个元素
        top_element = self.queue_main[0]
        # 将队列的第一个元素也转移至辅助队列
        self.queue_helper.append(self.queue_main.popleft())
        # 交换主队列和辅助队列的角色
        self.queue_main, self.queue_helper = self.queue_helper, self.queue_main
        return top_element

    def empty(self) -> bool:
        # 检查主队列是否为空
        return not self.queue_main
```

### 进阶版本

使用单个队列实现栈的进阶方法的核心思想是确保最新添加的元素总是位于队列的前端，这样当执行 `pop` 或 `top` 操作时，可以直接访问或移除队列的第一个元素，从而模拟栈的后入先出（LIFO）特性。

1. `push` 操作：首先将元素添加到队列的末尾。然后，将队列中的所有其他元素（除了刚刚添加的元素）从队列的前端移除并重新添加到队列的末尾，这样新添加的元素就移动到了队列的前端。
2. `pop` 操作：由于最新的元素位于队列的前端，我们可以直接从队列的前端移除并返回该元素。
3. `top` 操作：与 `pop` 操作类似，只是不移除元素，而是返回队列前端的元素值。
4. `empty` 操作：检查队列是否为空。

```python
from collections import deque

class MyStack:

    def __init__(self):
        self.queue = deque()  # 使用一个队列

    def push(self, x: int) -> None:
        # 将新元素添加到队列末尾
        self.queue.append(x)
        # 将队列中的旧元素（除了新添加的元素）依次移到队列末尾
        for _ in range(len(self.queue) - 1):
            self.queue.append(self.queue.popleft())

    def pop(self) -> int:
        # 弹出并返回队列前端的元素
        return self.queue.popleft()

    def top(self) -> int:
        # 返回队列前端的元素
        return self.queue[0]

    def empty(self) -> bool:
        # 检查队列是否为空
        return not self.queue
```

在这种实现中，`push` 操作的时间复杂度是 O(n)，其中 `n` 是栈中元素的数量，因为它涉及到移动几乎所有元素到队列的末尾。而 `pop`、`top` 和 `empty` 操作的时间复杂度是 O(1)。

#### 代码随想录算法训练营第十一天 | 20. 有效的括号， 1047. 删除字符串中的所有相邻重复项， 150. 逆波兰表达式求值

#### ● day 11 任务以及具体安排：[第五章 栈与队列part02](https://docs.qq.com/doc/DUHh6UE5hUUZOZUd0) (12.23)

#### 第五章 栈与队列part02

今日内容：

●  20. 有效的括号

●  1047. 删除字符串中的所有相邻重复项

●  150. 逆波兰表达式求值

#### 详细布置

#### 20. 有效的括号

讲完了栈实现队列，队列实现栈，接下来就是栈的经典应用了。

大家先自己思考一下 有哪些不匹配的场景，在看视频 我讲的都有哪些场景，落实到代码其实就容易很多了。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html](https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html)

#### 1047. 删除字符串中的所有相邻重复项

栈的经典应用。

要知道栈为什么适合做这种类似于爱消除的操作，因为栈帮助我们记录了 遍历数组当前元素时候，前一个元素是什么。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html](https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html)

#### 150. 逆波兰表达式求值

本题不难，但第一次做的话，会很难想到，所以先看视频，了解思路再去做题

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html](https://programmercarl.com/0150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html)

[Just a moment...](https://chat.openai.com/share/c5d8d575-ca99-405b-b14c-823845474e03)

---

### [20. 有效的括号](https://leetcode.com/problems/valid-parentheses/)

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

**示例 1：**

输入：s = "()"

输出：true

**示例 2：**

输入：s = "()[]{}"

输出：true

**示例 3：**

输入：s = "(]"

输出：false

**提示：**

- `1 <= s.length <= 104`
- `s` 仅由括号 `'()[]{}'` 组成

#### 解题思路

使用栈（Stack）来处理这个问题是最直观的方法。栈是一种后进先出（LIFO）的数据结构，它非常适合处理这种成对出现且需要按顺序匹配的字符。

具体步骤如下：

1. 遍历字符串中的每个字符。
2. 当遇到左括号时（'(', '{', '['），将其压入栈中。
3. 当遇到右括号时（')', '}', ']'），检查栈顶元素：
   - 如果栈不为空，并且栈顶元素与当前右括号匹配（即构成一对括号），则弹出栈顶元素。
   - 否则，说明括号不匹配，直接返回 `false`。
4. 最后，如果栈为空，则所有括号均有效匹配，返回 `true`；如果栈不为空，则说明有未匹配的左括号，返回 `false`。

```python
def isValid(s: str) -> bool:
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}

    for char in s:
        if char in mapping:
            top_element = stack.pop() if stack else '#'
            if mapping[char] != top_element:
                return False
        else:
            stack.append(char)

    return not stack

# 测试示例
print(isValid("()"))       # True
print(isValid("()[]{}"))   # True
print(isValid("(]"))       # False
```

#### 时间复杂度分析

- 时间复杂度：O(n)，其中 n 是字符串 `s` 的长度。我们只需要遍历一次字符串。
- 空间复杂度：O(n)，在最坏的情况下（例如所有字符都是左括号），我们将所有字符都存储在栈中。

#### 视频讲解：

[栈的拿手好戏！| LeetCode：20. 有效的括号 |  20. Valid Parentheses](https://youtu.be/6QQOCtUcfbo?si=s5JRg1HrvpLJ8vrq)

这里有三种不匹配的情况:

第一种情况，字符串里左方向的括号多余了 ，所以不匹配。

第二种情况，括号没有多余，但是 括号的类型没有匹配上。

第三种情况，字符串里右方向的括号多余了，所以不匹配。

![20.有效括号.gif](https://res.craft.do/user/full/f88d89a3-d4f3-77bc-3e9a-85776d45d2a6/doc/8409C5CB-9875-4DCE-A3D3-F5080A0A1B5C/1c2e2fb8-9337-49a7-87dc-f585e0b7cec4)

第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false

第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符。所以return false

第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号return false

那么什么时候说明左括号和右括号全都匹配了呢，就是字符串遍历完之后，栈是空的，就说明全都匹配了。

---

### [1047. 删除字符串中的所有相邻重复项](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/)

给出由小写字母组成的字符串 `S`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

**示例：**

**输入：**"abbaca"

**输出：**"ca"

**解释：**

例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。

**提示：**

1. `1 <= S.length <= 20000`
2. `S` 仅由小写英文字母组成。

#### 解题思路

这个问题可以使用栈的数据结构来解决。我们可以遍历字符串中的每个字符，并使用栈来跟踪尚未删除的字符。当我们遇到一个新字符时，我们检查它是否与栈顶字符相同。如果相同，我们就从栈中弹出栈顶字符（即删除两个相邻的重复字符）。如果不相同，我们就将新字符压入栈中。

![Image.gif](https://code-thinking.cdn.bcebos.com/gifs/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.gif)

#### 解题步骤

1. 初始化一个空栈。
2. 遍历字符串中的每个字符。
   - 如果栈不为空且当前字符与栈顶字符相同，弹出栈顶字符（删除两个相邻的重复字符）。
   - 否则，将当前字符压入栈中。
3. 将栈中的字符转换为字符串并返回。

```python
def removeDuplicates(S: str) -> str:
    stack = []

    for char in S:
        if stack and char == stack[-1]:
            stack.pop()
        else:
            stack.append(char)

    return ''.join(stack)

# 测试示例
print(removeDuplicates("abbaca"))  # 输出: "ca"
```

#### 时间复杂度分析

- 时间复杂度：O(n)，其中 n 是字符串 `S` 的长度。我们需要遍历一次字符串来处理每个字符。
- 空间复杂度：O(n)，在最坏的情况下（没有重复字符），我们将所有字符都存储在栈中。

#### 题外话

这道题目就像是我们玩过的游戏对对碰，如果相同的元素挨在一起就要消除。

可能我们在玩游戏的时候感觉理所当然应该消除，但程序又怎么知道该如何消除呢，特别是消除之后又有新的元素可能挨在一起。

此时游戏的后端逻辑就可以用一个栈来实现（我没有实际考察对对碰或者爱消除游戏的代码实现，仅从原理上进行推断）。

游戏开发可能使用栈结构，编程语言的一些功能实现也会使用栈结构，实现函数递归调用就需要栈，但不是每种编程语言都支持递归，例如：

**递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中**，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。

相信大家应该遇到过一种错误就是栈溢出，系统输出的异常是`Segmentation fault`（当然不是所有的`Segmentation fault` 都是栈溢出导致的） ，如果你使用了递归，就要想一想是不是无限递归了，那么系统调用栈就会溢出。

而且**在企业项目开发中，尽量不要使用递归**！在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），**造成栈溢出错误（这种问题还不好排查！）**

---

### [150. 逆波兰表达式求值](https://leetcode.com/problems/evaluate-reverse-polish-notation/)

**逆波兰表达式：**

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

- 平常使用的算式则是一种中缀表达式，如 `( 1 + 2 ) * ( 3 + 4 )` 。
- 该算式的逆波兰表达式写法为 `( ( 1 2 + ) ( 3 4 + ) * )` 。

逆波兰表达式主要有以下两个优点：

- 去掉括号后表达式无歧义，上式即便写成 `1 2 + 3 4 + *` 也可以依据次序计算出正确结果。
- 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中

给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437) 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

**注意：**

- 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。
- 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
- 两个整数之间的除法总是 **向零截断** 。
- 表达式中不含除零运算。
- 输入是一个根据逆波兰表示法表示的算术表达式。
- 答案及所有中间计算结果可以用 **32 位** 整数表示。

**示例 1：**

输入：tokens = ["2","1","+","3","*"]

输出：9

解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9

**示例 2：**

输入：tokens = ["4","13","5","/","+"]

输出：6

解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6

**示例 3：**

输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]

输出：22

解释：该算式转化为常见的中缀算术表达式为：

((10 * (6 / ((9 + 3) * -11))) + 17) + 5

= ((10 * (6 / (12 * -11))) + 17) + 5

= ((10 * (6 / -132)) + 17) + 5

= ((10 * 0) + 17) + 5

= (0 + 17) + 5

= 17 + 5

= 22

**提示：**

- `1 <= tokens.length <= 104`
- `tokens[i]` 是一个算符（`"+"`、`"-"`、`"*"` 或 `"/"`），或是在范围 `[-200, 200]` 内的一个整数

#### 解题思路：

逆波兰表达式（也称为后缀表达式）的求值可以通过使用栈来实现。当遇到一个操作数时，我们将其压入栈中；当遇到一个运算符时，我们从栈中弹出两个操作数，执行相应的运算，并将结果压回栈中。最后，栈顶的元素就是整个表达式的计算结果。

![Image.gif](https://code-thinking.cdn.bcebos.com/gifs/150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.gif)

#### 解题步骤

1. 初始化一个空栈。
2. 遍历给定的 `tokens` 数组：
   - 如果遇到一个操作数（数字），将其转换为整数并压入栈中。
   - 如果遇到一个运算符（'+', '-', '*', '/'），从栈中弹出两个操作数，执行相应的运算，并将结果压回栈中。注意操作数的顺序和除法的截断方式。
3. 表达式的求值结果将是栈顶的唯一元素。

```python
def evalRPN(tokens):
    stack = []

    for token in tokens:
        if token in ["+", "-", "*", "/"]:
            b = stack.pop()
            a = stack.pop()
            if token == "+":
                stack.append(a + b)
            elif token == "-":
                stack.append(a - b)
            elif token == "*":
                stack.append(a * b)
            elif token == "/":
                # 注意 Python 中除法向零截断的实现方式
                stack.append(int(float(a) / b))
        else:
            stack.append(int(token))

    return stack[0]

# 测试示例
print(evalRPN(["2", "1", "+", "3", "*"]))  # 输出: 9
print(evalRPN(["4", "13", "5", "/", "+"])) # 输出: 6
print(evalRPN(["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"])) # 输出: 22
```

#### 注意点

- 在处理除法时，Python 对于负数的整除行为与其他一些语言不同。Python 的整除是向下取整，而题目要求向零截断。因此，我们需要先将操作数转换为浮点数进行除法，然后再使用 `int` 函数来截断到零。
- 确保在从栈中弹出元素时，正确处理操作数的顺序。

#### 时间复杂度分析

- 时间复杂度：O(n)，其中 n 是 `tokens` 数组的长度。我们需要遍历一次数组。
- 空间复杂度：O(n)，在最坏的情况下（所有元素都是数字），我们将所有元素都存储在栈中。

#### 视频讲解：

[栈的最后表演！ | LeetCode：150. 逆波兰表达式求值 | 150. Evaluate Reverse Polish Notation](https://youtu.be/xTt-XdNkmEw?si=roQmFzp1ivtCZMsj)

#### 代码随想录算法训练营第十三天 | 239. 滑动窗口最大值， 347.前 K 个高频元素

#### ● day 13 任务以及具体安排：[第五章 栈与队列part03](https://docs.qq.com/doc/DUHNpa3F4b2dMUWJ3) (12.25)

#### 第五章 栈与队列part03

#### 今日内容：

●  239. 滑动窗口最大值

●  347.前 K 个高频元素

●  总结

#### 详细布置

#### 239. 滑动窗口最大值 （一刷至少需要理解思路）

之前讲的都是栈的应用，这次该是队列的应用了。

本题算比较有难度的，需要自己去构造单调队列，建议先看视频来理解。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html](https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html)

#### 347.前 K 个高频元素 （一刷至少需要理解思路）

大/小顶堆的应用， 在C++中就是优先级队列

本题是 大数据中取前k值 的经典思路，了解想法之后，不算难。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html](https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html)

#### 总结

栈与队列做一个总结吧，加油

[代码随想录](https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93.html)

[Just a moment...](https://chat.openai.com/share/6266fea4-3867-4d56-8445-92cdfe2505d4)

[Deque | Set 1 (Introduction and Applications) - GeeksforGeeks](https://www.geeksforgeeks.org/deque-set-1-introduction-applications/)

---

### [239. 滑动窗口最大值](https://leetcode.com/problems/sliding-window-maximum/)

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

**示例 1：**

输入：nums = [1,3,-1,-3,5,3,6,7], k = 3

**输出：**[3,3,5,5,6,7]

**解释：**

滑动窗口的位置                最大值

---

[1  3  -1] -3  5  3  6  7       **3**

1 [3  -1  -3] 5  3  6  7       **3**

1  3 [-1  -3  5] 3  6  7      5

1  3  -1 [-3  5  3] 6  7       **5**

1  3  -1  -3 [5  3  6] 7       **6**

1  3  -1  -3  5 [3  6  7]      **7**

**示例 2：**

输入：nums = [1], k = 1

**输出：**[1]

**提示：**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`
- `1 <= k <= nums.length`

进阶：

你能在线性时间复杂度内解决此题吗？

#### 解题思路：

要解决这个问题，我们需要一个数据结构来快速从中找到最大值。普通的队列无法有效地支持这种操作，但双端队列（deque）可以做到。双端队列是一个序列容器，可以在两端以常数时间插入和删除元素。

1. **初始化双端队列** (Deque)：这个队列将用于存储数组中元素的索引，并保证队列中的元素对应的值从大到小排列。队首元素始终是当前窗口的最大值。
2. **遍历数组**：遍历给定的数组，索引为 `i`。

   a. **维护队列大小**：如果队首元素的索引已经不在滑动窗口内（即 `i - k` 大于队首索引），则将其从队列中移除。

   b. **维护队列内元素顺序**：如果新元素 `nums[i]` 大于队尾元素对应的值，则持续移除队尾元素，直到 `nums[i]` 可以被放到队列中合适的位置。这样做是为了保持队列元素对应值的降序排列。

   c. **加入新元素**：将当前索引 `i` 加入队列。

3. **记录最大值**：当窗口的大小首次达到 `k` 时，即 `i ≥ k - 1`，开始记录每个窗口的最大值。队首元素始终是当前窗口的最大值，将其加入结果列表。
4. **返回结果**：遍历完成后，返回包含每个窗口最大值的列表。

这个方法的关键在于使用双端队列来有效维护窗口内的最大值。队列的两端操作都是常数时间，这使得整体时间复杂度保持在 O(n)。

```python
from collections import deque

def maxSlidingWindow(nums, k):
    # 初始化双端队列和结果列表
    deq = deque()
    result = []

    for i in range(len(nums)):
        # 保持双端队列的元素个数不超过 k
        if deq and deq[0] < i - k + 1:
            deq.popleft()

        # 保持双端队列从大到小的顺序
        while deq and nums[i] > nums[deq[-1]]:
            deq.pop()

        # 添加当前元素的索引到双端队列
        deq.append(i)

        # 当窗口形成时，将最大值（队头元素）添加到结果列表
        if i >= k - 1:
            result.append(nums[deq[0]])

    return result

# 测试
nums = [1,3,-1,-3,5,3,6,7]
k = 3
print(maxSlidingWindow(nums, k))  # 输出: [3, 3, 5, 5, 6, 7]
```

#### 视频讲解

[单调队列正式登场！| LeetCode：239. 滑动窗口最大值 | 239. Sliding Window Maximum](https://youtu.be/2Ttv5vCKJnU?si=ni_o5Yg5HV5gyRPM)

---

### [347.前 K 个高频元素](https://leetcode.com/problems/top-k-frequent-elements/)

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

**示例 1:**

**输入:** nums = [1,1,1,2,2,3], k = 2

**输出:** [1,2]

**示例 2:**

**输入:** nums = [1], k = 1

**输出:** [1]

**提示：**

- `1 <= nums.length <= 105`
- `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
- 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

进阶：你所设计算法的时间复杂度 **必须** 优于 `O(n log n)` ，其中 `n` 是数组大小。

#### 解题思路：

我们可以采用哈希表和堆（优先队列）的数据结构。这个问题的核心是首先统计每个元素的出现频率，然后找到频率最高的 K 个元素。下面是具体步骤：

1. **使用哈希表统计频率**：遍历数组 `nums`，使用一个哈希表（或字典）来统计每个元素的出现次数。
2. **构建最小堆**：构建一个最小堆（优先队列），用于存储频率最高的 K 个元素。堆中的元素以频率为比较基准。
3. **遍历哈希表**：遍历哈希表中的每一个键值对（元素和其对应的频率）。对于每一个键值对：

   a. **将键值对加入堆**：将其加入到最小堆中。

   b. **维护堆的大小**：如果堆的大小超过了 K，那么弹出堆顶元素（即频率最小的元素），以保持堆的大小为 K。

4. **提取结果**：最后，堆中剩下的就是频率最高的 K 个元素。提取这些元素作为结果。
5. **返回结果**：返回步骤 4 中提取出的元素。

```python
import heapq
from collections import Counter

def topKFrequent(nums, k):
    # 统计元素频率
    count = Counter(nums)
    # 创建一个最小堆
    heap = []
    
    # 遍历统计的频率
    for num, freq in count.items():
        # 将元素的频率加入到堆中
        heapq.heappush(heap, (freq, num))
        # 如果堆的大小超过了 k，则弹出堆顶元素
        if len(heap) > k:
            heapq.heappop(heap)

    # 提取堆中的元素
    top_k = [item[1] for item in heap]
    return top_k

# 测试
print(topKFrequent([1,1,1,2,2,3], 2))  # 输出: [1, 2]
print(topKFrequent([1], 1))            # 输出: [1]
```

这个方法的时间复杂度主要在于构建和维护堆的操作，其时间复杂度为 O(N log K)，其中 N 是数组 `nums` 的长度。这是因为插入堆和弹出堆的操作都是 O(log K) 的时间复杂度，而我们需要对数组中的每个元素进行这样的操作。

#### 视频讲解

[优先级队列正式登场！大顶堆、小顶堆该怎么用？| LeetCode：347.前 K 个高频元素 | 347. Top K Frequent Elements](https://youtu.be/V9mtZHgAbsY?si=iGZdXRlWjyQa7WQX)

---

#### 栈与队列总结篇

首先我们在[栈与队列：来看看栈和队列不为人知的一面 (opens new window)](https://programmercarl.com/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)中讲解了栈和队列的理论基础。

里面提到了灵魂四问：

1. C++中stack，queue 是容器么？
2. 我们使用的stack，queue是属于那个版本的STL？
3. 我们使用的STL中stack，queue是如何实现的？
4. stack，queue 提供迭代器来遍历空间么？

可以出一道面试题：栈里面的元素在内存中是连续分布的么？

这个问题有两个陷阱：

- 陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中不一定是连续分布的。
- 陷阱2：缺省情况下，默认底层容器是deque，那么deque在内存中的数据分布是什么样的呢？ 答案是：不连续的，下文也会提到deque。

所以这就是考察候选者基础知识扎不扎实的好问题。

### 第六章：二叉树

#### 代码随想录算法训练营第十四天 | 理论基础，递归遍历，迭代遍历，统一遍历

#### ● day 14 任务以及具体安排：[第六章 二叉树part01](https://docs.qq.com/doc/DUHRtdXZZSWFkeGdE) (12.26)

#### 第六章 二叉树part01

#### 今日内容：

●  理论基础

●  递归遍历

●  迭代遍历

●  统一迭代

#### 详细布置

#### 理论基础

需要了解 二叉树的种类，存储方式，遍历方式 以及二叉树的定义

文章讲解：[https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)

#### 递归遍历 （必须掌握）

二叉树的三种递归遍历掌握其规律后，其实很简单

题目链接/文章讲解/视频讲解：[https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html)

#### 迭代遍历 （基础不好的录友，迭代法可以放过）

题目链接/文章讲解/视频讲解：[https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html)

#### 统一迭代   （基础不好的录友，迭代法可以放过）

这是统一迭代法的写法， 如果学有余力，可以掌握一下

题目链接/文章讲解：[https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html)

[Just a moment...](https://chat.openai.com/share/d988a69a-8ff8-4f7a-9927-49168cf26a53)

---

#### 二叉树理论基础篇

### 二叉树的种类

[二叉树、二叉查找树、二叉排序树、二叉平衡树的区别是什么 - PingCode](https://docs.pingcode.com/ask/25252.html#:~:text=371-,%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E3%80%81%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E3%80%81,%E6%A0%B9%E7%BB%93%E7%82%B9%E7%9A%84%E5%80%BC%E3%80%82)

#### 满二叉树

满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806185805576.png)

这棵二叉树为满二叉树，也可以说深度为k，有2^k-1个节点的二叉树。

#### 完全二叉树

完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20200920221638903.png)

### 二叉搜索树

面介绍的树，都没有数值的，而二叉搜索树是有数值的了，**二叉搜索树是一个有序树**。

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190304693.png)

### 平衡二叉搜索树

平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190511967.png)

最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。

**C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树**，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。

### 二叉树的存储方式

**二叉树可以链式存储，也可以顺序存储。**

那么链式存储方式就用指针， 顺序存储的方式就是用数组。

顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。

链式存储如图：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/2020092019554618.png)

顺序存储的方式如图：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20200920200429452.png)

用数组来存储二叉树如何遍历的呢？

**如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。**

但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。

### 二叉树的遍历方式

二叉树主要有两种遍历方式：

1. 深度优先遍历：先往深走，遇到叶子节点再往回走。
   - 前序遍历（递归法，迭代法）
   - 中序遍历（递归法，迭代法）
   - 后序遍历（递归法，迭代法）

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806191109896.png)

2. 广度优先遍历：一层一层的去遍历。
   - 层次遍历（迭代法）

最后再说一说二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。

**之前我们讲栈与队列的时候，就说过栈其实就是递归的一种实现结构**，也就说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。

而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。

### 二叉树的定义

我们来看看链式存储的二叉树节点的定义方式

```python
class TreeNode:
    def __init__(self, val, left = None, right = None):
        self.val = val
        self.left = left
        self.right = right
```

#### 二叉树的递归遍历

**本篇将介绍前后中序的递归写法，一些同学可能会感觉很简单，其实不然，我们要通过简单题目把方法论确定下来，有了方法论，后面才能应付复杂的递归。**

这里帮助大家确定下来递归算法的三个要素。**每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！**

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。
4. **前序遍历** (Pre-order Traversal)：
   - 访问根节点。
   - 递归地对左子树进行前序遍历。
   - 递归地对右子树进行前序遍历。
2. **中序遍历** (In-order Traversal)：
   - 递归地对左子树进行中序遍历。
   - 访问根节点。
   - 递归地对右子树进行中序遍历。
3. **后序遍历** (Post-order Traversal)：
   - 递归地对左子树进行后序遍历。
   - 递归地对右子树进行后序遍历。
   - 访问根节点。

```python
class TreeNode:
    def __init__(self, value=0, left=None, right=None):
        self.val = value
        self.left = left
        self.right = right

def preorderTraversal(root):
    if root is None:
        return []
    return [root.val] + preorderTraversal(root.left) + preorderTraversal(root.right)

def inorderTraversal(root):
    if root is None:
        return []
    return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)

def postorderTraversal(root):
    if root is None:
        return []
    return postorderTraversal(root.left) + postorderTraversal(root.right) + [root.val]
```

   #### 视频讲解

[每次写递归都要靠直觉？ 这次带你学透二叉树的递归遍历！| LeetCode：144.前序遍历，145.后序遍历，94.中序遍历](https://youtu.be/LZyTiZH3j80?si=iIUVJsjeVzFe6E__)

---

### [144. 二叉树的前序遍历](https://leetcode.com/problems/binary-tree-preorder-traversal/)

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

**示例 1：**

输入：root = [1,null,2,3]

**输出：**[1,2,3]

**示例 2：**

输入：root = []

**输出：**[]

**示例 3：**

输入：root = [1]

**输出：**[1]

**示例 4：**

输入：root = [1,2]

**输出：**[1,2]

**示例 5：**

输入：root = [1,null,2]

**输出：**[1,2]

**提示：**

- 树中节点数目在范围 `[0, 100]` 内
- `-100 <= Node.val <= 100`

进阶：递归算法很简单，你可以通过迭代算法完成吗？

#### 解题思路：

这个问题要求我们实现二叉树的前序遍历。在前序遍历中，我们首先访问根节点，然后访问左子树，最后访问右子树。这个顺序遵循 "根-左-右" 的模式。

首先，我将提供递归解法，然后介绍迭代解法，以满足题目中的进阶要求。

#### 递归解法

递归解法是直观的。我们首先检查根节点是否为空。如果不为空，我们将根节点的值添加到结果中，然后递归地对左子树和右子树进行前序遍历。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def preorderTraversal(root):
    if not root:
        return []
    return [root.val] + preorderTraversal(root.left) + preorderTraversal(root.right)
```

#### 迭代解法

迭代解法相比递归更为复杂，但它的好处在于不需要使用递归栈。这在某些情况下可以减少内存使用。迭代解法使用一个栈来模拟递归过程。

```python
def preorderTraversalIterative(root):
    if not root:
        return []

    stack, output = [root, ], []
    while stack:
        node = stack.pop()
        if node:
            output.append(node.val)
            if node.right: # 先压入右子树，后访问
                stack.append(node.right)
            if node.left: # 后压入左子树，先访问
                stack.append(node.left)
    return output
```

在这个迭代方法中，我们使用一个栈来存储将要访问的节点。首先，我们将根节点压入栈中。在每次迭代中，我们弹出栈顶元素，并将其值添加到输出列表中。接着，我们先将右子节点压入栈（如果存在），然后压入左子节点（如果存在）。这样做是为了保证左子节点先于右子节点被访问，符合前序遍历的顺序。

#### 时间复杂度

无论是递归还是迭代方法，时间复杂度都是 O(n)，其中 n 是树中节点的数量，因为每个节点都被访问一次。

#### 空间复杂度

- 对于递归方法，空间复杂度主要取决于递归的深度，最坏情况下可以达到 O(n)。
- 对于迭代方法，空间复杂度为 O(n)，因为在最坏的情况下，我们可能需要存储整棵树的所有节点。

---

### [94](https://leetcode.cn/problems/binary-tree-inorder-traversal/)[. 二叉树的中序遍历](https://leetcode.com/problems/binary-tree-inorder-traversal/)

给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。

**示例 1：**

输入：root = [1,null,2,3]

**输出：**[1,3,2]

**示例 2：**

输入：root = []

**输出：**[]

**示例 3：**

输入：root = [1]

**输出：**[1]

**提示：**

- 树中节点数目在范围 `[0, 100]` 内
- `-100 <= Node.val <= 100`

**进阶:** 递归算法很简单，你可以通过迭代算法完成吗？

#### 解题思路

在二叉树的中序遍历中，我们按照“左-根-右”的顺序访问节点。首先，我将展示中序遍历的递归实现，随后介绍迭代实现以满足进阶要求。

#### 递归实现

递归实现的思路是先递归地访问左子树，然后访问根节点，最后递归地访问右子树。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def inorderTraversal(root):
    if not root:
        return []
    return inorderTraversal(root.left) + [root.val] + inorderTraversal(root.right)
```

#### 迭代实现

迭代实现中序遍历稍微复杂一些，需要使用栈来模拟递归的过程。

```python
def inorderTraversalIterative(root):
    stack, result = [], []
    current = root
    while current or stack:
        # 一直向左走直到最左叶子节点
        while current:
            stack.append(current)
            current = current.left
        # 回溯到最近的节点，并访问它的右子树
        current = stack.pop()
        result.append(current.val)
        current = current.right
    return result
```

这里，我们使用一个栈来存储沿途的节点，并首先遍历到最左边的节点。然后，我们开始从栈中弹出节点，并访问每个节点的右子树。

#### 时间复杂度

无论是递归还是迭代实现，时间复杂度都是 O(n)，其中 n 是树中节点的数量，因为每个节点都被访问一次。

#### 空间复杂度

- 对于递归实现，空间复杂度主要取决于递归的深度，最坏情况下可以达到 O(n)。
- 对于迭代实现，空间复杂度同样是 O(n)，在最坏的情况下，我们可能需要存储整棵树的所有节点。

---

### [145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

给你一棵二叉树的根节点 `root` ，返回其节点值的 **后序遍历** 。

**示例 1：**

输入：root = [1,null,2,3]

**输出：**[3,2,1]

**示例 2：**

输入：root = []

**输出：**[]

**示例 3：**

输入：root = [1]

**输出：**[1]

**提示：**

- 树中节点的数目在范围 `[0, 100]` 内
- `-100 <= Node.val <= 100`

进阶：递归算法很简单，你可以通过迭代算法完成吗？

#### 解题思路

二叉树的后序遍历是另一种常见的遍历方式，其遍历顺序为“左-右-根”。首先，我将提供后序遍历的递归实现，然后介绍迭代实现以满足进阶要求。

### 递归实现

递归实现的基本思路是先递归地访问左子树和右子树，然后访问根节点。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def postorderTraversal(root):
    if not root:
        return []
    return postorderTraversal(root.left) + postorderTraversal(root.right) + [root.val]
```

### 迭代实现

迭代实现后序遍历需要更细致的控制，因为它需要在访问左子树和右子树之后再访问根节点。我们可以使用两个栈来实现，或者使用一个栈但稍微调整访问顺序。

这里提供一个使用单栈的迭代实现：

```python
def postorderTraversalIterative(root):
    if not root:
        return []

    stack, result = [root], []
    while stack:
        node = stack.pop()
        result.append(node.val)
        # 先左后右添加节点
        if node.left:
            stack.append(node.left)
        if node.right:
            stack.append(node.right)

    # 翻转结果以符合后序遍历的顺序
    return result[::-1]
```

在这个迭代方法中，我们首先访问根节点，然后访问右子树，最后是左子树，这是前序遍历的逆序。最后，我们将结果列表翻转，以得到后序遍历的正确顺序。

### 时间复杂度

无论是递归还是迭代实现，时间复杂度都是 O(n)，其中 n 是树中节点的数量，因为每个节点都被访问一次。

### 空间复杂度

- 对于递归实现，空间复杂度主要取决于递归的深度，最坏情况下可以达到 O(n)。
- 对于迭代实现，空间复杂度同样是 O(n)，在最坏的情况下，我们可能需要存储整棵树的所有节点。

#### 代码随想录算法训练营第十五天 | 层序遍历十题，226.翻转二叉树， 101.对称二叉树 2

#### ● day 15 任务以及具体安排：[第六章  二叉树 part02](https://docs.qq.com/doc/DUHN0ZVJuRmVYeWNv) (12.27)

# 第六章 二叉树 part02

今日内容：

●  层序遍历  10

●  226.翻转二叉树

●  101.对称二叉树 2

## 详细布置

### 层序遍历

看完本篇可以一口气刷十道题，试一试， 层序遍历并不难，大家可以很快刷了十道题。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html](https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html)

### 226.翻转二叉树 （优先掌握递归）

这道题目 一些做过的同学 理解的也不够深入，建议大家先看我的视频讲解，无论做过没做过，都会有很大收获。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html](https://programmercarl.com/0226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html)

### 101. 对称二叉树 （优先掌握递归）

先看视频讲解，会更容易一些。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html](https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html)

[Just a moment...](https://chat.openai.com/share/274a6f19-5d1a-4fd6-9ab2-b1e5d41640a0)

[Just a moment...](https://chat.openai.com/share/dcc5edbb-cd46-428a-816a-a9589d906305)

---

#### 二叉树的层序遍历

### [102.二叉树的层序遍历](https://leetcode.com/problems/binary-tree-level-order-traversal/)

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

**示例 1：**

![Image.jpg](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

输入：root = [3,9,20,null,null,15,7]

**输出：**[[3],[9,20],[15,7]]

**示例 2：**

输入：root = [1]

**输出：**[[1]]

**示例 3：**

输入：root = []

**输出：**[]

**提示：**

- 树中节点数目在范围 `[0, 2000]` 内
- `-1000 <= Node.val <= 1000`

#### 解决方案

1. **初始化队列**: 首先，创建一个队列用于存储每一层的节点。
2. **遍历每一层**: 当队列不为空时，进行以下操作：
   - 确定当前层的节点数量，这等于队列的长度。
   - 遍历这些节点，并将它们的值加入到当前层的结果列表中。
   - 同时，将每个节点的非空左右子节点加入队列。
3. **记录结果**: 每完成一层的遍历后，将该层的结果添加到最终的层序遍历列表中。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def levelOrder(root):
    if not root:
        return []  # 如果根节点为空，直接返回空列表

    result = []  # 存储最终的层序遍历结果
    queue = [root]  # 使用队列来进行层序遍历

    while queue:
        level = []  # 存储当前层的节点值
        level_size = len(queue)  # 当前层的节点数量

        for _ in range(level_size):
            node = queue.pop(0)  # 弹出当前层的一个节点
            level.append(node.val)  # 将节点值加入到当前层的结果中
            if node.left:
                queue.append(node.left)  # 将左子节点加入队列
            if node.right:
                queue.append(node.right)  # 将右子节点加入队列
        
        result.append(level)  # 将当前层的结果加入到最终结果中

    return result
```

#### 时间和空间复杂度

- **时间复杂度**: O(N)，其中 N 是树中节点的数量。每个节点被访问一次。
- **空间复杂度**: O(N)，最坏情况下，队列中存储所有节点。

#### 常见错误

- 不处理空树的情况，导致空指针异常。
- 未正确记录每层的节点数量，导致层序遍历不准确。

#### 测试用例

- **空树**: 输入 `root = []`，预期输出 `[]`。
- **单节点树**: 输入 `root = [1]`，预期输出 `[[1]]`。
- **多层树**: 输入 `root = [3,9,20,null,null,15,7]`，预期输出 `[[3],[9,20],[15,7]]`。

### [107.二叉树的层次遍历II](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/)

给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

**示例 1：**

![Image.jpg](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

输入：root = [3,9,20,null,null,15,7]

**输出：**[[15,7],[9,20],[3]]

**示例 2：**

输入：root = [1]

**输出：**[[1]]

**示例 3：**

输入：root = []

**输出：**[]

**提示：**

- 树中节点数目在范围 `[0, 2000]` 内
- `-1000 <= Node.val <= 1000`

#### 解决方案

1. **初始化队列**: 首先，创建一个队列用于存储每一层的节点。
2. **遍历每一层**: 当队列不为空时，进行以下操作：
   - 确定当前层的节点数量，这等于队列的长度。
   - 遍历这些节点，并将它们的值加入到当前层的结果列表中。
   - 同时，将每个节点的非空左右子节点加入队列。
3. **记录结果**: 每完成一层的遍历后，将该层的结果添加到最终的层序遍历列表中。
4. **逆序结果**: 完成所有层的遍历后，将结果列表逆序，以得到自底向上的层序遍历。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def levelOrderBottom(root):
    if not root:
        return []  # 如果根节点为空，直接返回空列表

    result = []  # 存储最终的层序遍历结果
    queue = [root]  # 使用队列来进行层序遍历

    while queue:
        level = []  # 存储当前层的节点值
        level_size = len(queue)  # 当前层的节点数量

        for _ in range(level_size):
            node = queue.pop(0)  # 弹出当前层的一个节点
            level.append(node.val)  # 将节点值加入到当前层的结果中
            if node.left:
                queue.append(node.left)  # 将左子节点加入队列
            if node.right:
                queue.append(node.right)  # 将右子节点加入队列
        
        result.insert(0, level)  # 将当前层的结果加入到最终结果的开头

    return result
```

#### 时间和空间复杂度

- **时间复杂度**: O(N)，其中 N 是树中节点的数量。每个节点被访问一次。
- **空间复杂度**: O(N)，最坏情况下，队列中存储所有节点。

#### 常见错误

- 忽略自底向上的要求，导致顺序错误。
- 未正确处理空树的情况。

#### 测试用例

- **空树**: 输入 `root = []`，预期输出 `[]`。
- **单节点树**: 输入 `root = [1]`，预期输出 `[[1]]`。
- **多层树**: 输入 `root = [3,9,20,null,null,15,7]`，预期输出 `[[15,7],[9,20],[3]]`。

### [199.二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

### [637.二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

### [429.N叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

### [515.在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

### [116.填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

### [117.填充每个节点的下一个右侧节点指针II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

### [104.二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

### [111.二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

### [226.翻转二叉树](https://leetcode.com/problems/invert-binary-tree/)

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

**示例 1：**

![Image.jpg](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

输入：root = [4,2,7,1,3,6,9]

**输出：**[4,7,2,9,6,3,1]

**示例 2：**

![Image.jpg](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

输入：root = [2,1,3]

**输出：**[2,3,1]

**示例 3：**

输入：root = []

**输出：**[]

**提示：**

- 树中节点数目范围在 `[0, 100]` 内
- `-100 <= Node.val <= 100`

### 解法一：递归法

#### 解题步骤

1. **递归函数定义**：定义一个递归函数，它接受一个节点作为参数，并返回翻转后的该节点。
2. **递归终止条件**：如果当前节点为空，直接返回空。
3. **递归过程**：
   - 递归地翻转当前节点的左子树和右子树。
   - 将左子树和右子树的指针交换。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def invertTree(root):
    if not root:
        return None

    # 递归翻转左右子树
    left = invertTree(root.left)
    right = invertTree(root.right)

    # 交换左右子树
    root.left, root.right = right, left

    return root
```

#### 时间和空间复杂度

- **时间复杂度**：O(N)，其中 N 是树中节点的数量。我们需要访问树中的每个节点。
- **空间复杂度**：O(H)，其中 H 是树的高度。由于递归调用的栈空间，空间复杂度为树的高度。

#### 常见错误

- 忘记处理空节点的情况。
- 在翻转过程中弄丢子树的引用。

### 解法二：层序遍历

#### 解题步骤

1. **初始化队列**：首先，如果根节点不为空，将根节点加入队列。
2. **层序遍历**：遍历队列中的每个元素，对每个节点进行如下操作：
   - 将当前节点的左右子节点交换。
   - 如果当前节点的左子节点不为空，将左子节点加入队列。
   - 如果当前节点的右子节点不为空，将右子节点加入队列。
3. 继续这个过程，直到队列为空。

```python
from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def invertTree(root):
    if not root:
        return None

    queue = deque([root])
    while queue:
        current = queue.popleft()
        
        # 交换当前节点的左右子树
        current.left, current.right = current.right, current.left

        # 将左右子节点加入队列
        if current.left:
            queue.append(current.left)
        if current.right:
            queue.append(current.right)

    return root
```

#### 时间和空间复杂度

- **时间复杂度**：O(N)，其中 N 是树中节点的数量。每个节点都被访问一次。
- **空间复杂度**：O(N)，在最坏的情况下（树完全不平衡），队列中可能包含所有节点。

#### 注意事项

- 使用队列是实现层序遍历的关键。
- 要记得在每个节点处交换左右子树。
- 队列在遍历过程中不断更新，直到遍历完成。

使用层序遍历的好处是，这种方法更加直观且易于理解，尤其是对于初学者来说。此外，它不涉及递归调用，因此不会有栈溢出的风险，适用于非常深的树结构。

---

### [101. 对称二叉树](https://leetcode.com/problems/symmetric-tree/)

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

**示例 1：**

![Image.png](https://pic.leetcode.cn/1698026966-JDYPDU-image.png)

输入：root = [1,2,2,3,4,4,3]

输出：true

**示例 2：**

![Image.png](https://pic.leetcode.cn/1698027008-nPFLbM-image.png)

输入：root = [1,2,2,null,3,null,3]

输出：false

**提示：**

- 树中节点数目在范围 `[1, 1000]` 内
- `-100 <= Node.val <= 100`

进阶：你可以运用递归和迭代两种方法解决这个问题吗？

### 方法一：递归

#### 解题步骤

1. **定义递归函数**：定义一个辅助函数来比较两个节点是否对称。它接受两个节点作为参数。
2. **递归终止条件**：
   - 如果两个节点都为空，返回 `True`。
   - 如果一个节点为空，另一个不为空，或者两个节点的值不相等，返回 `False`。
3. **递归过程**：递归地比较左节点的左子树与右节点的右子树，以及左节点的右子树与右节点的左子树是否对称。

```python
# 定义二叉树节点
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        def isMirror(t1, t2):
            # 如果两个节点都为空，则为对称
            if not t1 and not t2:
                return True
            # 如果一个节点为空而另一个不为空，或者两节点的值不同，则不对称
            if not t1 or not t2 or t1.val != t2.val:
                return False

            # 递归比较当前节点的左右子树是否对称
            return isMirror(t1.left, t2.right) and isMirror(t1.right, t2.left)

        # 从根节点开始判断是否对称
        return isMirror(root, root)
```

#### 时间和空间复杂度

- **时间复杂度**：O(N)，其中 N 是树中节点的数量。每个节点都被访问一次。
- **空间复杂度**：O(H)，其中 H 是树的高度。递归时堆栈需要消耗的空间。

### 方法二：迭代

#### 解题步骤

1. **使用队列**：初始化一个队列，先将根节点的左右子节点加入队列。
2. **迭代过程**：
   - 每次从队列中取出两个节点并比较它们的值。
   - 然后将左节点的左子节点和右节点的右子节点加入队列，再将左节点的右子节点和右节点的左子节点加入队列。
   - 如果队列中的节点不对称或有一个节点为空而另一个不为空，则树不是对称的。

```python
from collections import deque

class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True

        # 使用队列来进行层序遍历
        queue = deque([(root.left, root.right)])
        while queue:
            t1, t2 = queue.popleft()

            # 如果两个节点都为空，继续下一轮循环
            if not t1 and not t2:
                continue
            # 如果一个节点为空而另一个不为空，或者两节点的值不同，则不对称
            if not t1 or not t2 or t1.val != t2.val:
                return False

            # 将当前节点的对称子节点加入队列
            queue.append((t1.left, t2.right))
            queue.append((t1.right, t2.left))

        return True
```

#### 时间和空间复杂度

- **时间复杂度**：O(N)，与递归方法相同。
- **空间复杂度**：O(N)，在最坏的情况下（树完全不平衡），队列中可能包含所有节点。

### 注意事项

- 在递归方法中，正确地处理空节点是关键。
- 在迭代方法中，使用队列正确地存储和比较节点是解题的关键。

这两种方法都是解决这类问题的有效手段。递归方法更简洁，但在树很深时可能会导致栈溢出；而迭代方法更适合处理深度很大的树。根据不同的情况和个人喜好选择合适的方法。

#### 代码随想录算法训练营第十六天 | 104.二叉树的最大深度，559.n叉树的最大深度，111.二叉树的最小深度，222.完全二叉树的节点个数

#### ● day 16 任务以及具体安排：[第六章  二叉树part03](https://docs.qq.com/doc/DUHBQRm1aSWR4T2NK) (12.28)

# 第六章 二叉树part03

今日内容：

●  104.二叉树的最大深度  559.n叉树的最大深度

●  111.二叉树的最小深度

●  222.完全二叉树的节点个数

迭代法，大家可以直接过，二刷有精力的时候 再去掌握迭代法。

## 详细布置

### 104.二叉树的最大深度 （优先掌握递归）

什么是深度，什么是高度，如何求深度，如何求高度，这里有关系到二叉树的遍历方式。

大家 要先看视频讲解，就知道以上我说的内容了，很多录友刷过这道题，但理解的还不够。

题目链接/文章讲解/视频讲解： [https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html](https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html)

### 111.二叉树的最小深度 （优先掌握递归）

先看视频讲解，和最大深度 看似差不多，其实 差距还挺大，有坑。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html](https://programmercarl.com/0111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html)

### 222.完全二叉树的节点个数（优先掌握递归）

需要了解，普通二叉树 怎么求，完全二叉树又怎么求

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html](https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html)

[Just a moment...](https://chat.openai.com/share/b80e87ee-91a3-44d9-9bcb-61addb5e5b98)

---

### [104.二叉树的最大深度](https://leetcode.com/problems/maximum-depth-of-binary-tree/)

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

**示例 1：**

![Image.jpg](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)

输入：root = [3,9,20,null,null,15,7]

输出：3

**示例 2：**

输入：root = [1,null,2]

输出：2

**提示：**

- 树中节点的数量在 `[0, 104]` 区间内。
- `-100 <= Node.val <= 100`

#### 递归法

**解题思路**：

   - 如果二叉树为空，即根节点为null，则最大深度为0。
   - 如果不为空，则计算左子树和右子树的最大深度。
   - 二叉树的最大深度等于左子树和右子树的最大深度的最大值加1（加的1是根节点）。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        # 如果根节点为空，则返回深度0
        if not root:
            return 0
        # 递归计算左子树和右子树的深度
        left_depth = self.maxDepth(root.left)
        right_depth = self.maxDepth(root.right)
        # 返回最大深度
        return max(left_depth, right_depth) + 1
```

**复杂度分析**：

   时间复杂度：O(N)，其中N是树中的节点数。每个节点只访问一次。

   空间复杂度：最坏情况下（树完全不平衡），递归调用的栈的深度可以达到N。在最好情况下（树完全平衡），栈的深度为log(N)。

**常见错误**：

   忘记考虑树为空的情况。

   未正确理解递归过程中左右子树深度的计算。

**测试案例**：

   测试空树：输入 `root = None`，预期输出 `0`。

   测试只有根节点的树：输入 `root = TreeNode(1)`，预期输出 `1`。

   测试题目给出的示例：输入 `root = [3,9,20,null,null,15,7]`，预期输出 `3`。

---

### [559. N 叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)

给定一个 N 叉树，找到其最大深度。

最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。

**示例 1：**

![Image.png](https://assets.leetcode.com/uploads/2018/10/12/narytreeexample.png)

输入：root = [1,null,3,2,4,null,5,6]

输出：3

**示例 2：**

![Image.png](https://assets.leetcode.com/uploads/2019/11/08/sample_4_964.png)

输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]

输出：5

**提示：**

- 树的深度不会超过 `1000` 。
- 树的节点数目位于 `[0, 104]` 之间。

#### 递归法

**解题思路**：

- 如果树为空，则最大深度为0。
- 如果树不为空，对于每个子节点，计算其子树的最大深度。
- N叉树的最大深度是所有子树的最大深度中的最大值加1（加的1是根节点）。

```python
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []

class Solution:
    def maxDepth(self, root: 'Node') -> int:
        # 如果根节点为空，返回深度0
        if not root:
            return 0

        # 如果没有子节点，返回深度1（只有根节点）
        if not root.children:
            return 1

        # 计算所有子节点的深度，取最大值
        max_depth = 0
        for child in root.children:
            max_depth = max(max_depth, self.maxDepth(child))
        
        # 返回最大深度加上根节点的1
        return max_depth + 1
```

**复杂度分析**：

   - 时间复杂度：O(N)，其中N是树中的节点数。需要访问树中的每个节点。
   - 空间复杂度：最坏情况下（树完全不平衡），递归调用的栈的深度可以达到N。在最好情况下（树完全平衡），栈的深度为树的高度。

**测试案例**：

   - 测试空树：输入 `root = None`，预期输出 `0`。
   - 测试只有根节点的树：输入 `root = Node(1)`，预期输出 `1`。
   - 测试题目给出的示例：输入 `root = [1,null,3,2,4,null,5,6]`，预期输出 `3`。

---

### [111.二叉树的最小深度](https://leetcode.com/problems/minimum-depth-of-binary-tree/)

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明：叶子节点是指没有子节点的节点。

**示例 1：**

![Image.jpg](https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg)

输入：root = [3,9,20,null,null,15,7]

输出：2

**示例 2：**

输入：root = [2,null,3,null,4,null,5,null,6]

输出：5

**提示：**

- 树中节点数的范围在 `[0, 105]` 内
- `-1000 <= Node.val <= 1000`

#### 递归法

**解题思路**：

- 若根节点为空，则最小深度为0。
- 若左子树和右子树都不为空，则需要找出左子树和右子树的最小深度，取二者之间的较小值，再加上根节点。
- 若左子树和右子树中有一个为空，则只需考虑非空的那个子树。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def minDepth(self, root: TreeNode) -> int:
        # 如果根节点为空，则返回深度0
        if not root:
            return 0
        # 如果左子树为空，只需考虑右子树
        if not root.left:
            return self.minDepth(root.right) + 1
        # 如果右子树为空，只需考虑左子树
        if not root.right:
            return self.minDepth(root.left) + 1
        # 如果左右子树都不为空，取较小的深度
        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1
```

**复杂度分析**：

- 时间复杂度：O(N)，其中N是树中的节点数。在最坏情况下，我们可能需要访问树中所有的节点。
- 空间复杂度：最坏情况下（树完全不平衡），递归调用的栈的深度可以达到N。在最好情况下（树是完全平衡的），栈的深度为log(N)。

**常见错误**：

- 忽略了叶子节点的定义，错误地将只有一个子节点的节点视为叶子节点。
- 未正确处理一个子树为空而另一个子树不为空的情况。

**测试案例**：

- 测试空树：输入 `root = None`，预期输出 `0`。
- 测试只有根节点的树：输入 `root = TreeNode(1)`，预期输出 `1`。
- 测试题目给出的示例：输入 `root = [3,9,20,null,null,15,7]`，预期输出 `2`。

---

### [222.完全二叉树的节点个数](https://leetcode.com/problems/count-complete-tree-nodes/)

给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。

[完全二叉树](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层，则该层包含 `1~ 2h` 个节点。

**示例 1：**

![Image.jpg](https://assets.leetcode.com/uploads/2021/01/14/complete.jpg)

输入：root = [1,2,3,4,5,6]

输出：6

**示例 2：**

输入：root = []

输出：0

**示例 3：**

输入：root = [1]

输出：1

**提示：**

- 树中节点的数目范围是`[0, 5 * 104]`
- `0 <= Node.val <= 5 * 104`
- 题目数据保证输入的树是 **完全二叉树**

进阶：遍历树来统计节点是一种时间复杂度为 `O(n)` 的简单解决方案。你可以设计一个更快的算法吗？

#### 递归法

**解题思路**：

- 如果二叉树为空，则节点数为0。
- 如果二叉树非空，则节点数为左子树的节点数加上右子树的节点数，再加上根节点本身。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def countNodes(self, root: TreeNode) -> int:
        # 如果节点为空，返回0
        if not root:
            return 0
        # 递归计算左子树和右子树的节点数，再加上根节点
        return 1 + self.countNodes(root.left) + self.countNodes(root.right)
```

**复杂度分析**：

   - 时间复杂度：O(n)，其中n是树中的节点数。该算法需要访问树中的每个节点一次。
   - 空间复杂度：最坏情况下（树完全不平衡），递归调用的栈的深度可以达到n。在最好情况下（树完全平衡），栈的深度为log(n)。

**测试案例**：

   - 测试空树：输入 `root = None`，预期输出 `0`。
   - 测试只有一个节点的树：输入 `root = TreeNode(1)`，预期输出 `1`。
   - 测试题目给出的示例：输入 `root = [1,2,3,4,5,6]`，预期输出 `6`。

---

#### 层序遍历+二分法

#### **解题思路**：

- 利用完全二叉树的性质，可以通过计算树的高度和最后一层的节点数来优化。
- 首先，计算树的高度。
- 然后，使用二分查找方法找出最后一层的节点数。
- 计算节点总数：`总节点数 = 最后一层之前的所有节点数 + 最后一层的节点数`。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def countNodes(self, root: TreeNode) -> int:
        if not root:
            return 0

        def get_depth(node):
            # 计算树的深度
            depth = 0
            while node.left:
                node = node.left
                depth += 1
            return depth

        def exists(idx, depth, node):
            # 判断最后一层的某个位置是否存在节点
            left, right = 0, 2**depth - 1
            for _ in range(depth):
                mid = (left + right) // 2
                if idx <= mid:
                    node = node.left
                    right = mid
                else:
                    node = node.right
                    left = mid + 1
            return node is not None

        depth = get_depth(root)
        if depth == 0:
            return 1
        
        # 二分查找最后一层的节点数
        left, right = 1, 2**depth - 1
        while left <= right:
            mid = (left + right) // 2
            if exists(mid, depth, root):
                left = mid + 1
            else:
                right = mid - 1
        
        # 计算总节点数
        return (2**depth - 1) + left
```

**复杂度分析**：

   - 时间复杂度：O(log^2(n))，其中n是树中的节点数。这是因为我们首先通过O(log(n))的时间计算树的高度，然后通过O(log(n))的时间对最后一层进行二分查找。
   - 空间复杂度：O(1)，不考虑递归调用栈的空间。

**测试案例**：

   - 测试空树：输入 `root = None`，预期输出 `0`。
   - 测试只有一个节点的树：输入 `root = TreeNode(1)`，预期输出 `1`。
   - 测试题目给出的示例：输入 `root = [1,2,3,4,5,6]`，预期输出 `6`。

**进阶**：上述解法已经是较优的解法之一，利用了完全二叉树的性质来减少不必要的节点访问。

#### 代码随想录算法训练营第十七天 | 110.平衡二叉树， 257. 二叉树的所有路径， 404.左叶子之和

#### ● day 16 任务以及具体安排：[第六章  二叉树part03](https://docs.qq.com/doc/DUHBQRm1aSWR4T2NK) (12.28)

# 第六章 二叉树part04

今日内容：

●  110.平衡二叉树

●  257. 二叉树的所有路径

●  404.左叶子之和

## 详细布置

迭代法，大家可以直接过，二刷有精力的时候 再去掌握迭代法。

### 110.平衡二叉树 （优先掌握递归）

再一次涉及到，什么是高度，什么是深度，可以巩固一下。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html](https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html)

### 257. 二叉树的所有路径 （优先掌握递归）

这是大家第一次接触到回溯的过程， 我在视频里重点讲解了 本题为什么要有回溯，已经回溯的过程。

如果对回溯 似懂非懂，没关系， 可以先有个印象。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html](https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html)

### 404.左叶子之和 （优先掌握递归）

其实本题有点文字游戏，搞清楚什么是左叶子，剩下的就是二叉树的基本操作。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html](https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html)

---

### [110.平衡二叉树](https://leetcode.com/problems/balanced-binary-tree/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树_每个节点_ 的左右两个子树的高度差的绝对值不超过 1 。

**示例 1：** 输入：root = [3,9,20,null,null,15,7]
输出：true

![Image.jpg](https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg)

**示例 2：** 输入：root = [1,2,2,3,3,null,null,4,4]
输出：false

![Image.jpg](https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg)

**示例 3：** 输入：root = []
输出：true **提示：**

- 树中的节点数在范围 `[0, 5000]` 内
- `-104 <= Node.val <= 104`

#### 解题思路

求高度用后序遍历，求深度用前序遍历。

1. **定义递归函数**：编写一个辅助函数 `height`，用于计算二叉树的高度。这个函数同时检查子树是否平衡。如果不平衡，则提前返回。
2. **计算高度和判断平衡**：在计算高度的同时，判断当前子树是否平衡。如果左子树或右子树的高度差超过 1，则不平衡。
3. **递归终止条件**：如果节点为空，返回高度 0。如果发现不平衡的情况，提前返回。
4. **整合判断**：对于每个节点，我们都通过递归调用 `height` 函数来判断它的左右子树的平衡性和高度。
5. **返回结果**：如果整棵树是平衡的，返回 `true`，否则返回 `false`。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def isBalanced(self, root: TreeNode) -> bool:
        # 计算树的高度的同时检查平衡性
        def height(node):
            if not node:
                return 0
            left_height = height(node.left)
            right_height = height(node.right)
            # 如果左右子树高度差超过1，或者子树本身不平衡，则不平衡
            if left_height == -1 or right_height == -1 or abs(left_height - right_height) > 1:
                return -1
            return max(left_height, right_height) + 1

        # 如果树的高度不为-1，则平衡
        return height(root) != -1
```

#### **时间复杂度和空间复杂度分析**：

- 时间复杂度：O(N)，其中 N 是树中的节点数。我们需要遍历每个节点一次来计算高度。
- 空间复杂度：O(N)，其中 N 是树的高度。在最坏情况下，树完全不平衡，系统递归需要 O(N) 的栈空间。

#### **常见错误**：

- 忽略提前终止：如果子树已经不平衡，应立即停止计算，避免不必要的遍历。
- 错误处理空节点：空节点的高度应为 0。

#### 视频讲解：

[后序遍历求高度，高度判断是否平衡 | LeetCode：110.平衡二叉树](https://youtu.be/FIkzQqPfMRw?si=EzPhO6KEj2UYzmkg)

---

### [257. 二叉树的所有路径](https://leetcode.com/problems/binary-tree-paths/)

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

**示例 1：**

![Image.jpg](https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg)

输入：root = [1,2,3,null,5]

**输出：**["1->2->5","1->3"]

**示例 2：**

输入：root = [1]

**输出：**["1"]

**提示：**

- 树中节点的数目在范围 `[1, 100]` 内
- `-100 <= Node.val <= 100`

#### 解题思路

使用前序遍历，这样才能让父节点指向孩子节点。

1. **定义递归函数**：创建一个辅助函数 `dfs`，它接受当前节点和到目前为止的路径作为参数。
2. **递归遍历**：从根节点开始，遍历每个节点。对于每个节点，我们将它的值加到路径字符串中。
3. **检查叶子节点**：如果当前节点是叶子节点（即没有左右子节点），则将当前的路径字符串添加到结果列表中。
4. **递归终止条件**：如果当前节点为空，则直接返回。
5. **返回结果**：最终，我们返回包含所有路径的列表。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        def dfs(node, path):
            if not node:
                return
            # 将当前节点加入路径
            path += str(node.val)
            # 如果是叶子节点，加入结果列表
            if not node.left and not node.right:
                paths.append(path)
            else:
                # 继续递归遍历左右子树
                dfs(node.left, path + "->")
                dfs(node.right, path + "->")

        paths = []
        dfs(root, "")
        return paths
```

#### **时间复杂度和空间复杂度分析**：

- 时间复杂度：O(N)，其中 N 是树中的节点数。我们需要遍历每个节点一次。
- 空间复杂度：O(N)，最坏情况下，递归栈的深度可以达到 N，同时还需要空间来存储路径。

#### 视频讲解：

[递归中带着回溯，你感受到了没？| LeetCode：257. 二叉树的所有路径](https://youtu.be/Frtd83BY2pQ?si=2drOvWdr7MSit2gK)

---

### [404.左叶子之和](https://leetcode.com/problems/sum-of-left-leaves/)

给定二叉树的根节点 `root` ，返回所有左叶子之和。

**示例 1：**

![Image.jpg](https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg)

**输入:** root = [3,9,20,null,null,15,7]

**输出:** 24

**解释:** 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24

**示例 2:**

**输入:** root = [1]

**输出:** 0

**提示:**

- 节点数在 `[1, 1000]` 范围内
- `-1000 <= Node.val <= 1000`

#### 解题思路：

1. **定义递归函数**：创建一个辅助函数 `dfs`，用于遍历树并计算左叶子节点的和。
2. **判断左叶子节点**：在遍历树时，如果当前节点是其父节点的左子节点，并且没有自己的子节点，那么它就是一个左叶子节点。
3. **递归遍历**：从根节点开始，递归地遍历每个节点。对于每个节点，检查它是否是左叶子节点，如果是，则累加其值。
4. **递归终止条件**：如果当前节点为空，则直接返回。
5. **返回结果**：最终返回所有左叶子之和。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -> int:
        def dfs(node, is_left):
            if not node:
                return 0
            # 检查是否是左叶子节点
            if is_left and not node.left and not node.right:
                return node.val
            # 递归遍历左右子树
            return dfs(node.left, True) + dfs(node.right, False)

        return dfs(root, False)

# 示例用法
# root = TreeNode(3)
# root.left = TreeNode(9)
# root.right = TreeNode(20, TreeNode(15), TreeNode(7))
# sol = Solution()
# print(sol.sumOfLeftLeaves(root))  # 输出应为 24
```

#### **时间复杂度和空间复杂度分析**：

- 时间复杂度：O(N)，其中 N 是树中的节点数。我们需要遍历每个节点一次。
- 空间复杂度：O(N)，在最坏情况下，树完全不平衡，系统递归需要 O(N) 的栈空间。

#### 视频讲解：

[二叉树的题目中，总有一些规则让你找不到北 | LeetCode：404.左叶子之和](https://youtu.be/f5NFns93h58?si=ENV8AuJLU6ZNBWGo)

#### 代码随想录算法训练营第十八天 | 513.找树左下角的值，112. 路径总和，113.路径总和ii，106.从中序与后序遍历序列构造二叉树，105.从前序与中序遍历序列构造二叉树

#### ● day 18 任务以及具体安排：[第六章 二叉树 part05](https://docs.qq.com/doc/DUFFiVHl3YVlReVlr) (12.30)

# 第六章 二叉树 part05

# 今日内容

●  513.找树左下角的值

●  112. 路径总和  113.路径总和ii

●  106.从中序与后序遍历序列构造二叉树 105.从前序与中序遍历序列构造二叉树

## 详细布置

### 找树左下角的值

本地递归偏难，反而迭代简单属于模板题， 两种方法掌握一下

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html](https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html)

### 路径总和

本题 又一次设计要回溯的过程，而且回溯的过程隐藏的还挺深，建议先看视频来理解

112. 路径总和，和 113. 路径总和ii 一起做了。 优先掌握递归法。

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html](https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html)

### 从中序与后序遍历序列构造二叉树

本题算是比较难的二叉树题目了，大家先看视频来理解。

106.从中序与后序遍历序列构造二叉树，105.从前序与中序遍历序列构造二叉树 一起做，思路一样的

题目链接/文章讲解/视频讲解：[https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html](https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html)

[Just a moment...](https://chat.openai.com/share/cfa6133c-0a52-4660-b45b-0bb30f8c0edf)

---

### [513.找树左下角的值](https://leetcode.com/problems/find-bottom-left-tree-value/)

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

假设二叉树中至少有一个节点。

**示例 1:**

![Image.jpg](https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg)

**输入:** root = [2,1,3]

**输出:** 1

**示例 2:**

![Image.jpg](https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg)

**输入:** [1,2,3,4,null,5,6,null,null,7]

**输出:** 7

**提示:**

- 二叉树的节点个数的范围是 `[1,104]`
- `-231 <= Node.val <= 231 - 1`

### 解法一：广度优先搜索

#### 解题思路

要解决这个问题，我们可以使用广度优先搜索（BFS）来遍历二叉树。通过使用队列，我们可以按层级遍历树，始终保持最新的最左边节点的值。以下是解决这个问题的步骤：

1. 初始化一个队列，首先将根节点入队。
2. 进行循环，直到队列为空：
   - 获取当前队列的大小，这代表了这一层的节点数量。
   - 对于这一层的每个节点：
      - 将节点从队列中弹出。
      - 如果是这一层的第一个节点，则记录其值，因为这是最左边的节点。
      - 如果节点有左子节点，将左子节点入队。
      - 如果节点有右子节点，将右子节点入队。
3. 循环结束后，我们将得到最后一层最左边的节点值。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

from collections import deque

def findBottomLeftValue(root):
    if not root:
        return None

    queue = deque([root])
    while queue:
        size = len(queue)
        for i in range(size):
            node = queue.popleft()
            # 如果是这一层的第一个节点，则记录其值
            if i == 0:
                leftmost = node.val
            # 将子节点加入队列
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

    return leftmost

# 示例代码使用
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.right.left = TreeNode(5)
root.right.right = TreeNode(6)
root.right.left.left = TreeNode(7)

print(findBottomLeftValue(root))  # 输出: 7
```

#### **时间复杂度**：

O(N)，其中 N 是树中的节点数。每个节点都会被访问一次。

#### **空间复杂度**：

O(N)，最坏情况下，队列中可能包含接近树的一半的节点。例如在完全二叉树中。

#### **常见错误**：

- 不正确处理空树的情况。
- 忘记更新最左边节点的值。

### 解法二：深度优先搜索

#### 解题思路：

我们也可以使用深度优先搜索（DFS）来解决这个问题。在使用递归进行DFS时，我们需要跟踪每个节点的深度，并且更新我们找到的最深的节点。

1. 初始化一个变量来存储最左边节点的值以及该节点的深度。
2. 使用一个递归函数来遍历树，该函数需要记录当前节点的深度。
3. 如果当前节点的深度大于我们之前记录的最深深度，更新最深深度和最左边节点的值。
4. 首先递归遍历左子树，然后递归遍历右子树（这样可以保证如果在同一深度有多个节点，我们选择最左边的那个）。
5. 完成遍历后，返回记录的最左边节点的值。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def findBottomLeftValue(root):
    def dfs(node, depth):
        nonlocal maxDepth, leftmostValue
        if not node:
            return
        # 如果当前深度大于之前记录的最大深度，则更新最左边的值
        if depth > maxDepth:
            maxDepth = depth
            leftmostValue = node.val
        # 先左后右地递归遍历
        dfs(node.left, depth + 1)
        dfs(node.right, depth + 1)

    maxDepth = -1
    leftmostValue = 0
    dfs(root, 0)
    return leftmostValue

# 示例代码使用
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.left = TreeNode(4)
root.right.left = TreeNode(5)
root.right.right = TreeNode(6)
root.right.left.left = TreeNode(7)

print(findBottomLeftValue(root))  # 输出: 7
```

**时间复杂度**：O(N)，其中 N 是树中的节点数。每个节点都会被访问一次。

**空间复杂度**：O(H)，其中 H 是树的高度，用于递归栈空间。在最坏情况下，树可能是线性的，高度可以达到 O(N)。

#### 视频讲解：

[怎么找二叉树的左下角？ 递归中又带回溯了，怎么办？| LeetCode：513.找树左下角的值](https://youtu.be/cUY3uA3am4w?si=1AKtXTw7Hg_MNvZz)

---

### [112. 路径总和](https://leetcode.com/problems/path-sum/)

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**叶子节点** 是指没有子节点的节点。

**示例 1：**

![Image.jpg](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)

输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22

输出：true

解释：等于目标和的根节点到叶节点路径如上图所示。

**示例 2：**

![Image.jpg](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)

输入：root = [1,2,3], targetSum = 5

输出：false

解释：树中存在两条根节点到叶子节点的路径：

(1 --> 2): 和为 3

(1 --> 3): 和为 4

不存在 sum = 5 的根节点到叶子节点的路径。

**示例 3：**

输入：root = [], targetSum = 0

输出：false

*解释：由于树是空的，所以不存在根节点到叶子节点的路径。

**提示：**

- 树中节点的数目在范围 `[0, 5000]` 内
- `-1000 <= Node.val <= 1000`
- `-1000 <= targetSum <= 1000`

#### 解题思路：

为了解决这个问题，我们可以使用深度优先搜索（DFS）。我们从根节点开始，递归地检查每个路径是否能达到目标和。下面是解决这个问题的步骤：

1. 如果当前节点是 `null`，返回 `false`，因为空节点不能构成路径。
2. 如果当前节点是叶子节点（没有子节点），检查其值是否等于目标和。如果是，返回 `true`；否则，返回 `false`。
3. 递归地检查左子节点和右子节点，将目标和减去当前节点的值。
4. 如果左子节点或右子节点的递归调用返回 `true`，则整个函数返回 `true`；否则返回 `false`。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def hasPathSum(root, targetSum):
    if not root:
        return False

    if not root.left and not root.right:
        # 检查是否是叶子节点，且值等于目标和
        return root.val == targetSum

    # 递归检查左右子树
    return hasPathSum(root.left, targetSum - root.val) or hasPathSum(root.right, targetSum - root.val)

# 示例代码使用
root = TreeNode(5)
root.left = TreeNode(4)
root.right = TreeNode(8)
root.left.left = TreeNode(11, TreeNode(7), TreeNode(2))
root.right.left = TreeNode(13)
root.right.right = TreeNode(4, None, TreeNode(1))

print(hasPathSum(root, 22))  # 输出: True
```

**时间复杂度**：O(N)，其中 N 是树中的节点数。在最坏的情况下，我们可能需要访问树中的所有节点。

**空间复杂度**：O(H)，其中 H 是树的高度。这是因为递归栈的最大深度等于树的高度。

#### 视频讲解：

[拿不准的遍历顺序，搞不清的回溯过程，我太难了！ | LeetCode：112. 路径总和](https://youtu.be/0CjZRz0Asws?si=t0fnF5DylkekfHUh)

---

### [113.路径总和ii](https://leetcode.com/problems/path-sum-ii/)

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

**叶子节点** 是指没有子节点的节点。

**示例 1：**

![Image.jpg](https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg)

输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22

**输出：**[[5,4,11,2],[5,8,4,5]]

**示例 2：**

![Image.jpg](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)

输入：root = [1,2,3], targetSum = 5

**输出：**[]

**示例 3：**

输入：root = [1,2], targetSum = 0

**输出：**[]

**提示：**

- 树中节点总数在范围 `[0, 5000]` 内
- `-1000 <= Node.val <= 1000`
- `-1000 <= targetSum <= 1000`

#### 解题思路：

要解决这个问题，我们需要使用深度优先搜索（DFS）来遍历二叉树，并且记录每条到达叶子节点且节点值之和等于目标和的路径。以下是解决这个问题的步骤：

1. **初始化一个列表**来存储所有符合条件的路径。
2. **使用一个辅助函数**来进行递归遍历。这个函数需要维护当前路径和当前路径的总和。
3. **在遍历过程中**，将当前节点添加到当前路径中。如果当前节点是叶子节点且当前路径的总和等于目标和，则将这条路径添加到结果列表中。
4. **递归调用**左右子节点。
5. **回溯**：在返回到父节点之前，从当前路径中移除当前节点。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def pathSum(root, targetSum):
    def dfs(node, currentSum, path):
        if not node:
            return
        
        currentSum += node.val
        path.append(node.val)

        # 检查当前节点是否是叶子节点且路径和等于目标和
        if not node.left and not node.right and currentSum == targetSum:
            result.append(list(path))
        
        # 递归左右子树
        dfs(node.left, currentSum, path)
        dfs(node.right, currentSum, path)

        # 回溯
        path.pop()

    result = []
    dfs(root, 0, [])
    return result

# 示例代码使用
root = TreeNode(5)
root.left = TreeNode(4)
root.right = TreeNode(8)
root.left.left = TreeNode(11, TreeNode(7), TreeNode(2))
root.right.left = TreeNode(13)
root.right.right = TreeNode(4, TreeNode(5), TreeNode(1))

print(pathSum(root, 22))  # 输出: [[5,4,11,2],[5,8,4,5]]
```

**时间复杂度**：O(N^2)，其中 N 是树中的节点数。在最坏的情况下，我们可能需要访问树中的所有节点，并且对于树中的每个节点，我们可能需要 O(N) 的时间来复制路径。

**空间复杂度**：O(N)，这是因为递归栈的深度最多为 N，并且路径列表在最坏的情况下也可能需要 O(N) 的空间。

---

### [106.从中序与后序遍历序列构造二叉树](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。

**示例 1:**

![Image.jpg](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]

**输出：**[3,9,20,null,null,15,7]

**示例 2:**

输入：inorder = [-1], postorder = [-1]

**输出：**[-1]

**提示:**

- `1 <= inorder.length <= 3000`
- `postorder.length == inorder.length`
- `-3000 <= inorder[i], postorder[i] <= 3000`
- `inorder` 和 `postorder` 都由 **不同** 的值组成
- `postorder` 中每一个值都在 `inorder` 中
- `inorder` **保证**是树的中序遍历
- `postorder` **保证**是树的后序遍历

#### 解题思路：

要从中序和后序遍历序列构造二叉树，我们可以利用中序遍历和后序遍历的特性来递归地构建整棵树。中序遍历的顺序是“左-根-右”，而后序遍历的顺序是“左-右-根”。在后序遍历数组中，最后一个元素总是树的根节点，我们可以利用这个信息在中序遍历数组中找到根节点，然后确定左子树和右子树的节点。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20210203154249860.png)

1. 如果后序遍历数组为空，则树为空，返回 `null`。
2. 后序遍历数组的最后一个元素是树的根节点。创建一个新的树节点，节点的值为后序数组的最后一个元素。
3. 在中序遍历数组中找到这个根节点的位置，这将中序数组分为两部分：左子树的中序遍历和右子树的中序遍历。
4. 利用中序遍历数组中的左子树和右子树，以及后序遍历数组中对应的部分（注意后序数组的长度应该与中序数组的子数组长度相同），递归地构建左子树和右子树。
5. 将构建的左子树和右子树分别作为根节点的左右子节点。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def buildTree(inorder, postorder):
    if not inorder or not postorder:
        return None

    # 后序遍历的最后一个元素是根节点
    root_val = postorder.pop()
    root = TreeNode(root_val)

    # 在中序遍历中找到根节点的位置
    index = inorder.index(root_val)

    # 递归地构建右子树和左子树
    root.right = buildTree(inorder[index+1:], postorder[index:-1])
    root.left = buildTree(inorder[:index], postorder[:index])

    return root

# 示例代码使用
inorder = [9, 3, 15, 20, 7]
postorder = [9, 15, 7, 20, 3]
tree = buildTree(inorder, postorder)
```

这个算法的核心在于定位根节点，并根据根节点在中序遍历中的位置划分左右子树，然后递归地构建每个子树。这种方法能够正确地从中序和后序遍历序列中构造出原始的二叉树。

#### 视频讲解：

[坑很多！来看看你掉过几次坑 | LeetCode：106.从中序与后序遍历序列构造二叉树](https://youtu.be/_KCfIPqKWas?si=6YWdjNjzkbVn8b2_)

---

### [105.从前序与中序遍历序列构造二叉树](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

**示例 1:**

![Image.jpg](https://assets.leetcode.com/uploads/2021/02/19/tree.jpg)

**输入**: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]

**输出:** [3,9,20,null,null,15,7]

**示例 2:**

**输入:** preorder = [-1], inorder = [-1]

**输出:** [-1]

**提示:**

- `1 <= preorder.length <= 3000`
- `inorder.length == preorder.length`
- `-3000 <= preorder[i], inorder[i] <= 3000`
- `preorder` 和 `inorder` 均 **无重复** 元素
- `inorder` 均出现在 `preorder`
- `preorder` **保证** 为二叉树的前序遍历序列
- `inorder` **保证** 为二叉树的中序遍历序列

#### 解题思路：

为了从先序遍历和中序遍历序列构造二叉树，我们可以利用先序遍历和中序遍历的特性。在先序遍历中，第一个元素总是树的根节点。在中序遍历中，根节点的位置可以将数组分为两部分，分别表示树的左子树和右子树。以下是构造二叉树的具体步骤：

1. 如果先序遍历数组为空，则树为空，返回 `null`。
2. 先序遍历数组的第一个元素是树的根节点。创建一个新的树节点，节点的值为先序数组的第一个元素。
3. 在中序遍历数组中找到这个根节点的位置，这将中序数组分为两部分：左子树的中序遍历和右子树的中序遍历。
4. 在先序遍历数组中，根据中序数组中左子树和右子树的长度，划分出左子树和右子树的先序遍历。
5. 递归地使用左子树的先序遍历和中序遍历构建左子树，使用右子树的先序遍历和中序遍历构建右子树。
6. 将构建的左子树和右子树分别作为根节点的左右子节点。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def buildTree(preorder, inorder):
    if not preorder or not inorder:
        return None

    # 先序遍历的第一个元素是根节点
    root_val = preorder[0]
    root = TreeNode(root_val)

    # 在中序遍历中找到根节点的位置
    index = inorder.index(root_val)

    # 递归构建左子树和右子树
    root.left = buildTree(preorder[1:index+1], inorder[:index])
    root.right = buildTree(preorder[index+1:], inorder[index+1:])

    return root

# 示例代码使用
preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
tree = buildTree(preorder, inorder)
```

#### 代码随想录算法训练营第二十天 | 654.最大二叉树，617.合并二叉树，700.二叉搜索树中的搜索，98.验证二叉搜索树

#### ● day 20 任务以及具体安排：[第六章 二叉树 part06](https://docs.qq.com/doc/DUGFRU2V6Z1F4alBH) (1.1)

# 第六章 二叉树 part06

今日内容

●  654.最大二叉树

●  617.合并二叉树

●  700.二叉搜索树中的搜索

●  98.验证二叉搜索树

## 详细布置

### 654.最大二叉树

又是构造二叉树，昨天大家刚刚做完 中序后序确定二叉树，今天做这个 应该会容易一些， 先看视频，好好体会一下 为什么构造二叉树都是 前序遍历

题目链接/文章讲解：[https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html](https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html)

视频讲解：[https://www.bilibili.com/video/BV1MG411G7ox](https://www.bilibili.com/video/BV1MG411G7ox)

### 617.合并二叉树

这次是一起操作两个二叉树了， 估计大家也没一起操作过两个二叉树，也不知道该如何一起操作，可以看视频先理解一下。 优先掌握递归。

题目链接/文章讲解：[https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html](https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html)

视频讲解：[https://www.bilibili.com/video/BV1m14y1Y7JK](https://www.bilibili.com/video/BV1m14y1Y7JK)

### 700.二叉搜索树中的搜索

递归和迭代 都可以掌握以下，因为本题比较简单， 了解一下 二叉搜索树的特性

题目链接/文章讲解: [https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html](https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html)

视频讲解：[https://www.bilibili.com/video/BV1wG411g7sF](https://www.bilibili.com/video/BV1wG411g7sF)

### 98.验证二叉搜索树

遇到 搜索树，一定想着中序遍历，这样才能利用上特性。

但本题是有陷阱的，可以自己先做一做，然后在看题解，看看自己是不是掉陷阱里了。这样理解的更深刻。

题目链接/文章讲解：[https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html](https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html)

视频讲解：[https://www.bilibili.com/video/BV18P411n7Q4](https://www.bilibili.com/video/BV18P411n7Q4)

[Just a moment...](https://chat.openai.com/share/eabfbb0c-0274-4c5e-8fd0-39d568152633)

---

### [654.最大二叉树](https://leetcode.com/problems/maximum-binary-tree/)

给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:

1. 创建一个根节点，其值为 `nums` 中的最大值。
2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。

返回 `nums` *构建的* ***最大二叉树*** 。

**示例 1：**

![Image.jpg](https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg)

输入：nums = [3,2,1,6,0,5]

**输出：**[6,3,5,null,2,0,null,null,1]

解释：递归调用如下所示：

- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
   - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
      - 空数组，无子节点。
      - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
         - 空数组，无子节点。
         - 只有一个元素，所以子节点是一个值为 1 的节点。
   - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
      - 只有一个元素，所以子节点是一个值为 0 的节点。
      - 空数组，无子节点。

**示例 2：**

![Image.jpg](https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg)

输入：nums = [3,2,1]

**输出：**[3,null,2,null,1]

**提示：**

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`
- `nums` 中的所有整数 **互不相同**

### 解法一：递归

#### 解题思路：

1. **确定递归函数的参数和返回值**：递归函数需要数组和处理的范围（起始和结束位置），返回构建的树的根节点。
2. **确定终止条件**：当数组为空或起始位置大于结束位置时，返回空。
3. **确定单层递归的逻辑**：
   - 在当前范围内找到最大值和对应的索引。
   - 以最大值创建根节点。
   - 递归构建左子树和右子树。
   - 将构建的左右子树分别连接到根节点的左右。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def constructMaximumBinaryTree(nums):
    def construct(nums, left, right):
        if left > right:
            return None
        # 找到最大值及其索引
        max_val = max(nums[left:right+1])
        max_index = nums.index(max_val)
        # 创建根节点
        root = TreeNode(max_val)
        # 递归构建左右子树
        root.left = construct(nums, left, max_index-1)
        root.right = construct(nums, max_index+1, right)
        return root
    
    return construct(nums, 0, len(nums)-1)

# 测试用例
nums = [3,2,1,6,0,5]
tree = constructMaximumBinaryTree(nums)
```

#### 时间复杂度和空间复杂度分析：

- **时间复杂度**：O(n^2)，其中n是数组长度。在最坏情况下（数组已排序），每次递归都需要O(n)时间找到最大值，共需要递归n次。
- **空间复杂度**：O(n)，递归调用栈的深度。

#### 常见错误：

- 忽略递归终止条件，导致无限递归。
- 未正确处理左右子树的范围，导致数组索引越界。

#### 视频讲解：

[又是构造二叉树，又有很多坑！| LeetCode：654.最大二叉树](https://youtu.be/BdvvHGwCz54?si=gaSRP-9TLvGygrpm)

### 解法二：单调栈

#### 解题思路：

使用单调栈可以优化查找最大值的过程，从而降低整体的时间复杂度。单调栈的核心思想是维护一个单调递减的栈，这样我们可以快速找到每个节点的左边和右边第一个比它大的元素。

1. **遍历数组**：对于每个元素，我们将其与栈顶元素进行比较。
2. **维护单调栈**：如果当前元素比栈顶元素大，则栈顶元素的右边第一个比它大的元素找到了，我们弹出栈顶元素，并将当前元素作为栈顶元素的右子节点；反之，如果当前元素小于或等于栈顶元素，则将当前元素作为栈顶元素的左子节点。
3. **处理剩余元素**：数组遍历完成后，栈中可能还有剩余的元素。这些元素没有右边第一个比它大的元素，我们只需继续弹出栈中元素，依次将它们作为新的栈顶元素的右子节点即可。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def constructMaximumBinaryTree(nums):
    stack = []  # 初始化一个空栈，用于存放树节点
    for num in nums:
        node = TreeNode(num)  # 为当前元素创建一个树节点
        # 当栈不为空且栈顶元素小于当前元素时，进行循环
        while stack and stack[-1].val < num:
            # 将栈顶元素弹出，并设置为当前节点的左子节点
            node.left = stack.pop()
        # 如果栈不为空，则将当前节点设置为栈顶节点的右子节点
        if stack:
            stack[-1].right = node
        # 将当前节点压入栈中
        stack.append(node)
    # 返回栈底元素，即最大二叉树的根节点
    return stack[0] if stack else None

# 测试用例
nums = [3,2,1,6,0,5]
tree = constructMaximumBinaryTree(nums)
```

#### 时间复杂度和空间复杂度分析：

- **时间复杂度**：O(n)，其中n是数组长度。每个元素最多入栈和出栈一次。
- **空间复杂度**：O(n)，单调栈的空间。

#### 注意点：

- 单调栈的应用需要对栈的操作非常熟悉。
- 这种方法虽然时间复杂度较低，但理解和实现难度相对较高。

---

### [617.合并二叉树](https://leetcode.com/problems/merge-two-binary-trees/)

给你两棵二叉树： `root1` 和 `root2` 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

**注意:** 合并过程必须从两个树的根节点开始。

**示例 1：**

![Image.jpg](https://assets.leetcode.com/uploads/2021/02/05/merge.jpg)

输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]

**输出：**[3,4,5,5,4,null,7]

**示例 2：**

输入：root1 = [1], root2 = [1,2]

**输出：**[2,2]

**提示：**

- 两棵树中的节点数目在范围 `[0, 2000]` 内
- `-104 <= Node.val <= 104`

#### 解题思路：

为了合并两棵二叉树，我们可以使用递归的方法。在每一步中，我们将考虑当前两棵树的根节点。根据题目描述，合并的规则是：如果两个节点重叠，则将这两个节点的值相加；否则，非空的节点将直接作为新二叉树的节点。

1. **检查节点**：如果 `root1` 或 `root2` 中的任何一个是 `None`，返回另一个节点作为合并的结果。
2. **合并节点**：如果两个节点都不为空，将它们的值相加，并创建一个新的节点作为合并后的节点。
3. **递归合并**：递归地合并每个节点的左子树和右子树。
4. **返回结果**：返回合并后的树的根节点。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def mergeTrees(root1, root2):
    # 如果其中一个树为空，返回另一个树
    if not root1:
        return root2
    if not root2:
        return root1

    # 合并当前节点
    merged = TreeNode(root1.val + root2.val)
    # 递归合并左子树和右子树
    merged.left = mergeTrees(root1.left, root2.left)
    merged.right = mergeTrees(root1.right, root2.right)

    return merged

# 示例
# 构建示例树（省略了树的构建过程）
root1 = TreeNode(1, TreeNode(3, TreeNode(5)), TreeNode(2))
root2 = TreeNode(2, TreeNode(1, right=TreeNode(4)), TreeNode(3, right=TreeNode(7)))

merged_tree = mergeTrees(root1, root2)
```

#### 时间复杂度和空间复杂度分析：

- **时间复杂度**：O(min(m,n))，其中m和n分别是两棵树的节点数。我们需要遍历两棵树中较小的一棵。
- **空间复杂度**：O(min(m,n))，递归调用的深度取决于较小的树的高度。

#### 注意事项：

- 需要考虑树中存在空节点的情况。
- 此方法会创建新的树来存储合并结果，不会修改输入的树。如果需要原地修改其中一棵树，可以适当调整逻辑。

#### 视频讲解：

[一起操作两个二叉树？有点懵！| LeetCode：617.合并二叉树](https://youtu.be/LtWnLemydbo?si=XMh_pG8aPjNCA7T0)

---

### [700.二叉搜索树中的搜索](https://leetcode.com/problems/search-in-a-binary-search-tree/)

给定二叉搜索树（BST）的根节点 `root` 和一个整数值 `val`。

你需要在 BST 中找到节点值等于 `val` 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 `null` 。

**示例 1:**

![Image.jpg](https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg)

输入：root = [4,2,7,1,3], val = 2

**输出：**[2,1,3]

**示例 2:**

![Image.jpg](https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg)

输入：root = [4,2,7,1,3], val = 5

**输出：**[]

**提示：**

- 树中节点数在 `[1, 5000]` 范围内
- `1 <= Node.val <= 107`
- `root` 是二叉搜索树
- `1 <= val <= 107`

#### 解题思路：

要在二叉搜索树（BST）中查找一个特定值的节点，我们可以利用二叉搜索树的特性：左子树的所有节点的值都小于根节点的值，右子树的所有节点的值都大于根节点的值。这使得我们可以高效地定位到特定值的节点。

1. **检查当前节点**：如果当前节点为空，返回 `null`。
2. **比较节点值**：
   - 如果当前节点的值等于 `val`，返回当前节点。
   - 如果 `val` 小于当前节点的值，搜索左子树。
   - 如果 `val` 大于当前节点的值，搜索右子树。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def searchBST(root, val):
    if root is None:
        return None
    if root.val == val:
        return root
    elif val < root.val:
        return searchBST(root.left, val)
    else:
        return searchBST(root.right, val)

# 示例
# 构建示例树（省略了树的构建过程）
root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(7))
val = 2
result = searchBST(root, val)
```

#### 时间复杂度和空间复杂度分析：

- **时间复杂度**：O(h)，其中h是树的高度。在最坏的情况下（树是线性的），时间复杂度为O(n)，其中n是树中节点的数量。
- **空间复杂度**：O(h)，递归调用的深度为树的高度。

#### 注意事项：

- 在二叉搜索树中，可以利用其性质减少不必要的搜索，从而提高效率。
- 如果树不是二叉搜索树，则需要遍历整棵树来查找节点。

#### 视频讲解：

[不愧是搜索树，这次搜索有方向了！| LeetCode：700.二叉搜索树中的搜索](https://youtu.be/phQbPArM__U?si=-YqAjJ8H7VttqqEu)

---

### 98.验证二叉搜索树

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **小于** 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

**示例 1：**

![Image.jpg](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)

输入：root = [2,1,3]

输出：true

**示例 2：**

![Image.jpg](https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg)

输入：root = [5,1,4,null,null,3,6]

输出：false

解释：根节点的值是 5 ，但是右子节点的值是 4 。

**提示：**

- 树中节点数目范围在`[1, 104]` 内
- `-231 <= Node.val <= 231 - 1`

#### 解题思路：

为了验证一个树是否是有效的二叉搜索树（BST），我们需要保证所有左子树的节点值都小于其根节点的值，所有右子树的节点值都大于其根节点的值。此外，左右子树本身也必须是有效的二叉搜索树。

一个有效的方法是使用递归，并传递每个子树的有效值范围。对于每个节点，我们需要确保它的值位于这个范围内。

1. **定义递归函数**：该函数检查当前节点是否在指定的范围内。
2. **检查当前节点**：
   - 如果当前节点为空，返回 `True`。
   - 如果当前节点的值不在指定范围内，返回 `False`。
3. **递归检查子树**：
   - 对于左子树，确保所有节点的值都小于当前节点的值。
   - 对于右子树，确保所有节点的值都大于当前节点的值。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def isValidBST(root):
    def validate(node, low=-float('inf'), high=float('inf')):
        if not node:
            return True
        if not (low < node.val < high):
            return False
        return validate(node.left, low, node.val) and validate(node.right, node.val, high)

    return validate(root)

# 示例
# 构建示例树（省略了树的构建过程）
root1 = TreeNode(2, TreeNode(1), TreeNode(3))
root2 = TreeNode(5, TreeNode(1), TreeNode(4, TreeNode(3), TreeNode(6)))

print(isValidBST(root1))  # 应该返回 True
print(isValidBST(root2))  # 应该返回 False
```

#### 时间复杂度和空间复杂度分析：

- **时间复杂度**：O(n)，其中n是树中的节点数。在最坏的情况下，我们可能需要访问树中的每个节点。
- **空间复杂度**：O(n)，递归调用栈的空间。

#### 注意事项：

- 需要处理边界条件，例如节点值等于 `INT_MIN` 或 `INT_MAX`。
- 递归函数中的范围需要正确更新，以保证左子树的所有节点都小于当前节点，右子树的所有节点都大于当前节点。

#### 视频讲解：

[你对二叉搜索树了解的还不够！ | LeetCode：98.验证二叉搜索树](https://youtu.be/zU0f-0U5iH8?si=tL9NH1f8KH3SHy-4)

#### 代码随想录算法训练营第二十一天 | 530.二叉搜索树的最小绝对差，501.二叉搜索树中的众数，236. 二叉树的最近公共祖先

#### ● day 21 任务以及具体安排：[第六章 二叉树part07](https://docs.qq.com/doc/DUHl2SGNvZmxqZm1X) (1.2)

# 第六章 二叉树part07

今日内容

●  530.二叉搜索树的最小绝对差

●  501.二叉搜索树中的众数

●  236. 二叉树的最近公共祖先

## 详细布置

### 530.二叉搜索树的最小绝对差

需要领悟一下二叉树遍历上双指针操作，优先掌握递归

题目链接/文章讲解：[https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html](https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html)

视频讲解：[https://www.bilibili.com/video/BV1DD4y11779](https://www.bilibili.com/video/BV1DD4y11779)

### 501.二叉搜索树中的众数

和 530差不多双指针思路，不过 这里涉及到一个很巧妙的代码技巧。

可以先自己做做看，然后看我的视频讲解。

[代码随想录](https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html)

视频讲解：[https://www.bilibili.com/video/BV1fD4y117gp](https://www.bilibili.com/video/BV1fD4y117gp)

### 236. 二叉树的最近公共祖先

本题其实是比较难的，可以先看我的视频讲解

[代码随想录](https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html)

视频讲解：[https://www.bilibili.com/video/BV1jd4y1B7E2](https://www.bilibili.com/video/BV1jd4y1B7E2)

[Just a moment...](https://chat.openai.com/share/67750acf-8b80-475e-b75d-5c56d76562ba)

---

### [530.二叉搜索树的最小绝对差](https://leetcode.com/problems/minimum-absolute-difference-in-bst/)

给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。

差值是一个正数，其数值等于两值之差的绝对值。

**示例 1：**

![Image.jpg](https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg)

输入：root = [4,2,6,1,3]

输出：1

**示例 2：**

![Image.jpg](https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg)

输入：root = [1,0,48,null,null,12,49]

输出：1

**提示：**

- 树中节点的数目范围是 `[2, 104]`
- `0 <= Node.val <= 105`

注意：本题与 783 [https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/](https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/) 相同

#### 解题思路：

针对题目「530. 二叉搜索树的最小绝对差」，我们可以利用二叉搜索树（BST）的性质来解决。BST的特性是对于任意节点N，其左子树的所有节点的值都小于N的值，右子树的所有节点的值都大于N的值。这个特性使得中序遍历BST时得到的值序列是有序的。因此，我们可以通过中序遍历来找到任意两个相邻节点之间的最小差值。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20210204153247458.png)

1. 进行中序遍历BST。在遍历的过程中，比较当前节点和前一个节点的值，记录下这两个值的差值。
2. 更新最小差值。如果当前差值小于之前记录的最小差值，则更新最小差值。
3. 完成遍历后，返回最小差值。

```python
class Solution:
    def getMinimumDifference(self, root):
        # 初始化前一个节点值为负无穷，最小差值为正无穷
        self.prev = -float('inf')
        self.min_diff = float('inf')

        # 中序遍历函数
        def inorder(node):
            if not node:
                return
            # 先遍历左子树
            inorder(node.left)
            # 更新最小差值
            self.min_diff = min(self.min_diff, node.val - self.prev)
            # 记录当前节点值，作为下一个节点的前一个节点值
            self.prev = node.val
            # 遍历右子树
            inorder(node.right)

        # 对树进行中序遍历
        inorder(root)
        # 返回计算出的最小差值
        return self.min_diff
```

#### 时空复杂度：

时间复杂度是O(N)，因为需要遍历树中的每个节点。

空间复杂度是O(H)，其中H是树的高度，这是由于递归的栈空间所需。

#### 疑难点：

1. 忘记更新前一个节点的值。
2. 不正确地处理最小差值的初始值。

#### 视频讲解：

[二叉搜索树中，需要掌握如何双指针遍历！| LeetCode：530.二叉搜索树的最小绝对差 |  530. Minimum Absolute Difference in BST](https://youtu.be/3TEXUn10fiE?si=2R-83CCRv6ujS_e0)

---

### [501.二叉搜索树中的众数](https://leetcode.com/problems/find-mode-in-binary-search-tree/)

给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有 [众数](https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796)（即，出现频率最高的元素）。

如果树中有不止一个众数，可以按 **任意顺序** 返回。

假定 BST 满足如下定义：

- 结点左子树中所含节点的值 **小于等于** 当前节点的值
- 结点右子树中所含节点的值 **大于等于** 当前节点的值
- 左子树和右子树都是二叉搜索树

**示例 1：**

![Image.jpg](https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg)

输入：root = [1,null,2,2]

**输出：**[2]

**示例 2：**

输入：root = [0]

**输出：**[0]

**提示：**

- 树中节点的数目在范围 `[1, 104]` 内
- `-105 <= Node.val <= 105`

进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）

#### 解题思路：

为了解决题目「501. 二叉搜索树中的众数」，我们可以利用二叉搜索树的性质和中序遍历。由于二叉搜索树的中序遍历结果是有序的，因此重复的元素在中序遍历中会连续出现。我们可以在中序遍历过程中统计每个元素出现的次数，并更新众数列表。

解题步骤如下：

1. 初始化一些必要的变量：当前节点值的出现次数`currCount`，最大出现次数`maxCount`，以及一个列表`result`来存储众数。
2. 使用中序遍历遍历整个树。对于每个节点，判断它是否与前一个节点值相同。如果是，增加`currCount`；如果不是，将`currCount`重置为1。
3. 比较`currCount`与`maxCount`。如果`currCount`更大，清空`result`，并将当前节点值加入`result`。如果`currCount`等于`maxCount`，将当前节点值加入`result`。
4. 更新`maxCount`为`maxCount`和`currCount`中的较大值。
5. 遍历完成后，返回`result`。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20210204152758889.png)

```python
class Solution:
    def findMode(self, root):
        # 初始化变量
        self.maxCount = 0
        self.currCount = 0
        self.prev = None
        self.result = []

        # 中序遍历函数
        def inorder(node):
            if not node:
                return
            # 遍历左子树
            inorder(node.left)
            # 更新当前节点值出现次数
            if self.prev == node.val:
                self.currCount += 1
            else:
                self.currCount = 1
            # 更新众数列表
            if self.currCount > self.maxCount:
                self.maxCount = self.currCount
                self.result = [node.val]
            elif self.currCount == self.maxCount:
                self.result.append(node.val)
            # 记录当前节点值
            self.prev = node.val
            # 遍历右子树
            inorder(node.right)

        # 对树进行中序遍历
        inorder(root)
        return self.result
```

#### 时空复杂度：

时间复杂度是O(N)，因为需要遍历树中的每个节点。

空间复杂度是O(1)，如果不考虑递归栈的空间消耗。

#### 视频讲解：

[不仅双指针，还有代码技巧可以惊艳到你！ | LeetCode：501.二叉搜索树中的众数 ｜ 501. Find Mode in Binary Search Tree](https://youtu.be/-M2mh_tG2to?si=ZxOZzw86T5wYPLut)

---

### [236. 二叉树的最近公共祖先](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

**示例 1：**

![Image.png](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1

输出：3

解释：节点 `5` 和节点 `1` 的最近公共祖先是节点 `3 。`

**示例 2：**

![Image.png](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4

输出：5

解释：节点 `5` 和节点 `4` 的最近公共祖先是节点 `5 。`因为根据定义最近公共祖先节点可以为节点本身。

**示例 3：**

输入：root = [1,2], p = 1, q = 2

输出：1

**提示：**

- 树中节点数目在范围 `[2, 105]` 内。
- `-109 <= Node.val <= 109`
- 所有 `Node.val` `互不相同` 。
- `p != q`
- `p` 和 `q` 均存在于给定的二叉树中。

#### 解题思路：

我们可以使用递归方法。核心思想是检查当前节点是否为其中一个目标节点（p或q），或者在它的左右子树中是否有目标节点。如果在当前节点的两侧各找到一个目标节点，那么这个节点就是最近的公共祖先。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20220922173502.png)

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20220922173530.png)

解题步骤如下：

1. 如果当前节点为空或等于p或q，返回当前节点。
2. 对当前节点的左右子树递归调用此函数。
3. 如果左子树调用返回非空节点，而右子树调用返回空节点，则表示两个目标节点都在左子树，返回左子树的调用结果。
4. 如果左子树调用返回空节点，而右子树调用返回非空节点，则表示两个目标节点都在右子树，返回右子树的调用结果。
5. 如果左右子树调用都返回非空节点，则当前节点是最近公共祖先，返回当前节点。

```python
class Solution:
    def lowestCommonAncestor(self, root, p, q):
        # 如果到达叶子节点或者找到p或q，返回root
        if not root or root == p or root == q:
            return root

        # 递归查找左右子树
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)

        # 如果左右子树的递归调用都返回非空节点，说明p和q在当前节点的两侧，当前节点即为公共祖先
        if left and right:
            return root

        # 如果左子树为空，则公共祖先在右子树
        if not left:
            return right
        # 如果右子树为空，则公共祖先在左子树
        else:
            return left
```

#### 时空复杂度：

这个方法的时间复杂度是O(N)，其中N是树中的节点数，因为在最坏情况下可能需要遍历整棵树。空间复杂度是O(H)，其中H是树的高度，这是由于递归的栈空间所需。

#### 视频讲解：

[自底向上查找，有点难度！ | LeetCode：236. 二叉树的最近公共祖先没｜ 236. Lowest Common Ancestor of a Binary Tree](https://youtu.be/PHdnfJAUV2M?si=Y16FTDa9F12gihGa)

#### 代码随想录算法训练营第二十二天 | 235. 二叉搜索树的最近公共祖先，701.二叉搜索树中的插入操作，450.删除二叉搜索树中的节点

#### ● day 22 任务以及具体安排：[第六章 二叉树  part08](https://docs.qq.com/doc/DUHplVUp5YnN1bnBL) (1.3)

# 第六章 二叉树part08

今日内容：

●  235. 二叉搜索树的最近公共祖先

●  701.二叉搜索树中的插入操作

●  450.删除二叉搜索树中的节点

## 详细布置

### 235. 二叉搜索树的最近公共祖先

相对于 二叉树的最近公共祖先 本题就简单一些了，因为 可以利用二叉搜索树的特性。

题目链接/文章讲解：[https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html](https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html)

视频讲解：[https://www.bilibili.com/video/BV1Zt4y1F7ww](https://www.bilibili.com/video/BV1Zt4y1F7ww)

### 701.二叉搜索树中的插入操作

本题比想象中的简单，大家可以先自己想一想应该怎么做，然后看视频讲解，就发现 本题为什么比较简单了。

题目链接/文章讲解：[https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html](https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html)

视频讲解：[https://www.bilibili.com/video/BV1Et4y1c78Y](https://www.bilibili.com/video/BV1Et4y1c78Y)

### 450.删除二叉搜索树中的节点

相对于 插入操作，本题就有难度了，涉及到改树的结构

题目链接/文章讲解：[https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html](https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html)

视频讲解：[https://www.bilibili.com/video/BV1tP41177us](https://www.bilibili.com/video/BV1tP41177us)

[Just a moment...](https://chat.openai.com/share/fd396ecd-1d1a-4ea5-b7ea-bc731b9161f2)

---

### [235. 二叉搜索树的最近公共祖先](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

![Image.png](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png)

**示例 1:**

**输入:** root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8

**输出:** 6

**解释:** 节点 `2` 和节点 `8` 的最近公共祖先是 `6。`

**示例 2:**

**输入:** root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4

**输出:** 2

**解释:** 节点 `2` 和节点 `4` 的最近公共祖先是 `2`, 因为根据定义最近公共祖先节点可以为节点本身。

**说明:**

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉搜索树中。

#### 解题思路：

对于这个问题，我们可以利用二叉搜索树（BST）的性质来找到最近的公共祖先。二叉搜索树的性质是：对于树中的任意一个节点，其左子树中所有节点的值都小于该节点的值，而其右子树中所有节点的值都大于该节点的值。这个性质可以帮助我们确定两个节点 p 和 q 相对于当前节点的位置，从而找到它们的最近公共祖先。

解题步骤如下：

1. 从根节点开始遍历树。
2. 如果节点 p 和节点 q 都在右子树上，那么以右孩子为根继续一步步向下遍历。
3. 如果节点 p 和节点 q 都在左子树上，那么以左孩子为根继续一步步向下遍历。
4. 如果条件 2 和条件 3 都不成立，这意味着我们已经找到了节点 p 和 q 的最近公共祖先。

```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        while root:
            # 如果两个节点值都大于当前节点值，说明它们都在右子树中
            if p.val > root.val and q.val > root.val:
                root = root.right
            # 如果两个节点值都小于当前节点值，说明它们都在左子树中
            elif p.val < root.val and q.val < root.val:
                root = root.left
            else:
                # 我们已经找到分叉点，即最近公共祖先
                return root
```

#### 时空复杂度：

时间复杂度：O(H)，其中 H 是树的高度。

平均情况下为 O(logN)，最坏情况下为 O(N)。 空间复杂度：O(1)。

#### 常见错误：

- 不正确地使用二叉搜索树的性质。
- 忽略了题目中说明的所有节点值都是唯一的这一条件。

#### 视频讲解：

[自底向上查找，有点难度！ | LeetCode：236. 二叉树的最近公共祖先没｜ 236. Lowest Common Ancestor of a Binary Tree](https://youtu.be/PHdnfJAUV2M?si=RQ66KR4cj0XJSquY)

---

### [701.二叉搜索树中的插入操作](https://leetcode.com/problems/insert-into-a-binary-search-tree/)

给定二叉搜索树（BST）的根节点 `root` 和要插入树中的值 `value` ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。

**注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。

**示例 1：**

![Image.jpg](https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg)

输入：root = [4,2,7,1,3], val = 5

**输出：**[4,2,7,1,3,5]

解释：另一个满足题目要求可以通过的树是：

![Image.jpg](https://assets.leetcode.com/uploads/2020/10/05/bst.jpg)

**示例 2：**

输入：root = [40,20,60,10,30,50,70], val = 25

**输出：**[40,20,60,10,30,50,70,null,null,25]

**示例 3：**

输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5

**输出：**[4,2,7,1,3,5]

**提示：**

- 树中的节点数将在 `[0, 104]`的范围内。
- `-108 <= Node.val <= 108`
- 所有值 `Node.val` 是 **独一无二** 的。
- `-108 <= val <= 108`
- **保证** `val` 在原始BST中不存在。

#### 解题思路：

1. **开始于根节点**：从根节点开始，将新值与当前节点的值进行比较。
2. **决定方向**：
   - 如果新值小于当前节点的值，向左子树移动。
   - 如果新值大于当前节点的值，向右子树移动。
3. **找到插入位置**：重复步骤2直到找到一个空位，即当前节点的左子节点或右子节点为空，这是新值应该插入的位置。
4. **执行插入**：在找到的位置创建一个新的节点，将新值放在这个新节点中。

```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:
        if not root:
            # 如果根节点为空，直接创建新节点作为根节点
            return TreeNode(val)
    
        if val < root.val:
            # 如果 val 小于当前节点值，处理左子树
            if root.left is None:
                root.left = TreeNode(val)
            else:
                self.insertIntoBST(root.left, val)
        else:
            # 如果 val 大于当前节点值，处理右子树
            if root.right is None:
                root.right = TreeNode(val)
            else:
                self.insertIntoBST(root.right, val)
    
        return root
```

#### 时空复杂度：

时间复杂度：O(H)，其中 H 是树的高度。由于在二叉搜索树中，一个节点的左右子节点都与其有明确的大小关系，因此平均时间复杂度是 O(logN)；最坏情况下，树可能会退化成一个链表，此时时间复杂度为 O(N)。

空间复杂度：O(H)。递归函数的深度决定了所需的空间。平均情况下为 O(logN)，最坏情况下为 O(N)。

#### 常见错误：

- 忽略检查当前节点是否为空，导致空指针异常。
- 在找到插入位置后，未正确创建新节点或未将新节点连接到树上。
- 不处理新值与当前节点值相等的情况（题目中已说明新值与树中任何节点值都不同，但在通常情况下这需要被处理）。

#### 视频讲解：

[原来这么简单？ | LeetCode：701.二叉搜索树中的插入操作 | 701. Insert into a Binary Search Tree](https://youtu.be/SFFT72VKotU?si=okqmubBISXnTtpHc)

---

### [450.删除二叉搜索树中的节点](https://leetcode.com/problems/delete-node-in-a-bst/)

给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

1. 首先找到需要删除的节点；
2. 如果找到了，删除它。

**示例 1:**

![Image.jpg](https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg)

输入：root = [5,3,6,2,4,null,7], key = 3

**输出：**[5,4,6,2,null,null,7]

解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。

一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。

另一个正确答案是 [5,2,6,null,4,null,7]。

![Image.jpg](https://assets.leetcode.com/uploads/2020/09/04/del_node_supp.jpg)

**示例 2:**

**输入:** root = [5,3,6,2,4,null,7], key = 0

**输出:** [5,3,6,2,4,null,7]

**解释:** 二叉树不包含值为 0 的节点

**示例 3:**

**输入:** root = [], key = 0

**输出:** []

**提示:**

- 节点数的范围 `[0, 104]`.
- `-105 <= Node.val <= 105`
- 节点值唯一
- `root` 是合法的二叉搜索树
- `-105 <= key <= 105`

**进阶：** 要求算法时间复杂度为 O(h)，h 为树的高度。

#### 解题思路：

1. **节点为叶子节点**：直接删除该节点。
2. **节点只有一个子节点**：删除该节点，并用其子节点替换。
3. **节点有两个子节点**：找到该节点的中序后继（右子树中的最小节点）或中序前驱（左子树中的最大节点），用它来替换要删除的节点，然后删除中序后继或中序前驱。

```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:
        if not root:
            return None

        # 如果 key 大于当前节点值，去右子树删除
        if key > root.val:
            root.right = self.deleteNode(root.right, key)
        # 如果 key 小于当前节点值，去左子树删除
        elif key < root.val:
            root.left = self.deleteNode(root.left, key)
        else:
            # 当前节点就是要删除的节点
            # 如果当前节点是叶子节点或仅有一个子节点
            if not root.left:
                return root.right
            elif not root.right:
                return root.left
            # 当前节点有两个子节点
            else:
                temp = self.findMin(root.right)
                root.val = temp.val
                root.right = self.deleteNode(root.right, root.val)

        return root

    def findMin(self, node):
        while node.left:
            node = node.left
        return node
```

#### 时空复杂度：

时间复杂度：O(H)，其中 H 是树的高度。平均情况下是 O(logN)，最坏情况下为 O(N)。

空间复杂度：O(H)。递归函数的深度决定了所需的空间。平均情况下为 O(logN)，最坏情况下为 O(N)。

#### 常见错误：

- 不正确处理节点有两个子节点的情况。
- 忘记更新父节点与新替换节点的连接。
- 在找到要删除的节点后，未考虑其可能为叶子节点或有一个子节点的情况。

#### 视频讲解：

[调整二叉树的结构最难！| LeetCode：450.删除二叉搜索树中的节点 | 450. Delete Node in a BST](https://youtu.be/jNZi07dLjhw?si=BKaM4fpDm_WR-3Nx)

#### 代码随想录算法训练营第二十三天 | 669. 修剪二叉搜索树，108.将有序数组转换为二叉搜索树，538.把二叉搜索树转换为累加树

#### ● day 23 任务以及具体安排：[第六章 二叉树part09](https://docs.qq.com/doc/DUFBUQmxpQU1pa29C) (1.4)

# 第六章 二叉树part09

# 今日内容：

●  669. 修剪二叉搜索树

●  108.将有序数组转换为二叉搜索树

●  538.把二叉搜索树转换为累加树

●  总结篇

## 详细布置

### 669. 修剪二叉搜索树

这道题目比较难，比 添加增加和删除节点难的多，建议先看视频理解。

题目链接/文章讲解： [https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html](https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html)

视频讲解： [https://www.bilibili.com/video/BV17P41177ud](https://www.bilibili.com/video/BV17P41177ud)

### 108.将有序数组转换为二叉搜索树

本题就简单一些，可以尝试先自己做做。

[代码随想录](https://programmercarl.com/0108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html)

视频讲解：[https://www.bilibili.com/video/BV1uR4y1X7qL](https://www.bilibili.com/video/BV1uR4y1X7qL)

### 538.把二叉搜索树转换为累加树

本题也不难，在 求二叉搜索树的最小绝对差 和 众数 那两道题目 都讲过了 双指针法，思路是一样的。

[代码随想录](https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html)

视频讲解：[https://www.bilibili.com/video/BV1d44y1f7wP](https://www.bilibili.com/video/BV1d44y1f7wP)

### 总结篇

好了，二叉树大家就这样刷完了，做一个总结吧

[代码随想录](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html)

[ChatGPT](https://chat.openai.com/share/dcb4895d-8fb8-4007-8b8b-42165c1d8320)

---

### [669. 修剪二叉搜索树](https://leetcode.com/problems/trim-a-binary-search-tree/)

给你二叉搜索树的根节点 `root` ，同时给定最小边界`low` 和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。修剪树 **不应该** 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 **唯一的答案** 。

所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。

**示例 1：**

![Image.jpg](https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg)

输入：root = [1,0,2], low = 1, high = 2

**输出：**[1,null,2]

**示例 2：**

![Image.jpg](https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg)

输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3

**输出：**[3,2,null,1]

**提示：**

- 树中节点数在范围 `[1, 104]` 内
- `0 <= Node.val <= 104`
- 树中每个节点的值都是 **唯一** 的
- 题目数据保证输入是一棵有效的二叉搜索树
- `0 <= low <= high <= 104`

#### **解题思路**:

- 如果根节点为空，直接返回空。
- 如果根节点的值小于 `low`，说明左子树上所有的节点都不在范围内，所以递归修剪右子树。
- 如果根节点的值大于 `high`，说明右子树上所有的节点都不在范围内，所以递归修剪左子树。
- 如果根节点的值在 `low` 和 `high` 之间，递归修剪左右子树。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def trimBST(root, low, high):
    if not root:
        return None
    # 如果节点值小于low，则修剪左子树
    if root.val < low:
        return trimBST(root.right, low, high)
    # 如果节点值大于high，则修剪右子树
    if root.val > high:
        return trimBST(root.left, low, high)
    # 节点值在范围内，递归处理子节点
    root.left = trimBST(root.left, low, high)
    root.right = trimBST(root.right, low, high)
    return root
```

**时间复杂度和空间复杂度分析**:

- 时间复杂度是 O(N)，其中 N 是树中的节点数。在最坏情况下，我们可能需要访问树中的每个节点。
- 空间复杂度是 O(N)，主要是因为递归的栈空间。在最坏的情况下，递归的深度可以达到 N。

**常见错误**:

- 没有考虑到递归时根节点的值可能不在范围内。
- 忘记递归调用修剪左右子树。

#### 视频讲解：

[你修剪的方式不对，我来给你纠正一下！| LeetCode：669. 修剪二叉搜索树 | 669. Trim a Binary Search Tree](https://youtu.be/MVBkCWc5D60?si=RK7z9ePH7a-qDIL6)

---

### [108.将有序数组转换为二叉搜索树](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。

**高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

**示例 1：**

![Image.jpg](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

输入：nums = [-10,-3,0,5,9]

**输出：**[0,-3,9,-10,null,5]

**解释：**[0,-10,5,null,-3,null,9] 也将被视为正确答案：

![Image.jpg](https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg)

**示例 2：**

![Image.jpg](https://assets.leetcode.com/uploads/2021/02/18/btree.jpg)

输入：nums = [1,3]

**输出：**[3,1]

**解释：**[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。

**提示：**

- `1 <= nums.length <= 104`
- `-104 <= nums[i] <= 104`
- `nums` 按 **严格递增** 顺序排列

#### 解题思路：

- 使用递归来构建二叉搜索树。
- 选择数组的中间元素作为根节点，这可以保证左右子树的高度尽可能相等。
- 递归地在根节点的左边数组上构建左子树，在右边数组上构建右子树。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def sortedArrayToBST(nums):
    if not nums:
        return None
    mid = len(nums) // 2
    root = TreeNode(nums[mid])
    root.left = sortedArrayToBST(nums[:mid])
    root.right = sortedArrayToBST(nums[mid + 1:])
    return root
```

#### **时间复杂度和空间复杂度分析**:

   - 时间复杂度是 O(N)，其中 N 是数组中的元素数量。每个元素只访问一次。
   - 空间复杂度是 O(log N)，这是由于递归栈的空间。在最坏的情况下，树的高度可以达到 log N。

#### **常见错误**:

   - 忘记处理空数组的情况。
   - 选取中间元素时没有正确处理中间索引的计算。

#### 视频讲解：

[构造平衡二叉搜索树！| LeetCode：108.将有序数组转换为二叉搜索树 ｜ 108. Convert Sorted Array to Binary Search Tree](https://youtu.be/7BHXx2VzwNA?si=QSI4F_NeGc9j76Xv)

---

### [538.把二叉搜索树转换为累加树](https://leetcode.com/problems/convert-bst-to-greater-tree/)

给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

- 节点的左子树仅包含键 **小于** 节点键的节点。
- 节点的右子树仅包含键 **大于** 节点键的节点。
- 左右子树也必须是二叉搜索树。

注意：本题和 1038: [https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/](https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/) 相同

**示例 1：**

![Image.png](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png)

**输入：**[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]

**输出：**[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]

**示例 2：**

输入：root = [0,null,1]

**输出：**[1,null,1]

**示例 3：**

输入：root = [1,0,2]

**输出：**[3,3,2]

**示例 4：**

输入：root = [3,2,4,1]

**输出：**[7,9,4,10]

**提示：**

- 树中的节点数介于 `0` 和 `104` 之间。
- 每个节点的值介于 `-104` 和 `104` 之间。
- 树中的所有值 **互不相同** 。
- 给定的树为二叉搜索树。

#### 解题思路：

- 利用二叉搜索树的特性：右子树的所有节点值都大于根节点，左子树的所有节点值都小于根节点。
- 采用逆中序遍历（右-根-左）的方式遍历树，这样可以保证从最大的节点值开始累加。
- 维护一个累加和变量，在遍历过程中更新每个节点的值，并更新累加和。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def convertBST(root):
    total = 0

    def traverse(node):
        nonlocal total
        if not node:
            return
        traverse(node.right)
        total += node.val
        node.val = total
        traverse(node.left)

    traverse(root)
    return root
```

**时间复杂度和空间复杂度分析**:

   - 时间复杂度是 O(N)，其中 N 是树中的节点数。我们需要遍历树中的每个节点一次。
   - 空间复杂度是 O(N)，这是因为在最坏情况下（即树完全不平衡时），递归的深度可以达到 N。

**常见错误**:

   - 忘记使用逆中序遍历，导致无法正确累加。
   - 没有正确维护累加和变量。

#### 视频讲解：

[普大喜奔！二叉树章节已全部更完啦！| LeetCode：538.把二叉搜索树转换为累加树 ｜ 538. Convert BST to Greater Tree](https://youtu.be/-TtJY8W2pO0?si=fWQSMm-pwPIHv3cn)

---

#### 二叉树总结

## [\#](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80)二叉树的理论基础

- [关于二叉树，你该了解这些！ (opens new window)](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)：二叉树的种类、存储方式、遍历方式、定义方式

## [\#](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F)二叉树的遍历方式

- 深度优先遍历
   - [二叉树：前中后序递归法 (opens new window)](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html)：递归三部曲初次亮相
   - [二叉树：前中后序迭代法（一） (opens new window)](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html)：通过栈模拟递归
   - [二叉树：前中后序迭代法（二）统一风格(opens new window)](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html)
- 广度优先遍历
   - [二叉树的层序遍历 (opens new window)](https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html)：通过队列模拟

## [\#](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7)求二叉树的属性

- [二叉树：是否对称(opens new window)](https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html)
   - 递归：后序，比较的是根节点的左子树与右子树是不是相互翻转
   - 迭代：使用队列/栈将两个节点顺序放入容器中进行比较
- [二叉树：求最大深度(opens new window)](https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html)
   - 递归：后序，求根节点最大高度就是最大深度，通过递归函数的返回值做计算树的高度
   - 迭代：层序遍历
- [二叉树：求最小深度(opens new window)](https://programmercarl.com/0111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html)
   - 递归：后序，求根节点最小高度就是最小深度，注意最小深度的定义
   - 迭代：层序遍历
- [二叉树：求有多少个节点(opens new window)](https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html)
   - 递归：后序，通过递归函数的返回值计算节点数量
   - 迭代：层序遍历
- [二叉树：是否平衡(opens new window)](https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html)
   - 递归：后序，注意后序求高度和前序求深度，递归过程判断高度差
   - 迭代：效率很低，不推荐
- [二叉树：找所有路径(opens new window)](https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html)
   - 递归：前序，方便让父节点指向子节点，涉及回溯处理根节点到叶子的所有路径
   - 迭代：一个栈模拟递归，一个栈来存放对应的遍历路径
- [二叉树：递归中如何隐藏着回溯(opens new window)](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E9%80%92%E5%BD%92%E5%B8%A6%E7%9D%80%E5%9B%9E%E6%BA%AF.html)
   - 详解[二叉树：找所有路径 (opens new window)](https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html)中递归如何隐藏着回溯
- [二叉树：求左叶子之和(opens new window)](https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html)
   - 递归：后序，必须三层约束条件，才能判断是否是左叶子。
   - 迭代：直接模拟后序遍历
- [二叉树：求左下角的值(opens new window)](https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html)
   - 递归：顺序无所谓，优先左孩子搜索，同时找深度最大的叶子节点。
   - 迭代：层序遍历找最后一行最左边
- [二叉树：求路径总和(opens new window)](https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html)
   - 递归：顺序无所谓，递归函数返回值为bool类型是为了搜索一条边，没有返回值是搜索整棵树。
   - 迭代：栈里元素不仅要记录节点指针，还要记录从头结点到该节点的路径数值总和

## [\#](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%9E%84%E9%80%A0)二叉树的修改与构造

- [翻转二叉树(opens new window)](https://programmercarl.com/0226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html)
   - 递归：前序，交换左右孩子
   - 迭代：直接模拟前序遍历
- [构造二叉树(opens new window)](https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html)
   - 递归：前序，重点在于找分割点，分左右区间构造
   - 迭代：比较复杂，意义不大
- [构造最大的二叉树(opens new window)](https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html)
   - 递归：前序，分割点为数组最大值，分左右区间构造
   - 迭代：比较复杂，意义不大
- [合并两个二叉树(opens new window)](https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html)
   - 递归：前序，同时操作两个树的节点，注意合并的规则
   - 迭代：使用队列，类似层序遍历

## [\#](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%B1%9E%E6%80%A7)求二叉搜索树的属性

- [二叉搜索树中的搜索(opens new window)](https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html)
   - 递归：二叉搜索树的递归是有方向的
   - 迭代：因为有方向，所以迭代法很简单
- [是不是二叉搜索树(opens new window)](https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html)
   - 递归：中序，相当于变成了判断一个序列是不是递增的
   - 迭代：模拟中序，逻辑相同
- [求二叉搜索树的最小绝对差(opens new window)](https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html)
   - 递归：中序，双指针操作
   - 迭代：模拟中序，逻辑相同
- [求二叉搜索树的众数(opens new window)](https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html)
   - 递归：中序，清空结果集的技巧，遍历一遍便可求众数集合
   - [二叉搜索树转成累加树(opens new window)](https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html)
   - 递归：中序，双指针操作累加
   - 迭代：模拟中序，逻辑相同

## [\#](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98)二叉树公共祖先问题

- [二叉树的公共祖先问题(opens new window)](https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html)
   - 递归：后序，回溯，找到左子树出现目标值，右子树节点目标值的节点。
   - 迭代：不适合模拟回溯
- [二叉搜索树的公共祖先问题(opens new window)](https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html)
   - 递归：顺序无所谓，如果节点的数值在目标区间就是最近公共祖先
   - 迭代：按序遍历

## [\#](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E4%BF%AE%E6%94%B9%E4%B8%8E%E6%9E%84%E9%80%A0)二叉搜索树的修改与构造

- [二叉搜索树中的插入操作(opens new window)](https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html)
   - 递归：顺序无所谓，通过递归函数返回值添加节点
   - 迭代：按序遍历，需要记录插入父节点，这样才能做插入操作
- [二叉搜索树中的删除操作(opens new window)](https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html)
   - 递归：前序，想清楚删除非叶子节点的情况
   - 迭代：有序遍历，较复杂
- [修剪二叉搜索树(opens new window)](https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html)
   - 递归：前序，通过递归函数返回值删除节点
   - 迭代：有序遍历，较复杂
- [构造二叉搜索树(opens new window)](https://programmercarl.com/0108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html)
   - 递归：前序，数组中间节点分割
   - 迭代：较复杂，通过三个队列来模拟

## [\#](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html#%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93)阶段总结

大家以上题目都做过了，也一定要看如下阶段小结。

**每周小结都会对大家的疑问做统一解答，并且对每周的内容进行拓展和补充，所以一定要看，将细碎知识点一网打尽！**

- [本周小结！（二叉树系列一）(opens new window)](https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20200927%E4%BA%8C%E5%8F%89%E6%A0%91%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html)
- [本周小结！（二叉树系列二）(opens new window)](https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201003%E4%BA%8C%E5%8F%89%E6%A0%91%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html)
- [本周小结！（二叉树系列三）(opens new window)](https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201010%E4%BA%8C%E5%8F%89%E6%A0%91%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html)
- [本周小结！（二叉树系列四）(opens new window)](https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201017%E4%BA%8C%E5%8F%89%E6%A0%91%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html)

## [\#](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93)最后总结

**在二叉树题目选择什么遍历顺序是不少同学头疼的事情，我们做了这么多二叉树的题目了，Carl给大家大体分分类**。

- 涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。
- 求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。
- 求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。

注意在普通二叉树的属性中，我用的是一般为后序，例如单纯求深度就用前序，[二叉树：找所有路径 (opens new window)](https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html)也用了前序，这是为了方便让父节点指向子节点。

所以求普通二叉树的属性还是要具体问题具体分析。

二叉树专题汇聚为一张图：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20211030125421.png)

这个图是 [代码随想录知识星球 (opens new window)](https://programmercarl.com/other/kstar.html)成员：[青 (opens new window)](https://wx.zsxq.com/dweb2/index/footprint/185251215558842)，所画，总结的非常好，分享给大家。

### 第七章：回溯算法

#### 代码随想录算法训练营第二十四天 | 回溯算法理论基础，77.组合

#### ● day 24 任务以及具体安排：[第七章 回溯算法part01](https://docs.qq.com/doc/DUEhsb0pUUm1WT2NP)  (1.5)

# 第七章 回溯算法part01

今日内容：

●  理论基础

●  77. 组合

## 详细布置

### 理论基础

其实在讲解二叉树的时候，就给大家介绍过回溯，这次正式开启回溯算法，大家可以先看视频，对回溯算法有一个整体的了解。

题目链接/文章讲解：[https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)

视频讲解：[https://www.bilibili.com/video/BV1cy4y167mM](https://www.bilibili.com/video/BV1cy4y167mM)

### 77. 组合

对着 在 回溯算法理论基础 给出的 代码模板，来做本题组合问题，大家就会发现 写回溯算法套路。

在回溯算法解决实际问题的过程中，大家会有各种疑问，先看视频介绍，基本可以解决大家的疑惑。

本题关于剪枝操作是大家要理解的重点，因为后面很多回溯算法解决的题目，都是这个剪枝套路。

题目链接/文章讲解：[https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html](https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html)

视频讲解：[https://www.bilibili.com/video/BV1ti4y1L7cv](https://www.bilibili.com/video/BV1ti4y1L7cv)

剪枝操作：[https://www.bilibili.com/video/BV1wi4y157er](https://www.bilibili.com/video/BV1wi4y157er)

[ChatGPT](https://chat.openai.com/share/7c8f7471-05a2-4805-ae54-4d3b723a98ee)

[ChatGPT](https://chat.openai.com/share/394aae5d-101b-411e-933f-296a69890682)

---

#### 回溯算法理论基础

**定义与特点**: 回溯算法是一种通过探索所有可能的候选解来找出所有解的解题策略。其核心是深度优先搜索(DFS)。在搜索过程中，当发现已不满足求解条件时，就“回溯”返回，尝试其它可能的路径。

回溯算法是纯暴力搜索，效率不高。

回溯算法可以用来解决以下问题：

- 组合问题组合（没有顺序）：N个数里面按一定规则找出k个数的集合
- 排列问题（有顺序）：N个数按一定规则全排列，有几种排列方式
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 棋盘问题：N皇后，解数独等等

#### 解决问题的步骤

1. **路径选择**: 定义一个解空间，它包含了问题的候选解。
2. **约束条件**: 设立约束条件，排除那些不满足条件的候选解。
3. **目标判断**: 判断当前的候选解是否满足达到目标的条件。
4. **回溯操作**: 当当前候选解被确认不是有效或者最优解时，将其从解空间中剔除，并退回至上一步，选择另一种可能的解法继续尝试。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png)

回溯法抽象为树形结构后，其遍历过程就是：**for循环横向遍历，递归纵向遍历，回溯不断调整结果集**。

#### 视频讲解：

[带你学透回溯算法（理论篇）| 回溯法精讲！_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1cy4y167mM/?vd_source=e014c4b20d4f37a6e5537cfac5ea2363)

#### 伪代码：

```python
回溯算法(路径, 选择列表):
    if 满足结束条件:
        添加路径到结果集
        return

    for 选择 in 选择列表:
        做选择
        回溯算法(路径, 选择列表)
        撤销选择
```

1. **路径**：记录当前的路径，即你已经做出的选择。
2. **选择列表**：记录你当前可以做的选择。
3. **结束条件**：决定是否到达了函数结束的条件，比如解决了一个问题。

在实际使用时，会根据具体问题来实现上述的伪代码。例如，在解决组合问题时，路径是当前的组合，选择列表是当前可以选择的元素，结束条件是达到了组合的长度要求。

回溯算法的关键在于：在每一次递归调用中，选择列表和路径的状态都是根据当前的选择更新的，并且在递归完成后，需要将它们回溯到上一步的状态，以便进行下一个选择的尝试。

---

### [77.组合](https://leetcode.com/problems/combinations/)

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

**示例 1：**

输入：n = 4, k = 2

**输出：**

[

[2,4],

[3,4],

[2,3],

[1,2],

[1,3],

[1,4],

]

**示例 2：**

输入：n = 1, k = 1

**输出：**[[1]]

**提示：**

- `1 <= n <= 20`
- `1 <= k <= n`

#### 解题思路

**每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围**。

**图中可以发现n相当于树的宽度，k相当于树的深度**。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195242899.png)

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130194335207.png)

1. 使用回溯法解决。
2. 创建一个辅助函数，递归地构建组合。
3. 从 1 到 n 遍历，每次递归时，将当前数字加入组合中。
4. 当组合中的数量达到 `k` 时，将其添加到结果中。
5. 回溯时，从组合中移除最后一个数字，尝试下一个数字。

```python
def combine(n, k):
    # 定义回溯函数
    def backtrack(start, path):
        # 当前组合长度达到 k，添加到结果中
        if len(path) == k:
            result.append(path[:])
            return
        # 从 start 到 n 遍历
        for i in range(start, n + 1):
            path.append(i)  # 将当前数字加入到组合中
            backtrack(i + 1, path)  # 递归调用
            path.pop()  # 回溯，移除最后一个数字

    result = []  # 用于存储所有可能的组合
    backtrack(1, [])  # 从数字 1 开始进行回溯
    return result

# 示例
print(combine(4, 2))
```

#### 时间和空间复杂度

- 时间复杂度：O(C(n, k))，其中 C 是组合数，因为我们需要构造出所有可能的组合。
- 空间复杂度：O(C(n, k))，用于存储所有可能的组合。

#### 视频讲解：

[带你学透回溯算法-组合问题（对应力扣题目：77.组合）| 回溯法精讲！_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1ti4y1L7cv/?spm_id_from=333.788&vd_source=e014c4b20d4f37a6e5537cfac5ea2363)

#### 常见错误和难点

- 忘记回溯时从路径中移除元素。
- 没有正确处理当路径长度等于 `k` 时的情况。
1. **如何确保每一种可能性都被包括在内，并且没有重复？**

   在这个问题中，我们需要从 `[1, n]` 的范围内选择 `k` 个数字的组合。使用 `backtrack(start, path)` 函数进行递归调用时，我们遵循以下规则来确保包含所有可能性且不重复：

   - 我们从 `start` 开始遍历到 `n`。对于每一个数字 `i`，我们把它加入当前组合（`path`），然后递归地调用 `backtrack(i + 1, path)`。
   - 每次递归调用 `backtrack` 时，我们将 `start` 设置为 `i + 1`。这意味着在下一层递归中，我们只会考虑当前数字之后的数字。这样可以防止重复，因为我们不会在组合中再次考虑之前已经使用过的数字。

   例如，如果 `n = 4`，`k = 2`，当我们选定了数字 `2` 后，下一次递归将会从 `3` 开始，而不是从 `1` 重新开始。

2. **为什么递归调用结束后需要回溯移除最后一个数字？**

   在回溯算法中，我们需要在每一层递归后“撤销”或“回溯”之前做出的选择，这样才能进行下一个选择。这是为了确保我们可以探索所有可能的选择路径。

   - 每次我们向 `path` 添加一个数字时，我们实际上是在做一个选择。
   - 当我们达到组合的长度 `k` 或完成了一次遍历后，我们需要回溯，即撤销最后的选择，以便于在同一层级尝试其他的数字。

   举例说明：假设 `n = 4`，`k = 2`，当我们的 `path` 变为 `[1, 2]` 后，这个组合已经达到了长度 `k`。我们将其添加到结果中，然后回溯，移除 `path` 中的 `2`。这样 `path` 变回 `[1]`，然后我们可以尝试 `[1, 3]` 和 `[1, 4]`。

3. #### 在终止条件下，为什么是result.append(path[:])而不是直接result.append(path)？

   在终止条件下使用 `result.append(path[:])` 而不是 `result.append(path)` 是为了避免 Python 中列表引用的问题。这里涉及到 Python 中对象引用和对象复制的概念。

   - 当使用 `result.append(path)` 时，我们实际上是将 `path` 这个列表的引用（而不是列表的内容）添加到 `result` 中。这意味着，当 `path` 在后续的递归调用中被修改时，`result` 中已经添加的那些引用也会随之改变，因为它们都指向同一个列表对象。
   - 相反，当使用 `result.append(path[:])` 时，`path[:]` 创建了 `path` 的一个浅拷贝。这意味着我们将 `path` 当前状态的一个副本（而不是原始引用）添加到 `result` 中。即使之后 `path` 被修改，`result` 中的副本保持不变，因为它们是独立的列表对象。

   举例来说，如果你只是添加引用（`result.append(path)`），那么当你回溯并修改 `path` 时，所有之前添加到 `result` 的组合都会受到影响，导致错误的结果。而通过添加一个副本（`result.append(path[:])`），每一个组合都是独立的，即使后续 `path` 发生变化，之前的组合也不会改变。这就确保了每一个组合都正确地被记录下来。

#### 代码随想录算法训练营第二十五天 | 216.组合总和III，17.电话号码的字母组合

#### ● day 25 任务以及具体安排：[第七章 回溯算法part02](https://docs.qq.com/doc/DUExTYXVzU1BiU2Zl) (1.6)

# 第七章 回溯算法part02

今日内容：

●  216.组合总和III

●  17.电话号码的字母组合

## 详细布置

### 216.组合总和III

如果把 组合问题理解了，本题就容易一些了。

题目链接/文章讲解：[https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html](https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html)

视频讲解：[https://www.bilibili.com/video/BV1wg411873x](https://www.bilibili.com/video/BV1wg411873x)

### 17.电话号码的字母组合

本题大家刚开始做会有点难度，先自己思考20min，没思路就直接看题解。

题目链接/文章讲解：[https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html](https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html)

视频讲解：[https://www.bilibili.com/video/BV1yV4y1V7Ug](https://www.bilibili.com/video/BV1yV4y1V7Ug)

[ChatGPT](https://chat.openai.com/share/8b82623a-dae0-4e98-abcd-b0be02d25117)

---

### [216.组合总和III](https://leetcode.com/problems/combination-sum-iii/)

找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：

- 只使用数字1到9
- 每个数字 **最多使用一次**

返回 *所有可能的有效组合的列表* 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

**示例 1:**

**输入:** ***k*** = 3, ***n*** = 7

**输出:** [[1,2,4]]

**解释:**

1 + 2 + 4 = 7

没有其他符合的组合了。

**示例 2:**

**输入:** ***k*** = 3, ***n*** = 9

**输出:** [[1,2,6], [1,3,5], [2,3,4]]

**解释:** 1 + 2 + 6 = 9

1 + 3 + 5 = 9

2 + 3 + 4 = 9

没有其他符合的组合了。

**示例 3:**

**输入:** k = 4, n = 1

**输出:** []

**解释:** 不存在有效的组合。

在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 > 1，没有有效的组合。

**提示:**

- `2 <= k <= 9`
- `1 <= n <= 60`

**解决思路**：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195717975.png)

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/2020112319580476.png)

- 使用回溯法来构建所有可能的组合。
- 从数字 1 开始，递归地向组合中添加数字，直到组合中的数字个数达到 `k`。
- 在每一步，检查当前组合的和是否等于 `n`，如果是，则将其加入结果中。
- 使用一个辅助函数，来处理递归，这个函数需要跟踪当前的组合、下一个添加的数字以及当前组合的和。

```python
def combinationSum3(k, n):
    def backtrack(start, path, remaining):
        # 如果路径长度等于k，检查总和是否为n
        if len(path) == k:
            if remaining == 0:
                result.append(path[:])
            return
        
        # 从start开始，尝试添加[1,9]范围内的数字
        for i in range(start, 10):
            # 如果剩余值小于当前值，停止尝试
            if remaining - i < 0:
                break
            # 添加当前值到路径
            path.append(i)
            # 递归调用，下一个数字应大于当前数字
            backtrack(i + 1, path, remaining - i)
            # 回溯，移除路径中最后一个数字，尝试下一个数字
            path.pop()

    result = []
    backtrack(1, [], n)
    return result

# 测试代码
print(combinationSum3(3, 7))  # 输出: [[1,2,4]]
print(combinationSum3(3, 9))  # 输出: [[1,2,6], [1,3,5], [2,3,4]]
print(combinationSum3(4, 1))  # 输出: []
```

#### **时间复杂度和空间复杂度**：

   - 时间复杂度：O(9!/(9-k)!)，因为我们从 9 个数字中选择 k 个数字进行组合。
   - 空间复杂度：O(k)，主要用于存储路径。

#### **常见错误**：

   - 没有正确处理组合中数字个数的限制。
   - 没有在递归过程中及时剪枝，导致不必要的计算。

#### 视频讲解：

[和组合问题有啥区别？回溯算法如何剪枝？| LeetCode：216.组合总和III_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1wg411873x/?spm_id_from=333.788&vd_source=e014c4b20d4f37a6e5537cfac5ea2363)

---

### [17.电话号码的字母组合](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![Image.png](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png)

**示例 1：**

输入：digits = "23"

**输出：**["ad","ae","af","bd","be","bf","cd","ce","cf"]

**示例 2：**

输入：digits = ""

**输出：**[]

**示例 3：**

输入：digits = "2"

**输出：**["a","b","c"]

**提示：**

- `0 <= digits.length <= 4`
- `digits[i]` 是范围 `['2', '9']` 的一个数字。

**解决思路**：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123200304469.png)

- 建立一个从数字到字母的映射。
- 使用回溯法来遍历每个数字对应的所有可能字母，并将它们加入到当前的组合中。
- 当遍历完成一个组合时，将其加入结果中。

```python
def letterCombinations(digits):
    if not digits:
        return []

    phoneMap = {
        "2": "abc",
        "3": "def",
        "4": "ghi",
        "5": "jkl",
        "6": "mno",
        "7": "pqrs",
        "8": "tuv",
        "9": "wxyz",
    }

    def backtrack(index, path):
        # 如果路径长度等于输入数字的长度，将路径加入结果
        if len(path) == len(digits):
            combinations.append("".join(path))
            return
        
        # 获取当前数字对应的所有可能字母
        possible_letters = phoneMap[digits[index]]
        for letter in possible_letters:
            # 添加当前字母到路径
            path.append(letter)
            # 递归调用，处理下一个数字
            backtrack(index + 1, path)
            # 回溯，移除路径中的最后一个字母
            path.pop()

    combinations = []
    backtrack(0, [])
    return combinations
```

#### **时间复杂度和空间复杂度**：

- 时间复杂度：O(3^N × 4^M)，其中 N 是映射为 3 个字母的数字个数，M 是映射为 4 个字母的数字个数。这是因为这是回溯过程中的最坏情况。
- 空间复杂度：O(N)，其中 N 是输入数字的长度，主要是递归过程中的栈空间。

#### **常见错误**：

- 没有处理输入为空字符串的情况。
- 在回溯过程中没有正确地添加和移除字母。

#### 视频讲解：

[还得用回溯算法！| LeetCode：17.电话号码的字母组合_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1yV4y1V7Ug/?spm_id_from=333.788&vd_source=e014c4b20d4f37a6e5537cfac5ea2363)

#### 代码随想录算法训练营第二十七天 | 39. 组合总和，40.组合总和II，131.分割回文串

#### ● day 27 任务以及具体安排：[第七章 回溯算法part03](https://docs.qq.com/doc/DUElpbnNUR3hIbXlY) (1.8)

# 第七章 回溯算法part03

●  39. 组合总和

●  40.组合总和II

●  131.分割回文串

## 详细布置

### 39. 组合总和

本题是 集合里元素可以用无数次，那么和组合问题的差别 其实仅在于 startIndex上的控制

题目链接/文章讲解：[https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html](https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html)

视频讲解：[https://www.bilibili.com/video/BV1KT4y1M7HJ](https://www.bilibili.com/video/BV1KT4y1M7HJ)

### 40.组合总和II

本题开始涉及到一个问题了：去重。

注意题目中给我们 集合是有重复元素的，那么求出来的 组合有可能重复，但题目要求不能有重复组合。

题目链接/文章讲解：[https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html](https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html)

视频讲解：[https://www.bilibili.com/video/BV12V4y1V73A](https://www.bilibili.com/video/BV12V4y1V73A)

### 131.分割回文串

本题较难，大家先看视频来理解 分割问题，明天还会有一道分割问题，先打打基础。

[代码随想录](https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html)

视频讲解：[https://www.bilibili.com/video/BV1c54y1e7k6](https://www.bilibili.com/video/BV1c54y1e7k6)

[ChatGPT](https://chat.openai.com/share/e64cc544-c4b5-49c8-a626-cf826dcd403e)

---

### [39. 组合总和](https://leetcode.com/problems/combination-sum/)

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

**示例 1：**

输入：candidates = `[2,3,6,7],` target = `7`

**输出：**[[2,2,3],[7]]

**解释：**

2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。

7 也是一个候选， 7 = 7 。

仅有这两种组合。

**示例 2：**

**输入:** candidates = [2,3,5]`,` target = 8

**输出:** [[2,2,2,2],[2,3,3],[3,5]]

**示例 3：**

**输入:** candidates = `[2],` target = 1

**输出:** []

**提示：**

- `1 <= candidates.length <= 30`
- `2 <= candidates[i] <= 40`
- `candidates` 的所有元素 **互不相同**
- `1 <= target <= 40`

#### 解题思路：

- 使用回溯算法来遍历所有可能的组合。
- 创建一个临时列表来存储当前的组合。
- 递归地尝试每个数字，每次递归时，减去当前数字的值从 `target`。
- 如果 `target` 减到0，将当前组合添加到结果中。
- 如果 `target` 小于0或者没有数字可以选择了，则回溯。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201223170730367.png)

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201223170809182.png)

```python
def combinationSum(candidates, target):
    def backtrack(start, target, path):
        # 如果目标数降为0，说明找到了一个有效的组合
        if target == 0:
            result.append(path.copy())
            return
        # 如果目标数小于0，说明这条路径不可能构成有效组合，回溯
        if target < 0:
            return
        # 从start开始遍历candidates中的每个数字
        for i in range(start, len(candidates)):
            # 将当前数字加入到当前路径
            path.append(candidates[i])
            # 递归调用，注意新的target值是减去当前数字的值
            backtrack(i, target - candidates[i], path)
            # 回溯，将当前数字从路径中移除，尝试下一个数字
            path.pop()

    result = []
    backtrack(0, target, [])
    return result

# 示例
candidates = [2, 3, 6, 7]
target = 7
print(combinationSum(candidates, target))
```

**时间和空间复杂度分析**:

- 时间复杂度: O(N^target) 其中 N 是 `candidates` 的长度。在最坏的情况下，我们可能要遍历到每个组合。
- 空间复杂度: O(target)，这主要是因为递归的深度最多为 `target`。

#### 视频讲解：

[带你学透回溯算法-组合总和（对应「leetcode」力扣题目：39.组合总和）| 回溯法精讲！_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1KT4y1M7HJ/?spm_id_from=333.788&vd_source=e014c4b20d4f37a6e5537cfac5ea2363)

**常见错误或难点**:

- 递归时不减少 `target` 值。
- 忘记在找到有效组合时拷贝 `path`。
- 为什么最后使用回溯算法不能直接用result = []
        backtrack(0, target, result)？
- 在这个算法中，`result` 用于存储所有有效的组合，而 `path` 用于在递归过程中构建当前正在考虑的组合。
- 如果直接传递 `result` 作为 `path` 参数，那么在递归过程中，所有的部分组合和最终组合都会被直接添加到 `result` 中，这样就无法区分哪些是完整的组合（即和为 `target` 的组合），哪些只是部分组合。
- 因此，我们需要一个单独的 `path` 变量来构建每一个可能的组合，一旦找到一个有效的组合（和为 `target`），我们就把它添加到 `result` 中。

- 这个算法是如何处理同一个数字可以被无限制重复选取的情况？
- 在 `backtrack` 函数中，每次递归调用时，我们传递的起始索引 `start` 是不变的。这意味着在每次递归中，都可以再次选择当前正在处理的数字。
- 比如，如果 `candidates = [2, 3, 6, 7]`，并且当前选择了数字 `2`，在下一层递归中，我们依然可以选择数字 `2`，因为 `start` 参数没有变化。
- 这种方法允许同一个数字被多次选取。只有当我们移动到数组的下一个元素时（即 `i` 增加时），我们才会考虑不同的数字。
- 如果不允许重复选择同一个数字，我们会在递归调用中使用 `i + 1` 作为新的起始索引，这样每次递归都会移动到下一个数字。

- 当目标值小于0，路径不可能构成有效组合时，直接return不需要清空当前构建的path吗？
- 在递归过程中，每次我们递归调用 `backtrack` 时，都是在尝试添加一个新的元素到 `path`。
- 如果发现目标值变为负数，这意味着当前 `path` 加上新尝试的元素无法构成有效组合，我们需要撤销这次添加操作。这通过递归返回到上一层，并执行 `path.pop()` 来实现，即移除最后添加的元素。
- 由于这个撤销操作是在每次递归返回时发生的，所以不需要在目标值小于0时单独清空 `path`。

- 这个 `return` 会返回到什么地方？

- 当执行 `return` 时，程序会退出当前的递归调用，返回到调用这个递归函数的地方。在我们的代码中，这意味着返回到上一次 `backtrack` 的调用处。
- 由于我们是在一个循环内部调用 `backtrack`（遍历 `candidates`），`return` 将会结束当前的递归调用，并继续执行循环中的下一个迭代（尝试下一个候选数字）或者返回到更上一层的递归调用。
- 这个 `return` 并不会结束整个程序的执行。它只是结束当前的递归分支，递归过程会继续探索其他可能的分支。

---

### [40.组合总和II](https://leetcode.com/problems/combination-sum-ii/)

给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用 **一次** 。

注意：解集不能包含重复的组合。

**示例 1:**

**输入:** candidates = `[10,1,2,7,6,1,5]`, target = `8`,

**输出:**

[

[1,1,6],

[1,2,5],

[1,7],

[2,6]

]

**示例 2:**

**输入:** candidates = [2,5,2,1,2], target = 5,

**输出:**

[

[1,2,2],

[5]

]

**提示:**

- `1 <= candidates.length <= 100`
- `1 <= candidates[i] <= 50`
- `1 <= target <= 30`

#### 解题思路：

- 首先对数组进行排序，以便于跳过重复元素。
- 使用回溯算法，类似之前的方法，但需要注意每次递归时跳过相同的元素。
- 每次递归调用时，都从上一个选择之后的下一个元素开始，以避免重复。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000918.png)

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000954.png)

```python
def combinationSum2(candidates, target):
    def backtrack(start, target, path):
        if target == 0:
            result.append(path.copy())
            return
        for i in range(start, len(candidates)):
            # 跳过重复元素
            if i > start and candidates[i] == candidates[i - 1]:
                continue
            # 如果当前元素已经大于target，后续不可能构成有效组合
            if candidates[i] > target:
                break
            path.append(candidates[i])
            # 每个数字只能使用一次，下一次递归从i+1开始
            backtrack(i + 1, target - candidates[i], path)
            path.pop()

    candidates.sort()
    result = []
    backtrack(0, target, [])
    return result

# 示例
candidates = [10, 1, 2, 7, 6, 1, 5]
target = 8
print(combinationSum2(candidates, target))
```

**时间和空间复杂度分析**:

- 时间复杂度: O(2^N * N)，其中 N 是 `candidates` 的长度。排序需要 O(NlogN) 时间，回溯过程中每个元素有选和不选两种情况，所以是 O(2^N)，每次添加解集需要 O(N) 时间。
- 空间复杂度: O(N)，主要是递归栈空间和临时列表 `path` 的空间。

#### 视频讲解：

[回溯算法中的去重，树层去重树枝去重，你弄清楚了没？| LeetCode:40.组合总和II_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV12V4y1V73A/?spm_id_from=333.788&vd_source=e014c4b20d4f37a6e5537cfac5ea2363)

**常见错误或难点**:

- 忘记对数组排序，导致无法有效跳过重复元素。
- 在递归时没有正确处理每个元素只能使用一次的限制。

---

### [131.分割回文串](This certificate recognizes you have completed the Financial Literacy Life Simulation covering banking, budgeting, credit, debt, insurance, investing and more.)

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串。

**示例 1：**

输入：s = "aab"

**输出：**[["a","a","b"],["aa","b"]]

**示例 2：**

输入：s = "a"

**输出：**[["a"]]

**提示：**

- `1 <= s.length <= 16`
- `s` 仅由小写英文字母组成

#### 解题思路：

- 使用回溯法遍历所有可能的分割方式。
- 对于字符串的每个位置，尝试所有可能的分割点。
- 在每一步中，检查当前选择的子串是否是回文串。
- 如果是回文串，则递归地继续分割剩余的字符串。
- 一旦到达字符串的末尾，将当前的分割方案添加到结果中。

![Image.jpg](https://code-thinking.cdn.bcebos.com/pics/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg)

```python
def partition(s):
    def isPalindrome(sub):
        # 检查子串是否为回文串
        return sub == sub[::-1]

    def backtrack(start, path):
        # 如果已经处理完整个字符串，则添加到结果中
        if start >= len(s):
            result.append(path.copy())
            return
        # 尝试从start位置开始的所有可能的分割点
        for end in range(start + 1, len(s) + 1):
            # 如果当前子串是回文串，则递归处理剩余的字符串
            if isPalindrome(s[start:end]):
                path.append(s[start:end])
                backtrack(end, path)
                path.pop()  # 回溯，撤销上一步的选择

    result = []
    backtrack(0, [])
    return result

# 示例
s = "aab"
print(partition(s))
```

**时间和空间复杂度分析**:

- 时间复杂度: O(N * 2^N)，其中 N 是字符串 `s` 的长度。对于每个子串，我们需要 O(N) 时间来检查是否为回文串，并且有 2^N 种分割方式。
- 空间复杂度: O(N)，这是因为递归栈空间和临时路径 `path` 的空间。

#### 视频讲解：

[带你学透回溯算法-分割回文串（对应力扣题目：131.分割回文串）| 回溯法精讲！_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1c54y1e7k6/?spm_id_from=333.788&vd_source=e014c4b20d4f37a6e5537cfac5ea2363)

**常见错误或难点**:

- 在检查回文串时效率低下。可以通过动态规划预处理来优化回文串的检查。
- 没有正确处理递归的结束条件。
- start和end在backtrack里是指代字符串的首位位置吗？如果是的话for end in range(start + 1, len(s) + 1):下面的东西不是只移动了end？你是如何更新start的位置的？

在 `backtrack` 函数中，`start` 和 `end` 确实代表了字符串中的位置，其中 `start` 指向当前考虑的子串的起始位置，而 `end` 用于尝试不同的结束位置。您的理解是正确的，`for` 循环确实只是移动 `end` 的位置。`start` 的位置是通过递归调用 `backtrack` 函数时更新的。

具体来说，当我们在 `for` 循环中找到一个回文子串时（即 `s[start:end]` 是一个回文串），我们通过递归调用 `backtrack(end, path)` 来处理剩下的字符串。在这个递归调用中，`end` 的值成为新的 `start` 值。这样，每次递归都是在处理字符串的一个不同部分，从而逐步推进 `start` 的位置。

这是一个典型的回溯算法的应用，通过递归来遍历所有可能的选择，并在每一步中更新起始位置来探索不同的子串。当回溯到某一层时，会继续移动 `end` 来尝试其他可能的子串，这样就可以探索到字符串的所有可能分割方式。

让我们以字符串 `s = "aab"` 为例，来详细说明这个回溯算法是如何工作的：

1. **初始状态**:
   - `start = 0`，意味着我们从字符串的第一个字符开始。
   - 结果列表 `result = []`，用于存储所有的分割方案。
2. **第一层递归**:
   - 在这一层，我们尝试所有以 `s[0]` 开始的子串：
      - 尝试子串 `s[0:1] = "a"`，它是回文串，所以我们把 `"a"` 添加到当前路径，并递归调用 `backtrack(1, ["a"])`。
      - 在这个递归调用中，`start = 1`，我们将处理字符串 `"ab"`。
3. **第二层递归**:
   - 现在我们处理字符串 `"ab"`，起始位置为 `1`：
      - 尝试子串 `s[1:2] = "a"`，同样是回文串，我们添加 `"a"` 到路径，得到 `["a", "a"]`，然后递归调用 `backtrack(2, ["a", "a"])`。
      - 在这个递归调用中，`start = 2`，我们将处理字符串 `"b"`。
4. **第三层递归**:
   - 处理字符串 `"b"`，起始位置为 `2`：
      - 尝试子串 `s[2:3] = "b"`，它是回文串，我们添加 `"b"` 到路径，得到 `["a", "a", "b"]`，然后递归调用 `backtrack(3, ["a", "a", "b"])`。
      - 在这个递归调用中，`start = 3`，超出了字符串长度，表示找到了一个完整的分割方案。我们把 `["a", "a", "b"]` 添加到结果中。
5. **回溯到第二层**:
   - 我们回到处理字符串 `"ab"` 的递归调用，尝试下一个子串 `s[1:3] = "ab"`，这不是回文串，所以不做任何操作，继续循环。
   - 循环结束，回溯到第一层。
6. **回溯到第一层**:
   - 继续第一层的循环，尝试子串 `s[0:2] = "aa"`，这是回文串，我们添加 `"aa"` 到路径，然后递归处理剩下的 `"b"`。
7. **再次进入第二层递归**:
   - 现在路径是 `["aa"]`，我们递归处理字符串 `"b"`，和前面类似，最终找到另一个分割方案 `["aa", "b"]`。
8. **最终结果**:
   - 完成所有递归后，我们得到所有分割方案：`[["a", "a", "b"], ["aa", "b"]]`。

通过这个例子，你可以看到算法是如何逐步深入每个可能的分割点，并通过回溯探索所有可能的分割方案的。在每个分割点，算法都检查当前的子串是否为回文串，如果是，就继续递归地处理剩下的字符串。通过这种方式，算法能够找到所有可能的将字符串分割成回文子串的方案。

#### 代码随想录算法训练营第二十八天 | 93.复原IP地址，78.子集，90.子集II

#### ● day 28 任务以及具体安排：[28 第七章 回溯算法 part04](https://docs.qq.com/doc/DUG1yVHdlWEdNYlhZ) (1.9)

# 28 第七章 回溯算法

●  93.复原IP地址

●  78.子集

●  90.子集II

## 详细布置

### 93.复原IP地址

本期本来是很有难度的，不过 大家做完 分割回文串 之后，本题就容易很多了

题目链接/文章讲解：[https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html](https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html)

视频讲解：[https://www.bilibili.com/video/BV1XP4y1U73i/](https://www.bilibili.com/video/BV1XP4y1U73i/)

### 78.子集

子集问题，就是收集树形结构中，每一个节点的结果。 整体代码其实和 回溯模板都是差不多的。

题目链接/文章讲解：[https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html](https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html)

视频讲解：[https://www.bilibili.com/video/BV1U84y1q7Ci](https://www.bilibili.com/video/BV1U84y1q7Ci)

### 90.子集II

大家之前做了 40.组合总和II 和 78.子集 ，本题就是这两道题目的结合，建议自己独立做一做，本题涉及的知识，之前都讲过，没有新内容。

题目链接/文章讲解：[https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html](https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html)

视频讲解：[https://www.bilibili.com/video/BV1vm4y1F71J](https://www.bilibili.com/video/BV1vm4y1F71J)

#### 回溯算法中的剪枝操作

### 回溯算法中的剪枝

回溯算法是一种通过探索所有可能的候选解来找出所有解决方案的算法。如果候选解被证明不是一个有效的解或者不可能产生一个有效的解，这个候选解就会被丢弃，这个过程称为“剪枝”。

在回溯算法中，剪枝是非常重要的，因为它可以帮助减少搜索空间，避免不必要的计算，特别是在解空间非常大的时候。

### 举例说明

#### 例子 1：78. 子集

这道题中，并没有显式的剪枝操作，因为我们需要遍历整个解空间。所有可能的子集都是候选解，所以不需要剪枝。

#### 例子 2：90. 子集 II

这个问题需要剪枝，因为数组中含有重复元素。如果不进行剪枝，就会产生重复的子集。我们在代码中使用了如下的剪枝逻辑：

```python
if i > start and nums[i] == nums[i - 1]:
    continue
```

这里的剪枝逻辑是：当我们遇到一个和前一个元素相同的元素时，我们会跳过这个元素。这样做是因为所有包含这个元素的子集已经在处理前一个元素时被考虑过了，再次考虑会产生重复。

#### 例子 3：93. 复原 IP 地址

在这个问题中，剪枝发生在确保每段 IP 地址的合法性上。如果当前段不合法（例如长度大于 3，或者值大于 255），我们就停止进一步的搜索。这里是相关的剪枝代码：

```python
if length > 3 or int(part) > 255:
    continue
```

这个剪枝步骤是必要的，因为它避免了生成无效的 IP 地址。

### 总结

在回溯算法中，剪枝是一个优化技巧，它通过排除那些不可能产生有效解的路径来减少不必要的搜索，从而提高算法的效率。每个问题可能需要根据其特定的需求和条件来设计合适的剪枝策略。

[ChatGPT](https://chat.openai.com/share/4510e902-9cc7-4ad5-8096-f20892e1e1a4)

---

### [93.复原IP地址](https://leetcode.com/problems/restore-ip-addresses/)

**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。

- 例如：`"0.1.2.201"` 和 `"192.168.1.1"` 是 **有效** IP 地址，但是 `"0.011.255.245"`、`"192.168.1.312"` 和 `"192.168@1.1"` 是 **无效** IP 地址。

给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。

**示例 1：**

输入：s = "25525511135"

**输出：**["255.255.11.135","255.255.111.35"]

**示例 2：**

输入：s = "0000"

**输出：**["0.0.0.0"]

**示例 3：**

输入：s = "101023"

**输出：**["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]

**提示：**

- `1 <= s.length <= 20`
- `s` 仅由数字组成

#### 解题思路：

1. **定义一个递归函数**：该函数负责将字符串分割成 IP 地址的四个部分。它需要以下参数：
   - 原始字符串 `s`。
   - 当前段的索引（0-3）。
   - 当前生成的 IP 地址列表。
   - 已经使用的字符串长度。
2. **递归终止条件**：如果当前段索引为 4（即已经分割出四部分），且已经使用的字符串长度等于 `s` 的长度，则将当前生成的 IP 地址添加到结果中。
3. **遍历可能的段长**：对于每一段，长度可以是 1 到 3 的数字。需要遍历这些可能性，并检查它们是否构成了有效的段。
4. **有效性检查**：
   - 段的值必须在 0 到 255 之间。
   - 如果段的长度大于 1，则它的第一个字符不能是 '0'。
5. **回溯**：如果当前段有效，递归地调用函数，为下一段寻找可能的字符串。
6. **返回结果**：将所有有效的 IP 地址返回。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123203735933.png)

```python
def restoreIpAddresses(s):
    def backtrack(seg, seg_start):
        # 如果是最后一个段且字符串已经被全部使用
        if seg == 4 and seg_start == len(s):
            res.append('.'.join(curr_ip))
            return
        # 如果不是最后一个段但字符串已经被全部使用
        if seg == 4 or seg_start == len(s):
            return

        # 遍历每个段的长度，1 到 3
        for length in range(1, 4):
            # 检查段的长度是否超出字符串的剩余部分
            if seg_start + length > len(s):
                return
            # 检查是否有前导 0
            if length != 1 and s[seg_start] == '0':
                return
            # 取出当前段
            part = s[seg_start:seg_start + length]
            # 检查当前段是否有效
            if int(part) <= 255:
                curr_ip.append(part)
                backtrack(seg + 1, seg_start + length)
                curr_ip.pop()  # 回溯

    res = []
    curr_ip = []
    backtrack(0, 0)
    return res

# 测试
print(restoreIpAddresses("25525511135"))
print(restoreIpAddresses("0000"))
print(restoreIpAddresses("101023"))
```

**时间复杂度**：O(1)，因为输入长度有限（最大 20），所以时间复杂度是常数级的。

**空间复杂度**：O(1)，虽然使用了递归，但由于输入长度的限制，递归深度和使用的额外空间都是有界的。

#### 视频讲解：

[回溯算法如何分割字符串并判断是合法IP？| LeetCode：93.复原IP地址_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1XP4y1U73i/?vd_source=e014c4b20d4f37a6e5537cfac5ea2363)

**常见错误**：

- 忘记检查前导 0。
- 在递归时未正确处理当前段的长度和索引。
- 未正确实现递归终止条件。

---

### [78.子集](https://leetcode.com/problems/subsets/)

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

**示例 1：**

输入：nums = [1,2,3]

**输出：**[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

**示例 2：**

输入：nums = [0]

**输出：**[[],[0]]

**提示：**

- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有元素 **互不相同**

#### 解题思路：

1. **初始化**：创建一个列表 `res` 来存储所有子集。
2. **定义回溯函数**：创建一个辅助函数 `backtrack(start, path)`，其中 `start` 是当前选择的起始位置，`path` 是当前构建的子集。
   - 遍历 `nums`，从 `start` 开始。
   - 在每次迭代中，将当前数字添加到 `path` 中。
   - 调用 `backtrack`，将 `start` 设置为下一个位置，这样每个数字只会被访问一次。
   - 在回溯之前，将当前 `path` 添加到结果集 `res` 中。
   - 回溯：从 `path` 中移除最后一个元素。
3. **调用回溯函数**：从位置 0 开始调用 `backtrack(0, [])`。
4. **返回结果**：返回列表 `res`，它包含了所有子集。

![Image.png](https://code-thinking.cdn.bcebos.com/pics/78.%E5%AD%90%E9%9B%86.png)

```python
def subsets(nums):
    res = []
    
    def backtrack(start, path):
        res.append(path[:])  # 添加当前子集到结果列表
        for i in range(start, len(nums)):
            path.append(nums[i])  # 添加当前元素
            backtrack(i + 1, path)  # 递归调用，注意更新起始位置
            path.pop()  # 回溯，移除最后一个元素

    backtrack(0, [])
    return res

# 测试
print(subsets([1, 2, 3]))
print(subsets([0]))
```

**时间复杂度**：O(N * 2^N)，其中 N 是数组 `nums` 的长度。对于每个元素，我们可以选择包含它或不包含它（两种情况），因此总共有 2^N 种子集。对于每个子集，我们需要 O(N) 的时间来复制到结果列表中。

**空间复杂度**：O(N)，主要为递归栈空间。

#### 视频讲解：

[回溯算法解决子集问题，树上节点都是目标集和！ | LeetCode：78.子集_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1U84y1q7Ci/?vd_source=e014c4b20d4f37a6e5537cfac5ea2363)

**常见错误**：

- 忘记在递归之前复制当前路径（`path[:]`）。
- 错误的回溯逻辑，忘记在递归后从路径中移除当前元素。
- 不正确地处理起始位置，导致生成重复的子集。

---

### [90.子集II](https://leetcode.com/problems/subsets-ii/)

给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。

**示例 1：**

输入：nums = [1,2,2]

**输出：**[[],[1],[1,2],[1,2,2],[2],[2,2]]

**示例 2：**

输入：nums = [0]

**输出：**[[],[0]]

**提示：**

- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`

#### 解题思路：

1. **排序**：首先对数组 `nums` 进行排序。这样，相同的数字就会被放在一起，方便我们在后续步骤中进行剪枝。
2. **初始化**：创建一个列表 `res` 来存储所有子集。
3. **定义回溯函数**：创建一个辅助函数 `backtrack(start, path)`，其中 `start` 是当前选择的起始位置，`path` 是当前构建的子集。
   - 遍历 `nums`，从 `start` 开始。
   - 使用剪枝条件：如果当前数字与前一个数字相同，且前一个数字未被选择，则跳过当前数字。
   - 在每次迭代中，将当前数字添加到 `path` 中。
   - 调用 `backtrack`，将 `start` 设置为下一个位置。
   - 在回溯之前，将当前 `path` 添加到结果集 `res` 中。
   - 回溯：从 `path` 中移除最后一个元素。
4. **调用回溯函数**：从位置 0 开始调用 `backtrack(0, [])`。
5. **返回结果**：返回列表 `res`，它包含了所有子集。

```python
def subsetsWithDup(nums):
    res = []
    nums.sort()  # 对数组进行排序

    def backtrack(start, path):
        res.append(path[:])  # 添加当前子集到结果列表
        for i in range(start, len(nums)):
            # 剪枝：跳过重复元素
            if i > start and nums[i] == nums[i - 1]:
                continue
            path.append(nums[i])  # 添加当前元素
            backtrack(i + 1, path)  # 递归调用
            path.pop()  # 回溯

    backtrack(0, [])
    return res

# 测试
print(subsetsWithDup([1, 2, 2]))
print(subsetsWithDup([0]))
```

**时间复杂度**：O(N * 2^N)，其中 N 是数组 `nums` 的长度。生成子集的总数与排序的时间复杂度相同。

**空间复杂度**：O(N)，主要为递归栈空间和排序的空间。

#### 视频讲解：

[回溯算法解决子集问题，如何去重？| LeetCode：90.子集II_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1vm4y1F71J/?vd_source=e014c4b20d4f37a6e5537cfac5ea2363)

**常见错误**：

- 忘记排序，这将导致无法有效地跳过重复元素。
- 在处理重复元素时逻辑不正确。正确的逻辑是检查当前元素是否与前一个元素相同，且前一个元素未被选择。

#### 代码随想录算法训练营第二十九天 | 491.递增子序列，46.全排列，47.全排列 II

#### ● day 29 任务以及具体安排：[第七章 回溯算法part05](https://docs.qq.com/doc/DUHZYbWhwSHRCRmp3) (1.10)

# 第七章 回溯算法part05

* 491.递增子序列

* 46.全排列

* 47.全排列 II

# 详细布置

## 491.递增子序列

本题和大家刚做过的 90.子集II 非常像，但又很不一样，很容易掉坑里。

[代码随想录](https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html)

视频讲解：[https://www.bilibili.com/video/BV1EG4y1h78v](https://www.bilibili.com/video/BV1EG4y1h78v)

## 46.全排列

本题重点感受一下，排列问题 与 组合问题，组合总和，子集问题的区别。 为什么排列问题不用 startIndex

[代码随想录](https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html)

视频讲解：[https://www.bilibili.com/video/BV19v4y1S79W](https://www.bilibili.com/video/BV19v4y1S79W)

## 47.全排列 II

本题 就是我们讲过的 40.组合总和II 去重逻辑 和 46.全排列 的结合，可以先自己做一下，然后重点看一下 文章中 我讲的拓展内容。 used[i - 1] == true 也行，used[i - 1] == false 也行

[代码随想录](https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html)

视频讲解：[https://www.bilibili.com/video/BV1R84y1i7Tm](https://www.bilibili.com/video/BV1R84y1i7Tm)

[ChatGPT](https://chat.openai.com/share/0d08cdde-2aea-4710-9ccd-ee3440001746)

---

### [491.递增子序列](https://leetcode.com/problems/non-decreasing-subsequences/)

给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

**示例 1：**

输入：nums = [4,6,7,7]

**输出：**[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]

**示例 2：**

输入：nums = [4,4,3,2,1]

**输出：**[[4,4]]

**提示：**

- `1 <= nums.length <= 15`
- `-100 <= nums[i] <= 100`

#### 解题思路：

- 使用回溯法遍历所有可能的子序列。
- 对于每个数字，有两种选择：要么将其加入当前子序列，要么不加入。
- 当选择加入时，必须保证子序列的递增性。
- 为避免重复子序列，同一层级的相同元素只能被选择一次。
- 当子序列长度大于等于2时，可以将其加入结果集。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124200229824.png)

```python
def findSubsequences(nums):
    res = []  # 存储所有合法的递增子序列

    def backtrack(start, path):
        # 当前子序列长度大于1时，添加到结果中
        if len(path) > 1:
            res.append(path[:])

        # 如果已遍历完所有元素，结束递归
        if start == len(nums):
            return

        used = set()  # 用于同一层级去重
        for i in range(start, len(nums)):
            # 检查是否可以将 nums[i] 加入到当前子序列
            # 条件：1. 当前子序列为空或 nums[i] 大于等于子序列最后一个元素
            #      2. nums[i] 在当前层级尚未使用过
            if (not path or nums[i] >= path[-1]) and nums[i] not in used:
                used.add(nums[i])  # 标记 nums[i] 已使用
                path.append(nums[i])  # 加入当前元素到子序列
                backtrack(i + 1, path)  # 递归调用，继续寻找下一个元素
                path.pop()  # 回溯，移除子序列最后一个元素

    backtrack(0, [])  # 从索引 0 开始回溯搜索
    return res

# 测试代码
nums = [4, 6, 7, 7]
print(findSubsequences(nums))
```

**时间和空间复杂度分析**：

- 时间复杂度：O(2^N)，其中 N 是数组的长度。在最坏的情况下，我们需要遍历数组的所有子序列。
- 空间复杂度：O(N)，主要用于递归栈空间。

**常见错误和难点**：

- 忘记在同一层级内去重。
我不太理解使用used去重的目的？去重难道不是去除重复的path，但不排斥重复的元素吗？比如以【4， 6， 7， 7】为例，如果第一个7已经在used里面了，那么第二个7又怎么加进当前的path？这不符合if中的第二个条件：nums[i] 在当前层级尚未使用过？

`used` 集合在这个回溯算法中的作用是防止在同一层级中重复选择相同的元素，从而生成重复的子序列。这里的关键是理解“层级”这个概念在回溯算法中的含义。

在本题的回溯算法中，每一层代表选择子序列中的一个元素的决策点。当我们在同一层级中循环时，`used` 集合确保我们不会选择在这个特定的层级中已经考虑过的元素。

考虑数组 `[4, 6, 7, 7]`：

1. 当我们考虑以 `4` 开始的子序列时，后面的元素可以是 `[6, 7, 7]`。在这一层，我们不希望重复选择 `7`，因为这会导致重复的子序列，比如 `[4, 7]` 会被重复添加两次。但这并不意味着在另一个决策点（例如在以 `6` 开始的子序列中），我们不能再次选择 `7`。
2. 当我们在以 `6` 开始的子序列中考虑后续元素 `[7, 7]` 时，`used` 集合会被重置（因为我们进入了一个新的层级）。在这个新的层级中，我们同样希望避免选择重复的 `7`。

这样，`used` 集合帮助我们避免了在同一层级中的重复选择，同时允许在不同层级中选择相同的元素。每次递归调用 `backtrack` 时，都会创建一个新的 `used` 集合，因此只会影响当前层级的选择，而不会影响其他层级。

这种方式确保了每个子序列都是独特的，即使原始数组中含有重复的元素。

- 未正确处理子序列的递增性质。

---

### [46.全排列](https://leetcode.com/problems/permutations/description/)

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

**示例 1：**

输入：nums = [1,2,3]

**输出：**[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

**示例 2：**

输入：nums = [0,1]

**输出：**[[0,1],[1,0]]

**示例 3：**

输入：nums = [1]

**输出：**[[1]]

**提示：**

- `1 <= nums.length <= 6`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有整数 **互不相同**

#### 解题思路：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20211027181706.png)

1. **初始化**：创建一个结果列表 `res` 来存储所有可能的全排列。
2. **定义回溯函数**：创建一个辅助函数 `backtrack`，它接受当前的排列 `path` 和剩余的数字 `remaining`。`path` 存储当前构建的排列，而 `remaining` 存储尚未使用的数字。
3. **遍历和选择**：在每次调用 `backtrack` 时，遍历 `remaining` 中的每个数字，将其添加到 `path`，然后从 `remaining` 中移除这个数字，并递归调用 `backtrack`。
4. **终止条件**：当 `remaining` 为空时，表示已经形成了一个完整的排列，将其添加到 `res`。
5. **回溯**：在每次递归返回后，撤销上一步的选择，以便进行下一次的选择。

```python
def permute(nums):
    # 初始化结果列表
    res = []
    # 定义一个辅助函数，参数是当前排列path和剩余数字remaining
    def backtrack(path, remaining):
        if not remaining:
            res.append(path[:])
            return
        for i in range(len(remaining)):
            # 选择当前数字
            path.append(remaining[i])
            # 回溯，继续填充剩下的数字
            backtrack(path, remaining[:i] + remaining[i+1:])
            # 撤销选择
            path.pop()

    backtrack([], nums)
    return res

# 测试代码
print(permute([1, 2, 3]))
print(permute([0, 1]))
print(permute([1]))
```

#### 时间复杂度

- 对于一个长度为 `N` 的数组，全排列的数量是 `N!`（阶乘），因为第一个位置有 `N` 种选择，第二个位置有 `N-1` 种选择，以此类推。
- 因此，这个算法的时间复杂度是 `O(N!)`。

#### 空间复杂度

- 空间复杂度主要取决于递归调用的深度，最大深度为 `N`，因此递归栈的空间复杂度为 `O(N)`。
- 此外，还有存储结果的列表，其空间复杂度也为 `O(N!)`，因为需要存储 `N!` 个排列。

#### 疑难点

- **理解回溯**：回溯算法可能难以理解，特别是对于初学者。理解回溯的关键在于它是一种通过试错来寻找所有解决方案的算法，如果当前选择导致无法找到解决方案，回溯算法会取消上一步的选择，然后尝试其他选项。
- **递归的使用**：递归是解决这类问题的强大工具，但也需要一定的逻辑思维来正确实现。
- **时间复杂度**：由于全排列的数量非常庞大，这个算法在处理大数组时会非常慢。理解这一点很重要，特别是在实际应用中考虑性能时。
- 我不太理解为什么backtrack里for loop下回溯为什么remaining的参数是remaining[:i]+remaining[i+1:]？能用实际例子解释一下吗？

当然，我可以通过一个实际的例子来解释为什么在 `backtrack` 函数中的 `for` 循环里，回溯时传递的 `remaining` 参数是 `remaining[:i] + remaining[i+1:]`。

假设我们的输入数组是 `[1, 2, 3]`，我们希望生成这个数组的所有可能排列。

### 流程解释

1. **初始调用**：`backtrack([], [1, 2, 3])`
2. **第一层递归**：选择第一个元素 `1`
   - `path = [1]`
   - `remaining = [2, 3]`
   - 调用 `backtrack([1], [2, 3])`
3. **第二层递归**：基于 `1`，选择下一个元素 `2`
   - `path = [1, 2]`
   - `remaining = [3]`
   - 调用 `backtrack([1, 2], [3])`
4. **第三层递归**：基于 `[1, 2]`，选择最后一个元素 `3`
   - `path = [1, 2, 3]`
   - `remaining = []`
   - 到达递归的底部，将 `[1, 2, 3]` 添加到结果中
   - 返回上一层
5. **回到第二层递归**：撤销选择 `2`，尝试下一个元素
   - `path = [1]`
   - `remaining` 在当前层级的下一个元素是 `3`
   - 调用 `backtrack([1], [3])`

这个过程中，`remaining[:i] + remaining[i+1:]` 这个表达式的作用就是从 `remaining` 中移除当前选择的元素。比如，当我们选择了 `1`，`remaining` 就变成了 `[2, 3]`，这是通过移除 `1`（即 `remaining[0]`）来实现的。

对于 `remaining[:i] + remaining[i+1:]` 这个表达式，其作用如下：

- `remaining[:i]`：取出 `remaining` 中索引 `i` 之前的所有元素。
- `remaining[i+1:]`：取出 `remaining` 中索引 `i` 之后的所有元素。
- 通过将这两部分连接起来，我们就能得到不包含当前选择元素 `i` 的新 `remaining` 数组。

这种方法允许我们在每一层递归中探索所有剩余的可能选择，而不会重复选择已经被加入到 `path` 的元素。

---

### [47.全排列 II](https://leetcode.com/problems/permutations-ii/description/)

给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。

**示例 1：**

输入：nums = [1,1,2]

**输出：**

[[1,1,2],

[1,2,1],

[2,1,1]]

**示例 2：**

输入：nums = [1,2,3]

**输出：**[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

**提示：**

- `1 <= nums.length <= 8`
- `-10 <= nums[i] <= 10`

#### 解题思路：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201331223.png)

1. 初始化一个计数器，记录每个数字出现的次数。
2. 使用回溯函数 `backtrack()` 生成所有全排列。
   - 在 `backtrack()` 函数中：
      - 如果路径长度等于原始数组长度，说明找到了一个全排列，将其添加到结果列表。
      - 遍历每个不同的数字：
         - 如果这个数字还有剩余可用，则选择当前数字，并递归填下一个数。
         - 撤销选择。

```python
# 回溯算法解决全排列问题（包含重复数字）
def permuteUnique(nums):
    def backtrack(path, counter):
        # 如果路径长度等于原始数组长度，说明找到了一个全排列
        if len(path) == len(nums):
            res.append(path[:])  # 添加当前全排列到结果列表
            return
        # 遍历每个不同的数字
        for num in counter:
            if counter[num] > 0:  # 如果这个数字还有剩余可用
                # 选择当前数字
                path.append(num)
                counter[num] -= 1
                
                # 继续递归填下一个数
                backtrack(path, counter)
                
                # 撤销选择
                path.pop()
                counter[num] += 1
    
    res = []
    counter = {}  # 计数器，记录每个数字出现的次数
    for num in nums:
        counter[num] = counter.get(num, 0) + 1
    backtrack([], counter)
    return res

# 示例测试
print(permuteUnique([1,1,2]))
print(permuteUnique([1,2,3]))
```

#### 时空复杂度：

- 时间复杂度由递归的层数决定，每个层数需要遍历 n 个数字，因此时间复杂度为 O(n!)。
- 空间复杂度由 visited 数组决定，visited 数组的大小为 n，因此空间复杂度为 O(n)。

#### 代码随想录算法训练营第三十天 | 332.重新安排行程，51. N皇后，37. 解数独

#### ● day 30 任务以及具体安排：[第七章 回溯算法part06](https://docs.qq.com/doc/DUEdTVVhxbnJiY3BR) (1.11)

# 第七章 回溯算法part06

●  332.重新安排行程

●  51. N皇后

●  37. 解数独

●  总结

# 详细布置

今天这三道题都非常难，那么这么难的题，为啥一天做三道？

因为 一刷 也不求大家能把这么难的问题解决，所以 大家一刷的时候，就了解一下题目的要求，了解一下解题思路，不求能直接写出代码，先大概熟悉一下这些题，二刷的时候，随着对回溯算法的深入理解，再去解决如下三题。

大家今天的任务，其实是 对回溯算法章节做一个总结就行。

重点是看 回溯算法总结篇：

[代码随想录](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html)

## 332.重新安排行程（可跳过）

[代码随想录](https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html)

## 51. N皇后（可跳过）

[代码随想录](https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html)

视频讲解：[https://www.bilibili.com/video/BV1Rd4y1c7Bq](https://www.bilibili.com/video/BV1Rd4y1c7Bq)

## 37. 解数独（可跳过）

[代码随想录](https://programmercarl.com/0037.%E8%A7%A3%E6%95%B0%E7%8B%AC.html)

视频讲解：[https://www.bilibili.com/video/BV1TW4y1471V](https://www.bilibili.com/video/BV1TW4y1471V)

## 总结

[代码随想录](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html)

[ChatGPT](https://chat.openai.com/share/62edf3b0-b1da-456d-bd78-7d035c08f795)

[代码随想录](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html)

---

### [332.重新安排行程](https://leetcode.com/problems/reconstruct-itinerary/description/)

给你一份航线列表 `tickets` ，其中 `tickets[i] = [fromi, toi]` 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。

所有这些机票都属于一个从 `JFK`（肯尼迪国际机场）出发的先生，所以该行程必须从 `JFK` 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。

- 例如，行程 `["JFK", "LGA"]` 与 `["JFK", "LGB"]` 相比就更小，排序更靠前。

假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。

**示例 1：**

![Image.jpg](https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg)

输入：tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]

**输出：**["JFK","MUC","LHR","SFO","SJC"]

**示例 2：**

![Image.jpg](https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg)

输入：tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]

**输出：**["JFK","ATL","JFK","SFO","ATL","SFO"]

解释：另一种有效的行程是 ["JFK","SFO","ATL","JFK","ATL","SFO"] ，但是它字典排序更大更靠后。

**提示：**

- `1 <= tickets.length <= 300`
- `tickets[i].length == 2`
- `fromi.length == 3`
- `toi.length == 3`
- `fromi` 和 `toi` 由大写英文字母组成
- `fromi != toi`

#### 解题思路：

这个问题可以通过使用图的深度优先搜索（DFS）算法来解决。我们首先构建一个图，其中每个机场是一个节点，每个机票代表从一个机场到另一个机场的有向边。由于题目要求我们找出字典序最小的行程，我们需要对从每个机场出发的航班按照字典序进行排序。然后，我们从 JFK 机场开始进行深度优先搜索。

具体的步骤如下：

1. 构建图：创建一个哈希表来存储每个机场和从该机场出发的所有航班列表。这些航班列表需要按照字典序排序。
2. 深度优先搜索：从 JFK 开始进行深度优先搜索。每次访问一个机场，我们就移除一张从该机场出发的机票，并继续搜索下一个目的地机场。
3. 当我们不能再继续搜索时（即没有更多的机票可用），我们将当前机场添加到行程中。
4. 由于深度优先搜索是递归的，所以行程会被逆序构建。我们需要在最后将行程翻转以获得正确的顺序。

```python
def findItinerary(tickets):
    from collections import defaultdict
    # 构建图，并对每个节点的邻接列表按字典序排序
    graph = defaultdict(list)
    for src, dst in sorted(tickets, reverse=True):
        graph[src].append(dst)
    
    route = []

    def dfs(airport):
        # 使用递归进行深度优先搜索
        while graph[airport]:
            next_dest = graph[airport].pop()  # 移除并返回最后一个元素
            dfs(next_dest)
        route.append(airport)

    dfs("JFK")
    return route[::-1]  # 翻转获得正确的顺序

# 测试用例
tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
print(findItinerary(tickets))
```

#### 时空复杂度：

时间复杂度：O(E log E)，其中 E 是机票的数量。由于我们对邻接列表进行了排序，这是主要的时间开销。

空间复杂度：O(E)，用于存储图结构。

#### 疑难点：

注意：这个问题是经典的“欧拉路径”或“欧拉回路”问题的变种，在图论中是一个知名的问题。在这个问题中，我们要找到一条通过每条边恰好一次的路径，这就是欧拉路径。如果路径的起点和终点相同，则称为欧拉回路。

**这道题目有几个难点：**

1. 一个行程中，如果航班处理不好容易变成一个圈，成为死循环
在构建图和进行深度优先搜索（DFS）时，我们需要确保每张机票只被使用一次。这可以通过在搜索过程中从图中移除已经使用的边来实现。在我们的实现中，`graph[airport].pop()` 操作正是在做这件事情，它确保了每张机票在整个行程中只被使用一次。这样，我们就不会陷入死循环，因为每次递归调用都会减少至少一张未使用的机票。

2. 有多种解法，字母序靠前排在前面，让很多同学望而退步，如何该记录映射关系呢 ？
为了确保字典序，我们首先对所有的机票进行排序，然后构建图。在构建图时，对于每个出发点，我们将其目的地按照字典序逆序放入列表（即最大的元素在栈顶）。这样，在进行 DFS 时，我们总是优先访问字典序最小的目的地。通过这种方式，我们确保了如果有多种有效行程，总是返回字典序最小的那个。

3. 使用回溯法（也可以说深搜） 的话，那么终止条件是什么呢？
在这个问题中，DFS 的终止条件是当前机场没有更多的航班可用，即 `graph[airport]` 为空。当这种情况发生时，我们将当前机场添加到行程中，并返回上一级递归。

4. 搜索的过程中，如何遍历一个机场所对应的所有机场。

在DFS搜索过程中，对于当前机场 `airport`，我们遍历其所有的目的地。这是通过循环 `while graph[airport]` 实现的，它会持续进行直到当前机场的所有航班都被遍历完。通过这种方式，我们能够探索从当前机场出发的所有可能的航班。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/2020111518065555-20230310121223600.png)

---

### [51. N皇后](https://leetcode.com/problems/n-queens/description/)

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

**示例 1：**

![Image.jpg](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)

输入：n = 4

**输出：**[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]

解释：如上图所示，4 皇后问题存在两个不同的解法。

**示例 2：**

输入：n = 1

**输出：**[["Q"]]

**提示：**

- `1 <= n <= 9`

#### 解题思路：

解决 N 皇后问题通常使用回溯法，这是一种基于深度优先搜索的算法。关键在于如何放置每个皇后并检查当前放置是否会导致冲突。皇后可以攻击同一行、同一列以及两个对角线上的任何棋子。因此，在放置每个皇后时，我们需要确保这三个条件都不被违反。

![Image.jpg](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130182532303.jpg)

下面是解决 N 皇后问题的步骤和相关Python代码：

1. **初始化棋盘**：

   使用一个 n x n 的矩阵来表示棋盘，初始时所有位置都为空（可以用'.'表示）。

2. **逐行放置皇后**：

   从第一行开始，尝试在每一列放置皇后。如果当前列是安全的（即不违反上述条件），则在这一列放置皇后。

3. **检查冲突**：

   在放置皇后之前，需要检查当前位置是否安全。具体来说，需要检查同一列、左上对角线和右上对角线是否已经有皇后。

4. **递归和回溯**：

   如果在当前行找到了安全的位置，则递归地在下一行放置皇后。如果所有行都成功放置了皇后，则找到了一个解决方案。如果在某行找不到安全的位置，则回溯到上一行，移动上一行的皇后到下一个安全的位置。

5. **收集解决方案**：

   当找到一个有效的棋盘布局时，将其添加到解决方案列表中。

```python
def solveNQueens(n):
    # 检查当前位置是否安全
    def isSafe(row, col):
        # 检查同一列是否安全
        for i in range(row):
            if board[i][col] == 'Q':
                return False
        # 检查左上对角线是否安全
        i, j = row, col
        while i >= 0 and j >= 0:
            if board[i][j] == 'Q':
                return False
            i -= 1
            j -= 1
        # 检查右上对角线是否安全
        i, j = row, col
        while i >= 0 and j < n:
            if board[i][j] == 'Q':
                return False
            i -= 1
            j += 1
        return True

    # 回溯函数
    def backtrack(row):
        # 如果已经到达最后一行的下一行，则找到一个解决方案
        if row == n:
            solution = [''.join(board[i]) for i in range(n)]
            result.append(solution)
            return
        # 尝试在当前行的每一列放置皇后
        for col in range(n):
            if isSafe(row, col):
                board[row][col] = 'Q'  # 放置皇后
                backtrack(row + 1)    # 递归到下一行
                board[row][col] = '.'  # 回溯，移除皇后

    result = []
    board = [['.' for _ in range(n)] for _ in range(n)]  # 初始化棋盘
    backtrack(0)  # 从第一行开始
    return result

# 测试用例
print(solveNQueens(4))
```

这个代码首先初始化一个空棋盘，然后从第一行开始尝试放置皇后。它使用递归和回溯来尝试所有可能的放置方法，并在找到有效解时将其添加到结果列表中。每次放置皇后前，都会检查当前位置是否安全。如果不安全，就跳过当前位置，尝试下一个位置。如果所有位置都不安全，则回溯到上一行。

**时间复杂度**：

- 在最坏情况下，我们需要探索所有可能的放置方法。每一行我们有 n 种放置皇后的选择，总共有 n 行，因此时间复杂度大约是 O(n^n)。
- 请注意，这个估计是非常宽松的。实际上，由于我们的安全检查（`isSafe` 函数），很多放置方法会被提前剪枝（即排除），因此实际的时间复杂度会低于 O(n^n)。

**空间复杂度**：

- 空间复杂度主要取决于棋盘的大小和递归栈的深度。
- 棋盘的大小是 O(n^2)。
- 递归栈的最大深度是 n，因此递归栈的空间复杂度是 O(n)。
- 综上，总的空间复杂度是 O(n^2)。

**疑难点**：

- **如何判断位置是否安全**：这是解决 N 皇后问题的核心。我们需要检查当前列、左上对角线和右上对角线是否已经有皇后。
- **回溯的处理**：正确地放置皇后后，我们递归地调用 `backtrack` 函数去处理下一行。如果下一行（或者更深的行）处理失败，则需要回溯，即撤销当前行的皇后放置，并尝试下一个位置。
- **找到所有解决方案**：我们需要收集所有可能的解决方案，而不仅仅是第一个找到的解决方案。这就是为什么我们在找到一个解决方案后继续回溯的原因。

---

### [37. 解数独](https://leetcode.com/problems/sudoku-solver/description/)

编写一个程序，通过填充空格来解决数独问题。

数独的解法需 **遵循如下规则**：

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

数独部分空格内已填入了数字，空白格用 `'.'` 表示。

**示例 1：**

![Image.png](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png)

输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]

**输出：**[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]

解释：输入的数独如上图所示，唯一有效的解决方案如下所示：

![Image.png](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714_solutionsvg.png)

**提示：**

- `board.length == 9`
- `board[i].length == 9`
- `board[i][j]` 是一位数字或者 `'.'`
- 题目数据 **保证** 输入数独仅有一个解

#### 解题思路：

解数独的问题可以通过回溯法来解决。回溯法是一种通过探索所有可能的候选解来找出所有解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会丢弃该解，并通过在上一步的解中进行适当的修改来继续寻找解。

解数独的关键在于逐个填充每个空白格子，确保填充的数字不违反数独的规则。具体步骤如下：

1. **逐格尝试**：遍历每个格子，对于每个空格（用 '.' 表示），尝试填入 1 到 9 中的每个数字，然后检查这个数字是否有效。
2. **检查有效性**：填入的数字必须满足数独的三个条件：在当前行、当前列以及当前 3x3 宫内数字唯一。
3. **递归和回溯**：如果一个数字有效，就递归地填充下一个空格。如果未来某个步骤失败了，就回溯，即撤销之前的填充，尝试下一个数字。
4. **找到解决方案**：当所有空格都有效地填充后，数独就被解决了。

```python
def solveSudoku(board):
    def isValid(row, col, c):
        # 检查行是否有效
        for i in range(9):
            if board[row][i] == c:
                return False
        # 检查列是否有效
        for i in range(9):
            if board[i][col] == c:
                return False
        # 检查 3x3 宫格是否有效
        startRow, startCol = 3 * (row // 3), 3 * (col // 3)
        for i in range(startRow, startRow + 3):
            for j in range(startCol, startCol + 3):
                if board[i][j] == c:
                    return False
        return True

    def backtrack():
        for i in range(9):
            for j in range(9):
                if board[i][j] == '.':
                    for c in '123456789':
                        if isValid(i, j, c):
                            board[i][j] = c  # 尝试填充
                            if backtrack():  # 递归填充下一个空格
                                return True
                            board[i][j] = '.'  # 回溯
                    return False  # 如果所有数字都不行，则返回 False
        return True  # 如果所有空格都填完，返回 True

    backtrack()

# 测试用例
board = [
    ["5","3",".",".","7",".",".",".","."],
    ["6",".",".","1","9","5",".",".","."],
    [".","9","8",".",".",".",".","6","."],
    ["8",".",".",".","6",".",".",".","3"],
    ["4",".",".","8",".","3",".",".","1"],
    ["7",".",".",".","2",".",".",".","6"],
    [".","6",".",".",".",".","2","8","."],
    [".",".",".","4","1","9",".",".","5"],
    [".",".",".",".","8",".",".","7","9"]
]
solveSudoku(board)
for row in board:
    print(row)
```

**时间复杂度**：最坏情况下，我们需要遍历所有可能的填充方法，即 O(9^m)，其中 m 是空格的

数量。每次尝试填充一个数字时，我们都需要 O(1) 的时间来检查行、列和 3x3 宫格的有效性。

**空间复杂度**：空间复杂度主要由递归深度决定，最坏情况下递归深度等于空格的数量，因此是 O(m)，其中 m 是空格的数量。

**疑难点**：

- **有效性检查**：最重要的是在填充数字前后都要进行有效性检查。这个检查包括行检查、列检查以及 3x3 宫格检查。
- **回溯的处理**：递归地尝试每种可能的数字填充，一旦发现当前选择导致未来无法完成数独，就撤销（回溯）当前选择，尝试下一个数字。
- **找到解决方案后的处理**：一旦所有的空格都被正确填充，即完成了数独的求解，应立即停止所有进一步的递归尝试，直接返回解决方案。

这种方法虽然在理论上可能有较高的时间复杂度，但在实际问题中，由于数独的特性和有效性检查的剪枝，通常能够快速找到解决方案。

---

### 回溯总结篇

### 组合问题

在[回溯算法：求组合问题！ (opens new window)](https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html)中，我们开始用回溯法解决第一道题目：组合问题。

我在文中开始的时候给大家列举k层for循环例子，进而得出都是同样是暴力解法，为什么要用回溯法！

**此时大家应该深有体会回溯法的魅力，用递归控制for循环嵌套的数量！**

本题我把回溯问题抽象为树形结构，如题：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201118152928844.png)

可以直观的看出其搜索的过程：**for循环横向遍历，递归纵向遍历，回溯不断调整结果集**，这个理念贯穿整个回溯法系列，也是我做了很多回溯的题目，不断摸索其规律才总结出来的。

对于回溯法的整体框架，网上搜的文章这块都说不清楚，按照天上掉下来的代码对着讲解，不知道究竟是怎么来的，也不知道为什么要这么写。

**所以，录友们刚开始学回溯法，起跑姿势就很标准了！**

优化回溯算法只有剪枝一种方法，在[回溯算法：组合问题再剪剪枝 (opens new window)](https://programmercarl.com/0077.%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96.html)中把回溯法代码做了剪枝优化，树形结构如图：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201118153133458.png)

大家可以一目了然剪的究竟是哪里。

[**回溯算法：求组合问题！ (opens new window)**](https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html)**剪枝精髓是：for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够题目要求的k个元素了，就没有必要搜索了**。

**在for循环上做剪枝操作是回溯法剪枝的常见套路！** 后面的题目还会经常用到。

#### 组合总和（一）

在[回溯算法：求组合总和！ (opens new window)](https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html)中，相当于 [回溯算法：求组合问题！ (opens new window)](https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html)加了一个元素总和的限制。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201118201921245.png)

树形结构如图：

整体思路还是一样的，本题的剪枝会好想一些，即：**已选元素总和如果已经大于n（题中要求的和）了，那么往后遍历就没有意义了，直接剪掉**，如图：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201118202038240.png)

在本题中，依然还可以有一个剪枝，就是[回溯算法：组合问题再剪剪枝 (opens new window)](https://programmercarl.com/0077.%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96.html)中提到的，对for循环选择的起始范围的剪枝。

所以剪枝的代码可以在for循环加上 `i <= 9 - (k - path.size()) + 1` 的限制！

#### [\#](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E4%BA%8C)组合总和（二）

在[回溯算法：求组合总和（二） (opens new window)](https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html)中讲解的组合总和问题，和[回溯算法：求组合问题！ (opens new window)](https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html)，[回溯算法：求组合总和！ (opens new window)](https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html)和区别是：本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制。

不少同学都是看到可以重复选择，就义无反顾的把startIndex去掉了。

**本题还需要startIndex来控制for循环的起始位置，对于组合问题，什么时候需要startIndex呢？**

我举过例子，如果是一个集合来求组合的话，就需要startIndex，例如：[回溯算法：求组合问题！ (opens new window)](https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html)，[回溯算法：求组合总和！ (opens new window)](https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html)。

如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：[回溯算法：电话号码的字母组合(opens new window)](https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html)

**注意以上我只是说求组合的情况，如果是排列问题，又是另一套分析的套路**。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201223170730367.png)

树形结构如下：

最后还给出了本题的剪枝优化，如下：

```other
for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++)
```

1

优化后树形结构如下：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201118202115929.png)

#### [\#](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E4%B8%89)组合总和（三）

在[回溯算法：求组合总和（三） (opens new window)](https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html)中集合元素会有重复，但要求解集不能包含重复的组合。

**所以难就难在去重问题上了**。

这个去重问题，相信做过的录友都知道有多么的晦涩难懂。网上的题解一般就说“去掉重复”，但说不清怎么个去重，代码一甩就完事了。

为了讲解这个去重问题，**Carl自创了两个词汇，“树枝去重”和“树层去重”**。

都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上“使用过”，一个维度是同一树层上“使用过”。**没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因**。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/2020111820220675.png)

我在图中将used的变化用橘黄色标注上，**可以看出在candidates[i] == candidates[i - 1]相同的情况下：**

- used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
- used[i - 1] == false，说明同一树层candidates[i - 1]使用过

**这块去重的逻辑很抽象，网上搜的题解基本没有能讲清楚的，如果大家之前思考过这个问题或者刷过这道题目，看到这里一定会感觉通透了很多！**

对于去重，其实排列和子集问题也是一样的道理。

### [\#](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html#%E5%A4%9A%E4%B8%AA%E9%9B%86%E5%90%88%E6%B1%82%E7%BB%84%E5%90%88)多个集合求组合

在[回溯算法：电话号码的字母组合 (opens new window)](https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html)中，开始用多个集合来求组合，还是熟悉的模板题目，但是有一些细节。

例如这里for循环，可不像是在 [回溯算法：求组合问题！ (opens new window)](https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html)和[回溯算法：求组合总和！ (opens new window)](https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html)中从startIndex开始遍历的。

**因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合，而**[**回溯算法：求组合问题！ (opens new window)**](https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html)**和**[**回溯算法：求组合总和！ (opens new window)**](https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html)**都是是求同一个集合中的组合！**

树形结构如下：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201118202335724.png)

如果大家在现场面试的时候，一定要注意各种输入异常的情况，例如本题输入1 * #按键。

其实本题不算难，但也处处是细节，还是要反复琢磨。

## [\#](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html#%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98)切割问题

在[回溯算法：分割回文串 (opens new window)](https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html)中，我们开始讲解切割问题，虽然最后代码看起来好像是一道模板题，但是从分析到学会套用这个模板，是比较难的。

我列出如下几个难点：

- 切割问题其实类似组合问题
- 如何模拟那些切割线
- 切割问题中递归如何终止
- 在递归循环中如何截取子串
- 如何判断回文

如果想到了**用求解组合问题的思路来解决 切割问题本题就成功一大半了**，接下来就可以对着模板照葫芦画瓢。

**但后序如何模拟切割线，如何终止，如何截取子串，其实都不好想，最后判断回文算是最简单的了**。

所以本题应该是一个道hard题目了。

除了这些难点，**本题还有细节，例如：切割过的地方不能重复切割所以递归函数需要传入i + 1**。

树形结构如下：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201118202448642.png)

### 子集问题（一）

在[回溯算法：求子集问题！ (opens new window)](https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html)中讲解了子集问题，**在树形结构中子集问题是要收集所有节点的结果，而组合问题是收集叶子节点的结果**。

如图：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201118202544339.png)

认清这个本质之后，今天的题目就是一道模板题了。

**本题其实可以不需要加终止条件**，因为startIndex >= nums.size()，本层for循环本来也结束了，本来我们就要遍历整棵树。

有的同学可能担心不写终止条件会不会无限递归？

并不会，因为每次递归的下一层就是从i+1开始的。

如果要写终止条件，注意：`result.push_back(path);`要放在终止条件的上面，如下：

```other
result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉结果
if (startIndex >= nums.size()) { // 终止条件可以不加
    return;
}
```

### [\#](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html#%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98-%E4%BA%8C)子集问题（二）

在[回溯算法：求子集问题（二） (opens new window)](https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html)中，开始针对子集问题进行去重。

本题就是[回溯算法：求子集问题！ (opens new window)](https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html)的基础上加上了去重，去重我们在[回溯算法：求组合总和（三） (opens new window)](https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html)也讲过了，一样的套路。

树形结构如下：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/2020111217110449.png)

### [\#](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html#%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97)递增子序列

在[回溯算法：递增子序列 (opens new window)](https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html)中，处处都能看到子集的身影，但处处是陷阱，值得好好琢磨琢磨！

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201112170832333.png)

树形结构如下：

很多同学都会把这道题目和[回溯算法：求子集问题（二） (opens new window)](https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html)混在一起。

[**回溯算法：求子集问题（二） (opens new window)**](https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html)**也可以使用set针对同一父节点本层去重，但子集问题一定要排序，为什么呢？**

我用没有排序的集合{2,1,2,2}来举个例子画一个图，如下：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/2020111316440479.png)

**相信这个图胜过千言万语的解释了**。

### 排列问题（一）

[回溯算法：排列问题！ (opens new window)](https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html)又不一样了。

排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方。

可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用startIndex了。

如图：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201112170304979.png)

**大家此时可以感受出排列问题的不同：**

- 每层都是从0开始搜索而不是startIndex
- 需要used数组记录path里都放了哪些元素了

### [\#](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html#%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98-%E4%BA%8C)排列问题（二）

排列问题也要去重了，在[回溯算法：排列问题（二） (opens new window)](https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html)中又一次强调了“树层去重”和“树枝去重”。

树形结构如下：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201112171930470.png)

**这道题目神奇的地方就是used[i - 1] == false也可以，used[i - 1] == true也可以！**

我就用输入: [1,1,1] 来举一个例子。

树层上去重(used[i - 1] == false)，的树形结构如下：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201112172230434.png)

树枝上去重（used[i - 1] == true）的树型结构如下：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201112172327967.png)

**可以清晰的看到使用(used[i - 1] == false)，即树层去重，效率更高！**

本题used数组即是记录path里都放了哪些元素，同时也用来去重，一举两得。

## [\#](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html#%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%98)去重问题

以上我都是统一使用used数组来去重的，其实使用set也可以用来去重！

在[本周小结！（回溯算法系列三）续集 (opens new window)](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%8E%BB%E9%87%8D%E9%97%AE%E9%A2%98%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95.html)中给出了子集、组合、排列问题使用set来去重的解法以及具体代码，并纠正一些同学的常见错误写法。

同时详细分析了 使用used数组去重 和 使用set去重 两种写法的性能差异：

**使用set去重的版本相对于used数组的版本效率都要低很多**，大家在leetcode上提交，能明显发现。

原因在[回溯算法：递增子序列 (opens new window)](https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html)中也分析过，主要是因为程序运行的时候对unordered_set 频繁的insert，unordered_set需要做哈希映射（也就是把key通过hash function映射为唯一的哈希值）相对费时间，而且insert的时候其底层的符号表也要做相应的扩充，也是费时的。

**而使用used数组在时间复杂度上几乎没有额外负担！**

**使用set去重，不仅时间复杂度高了，空间复杂度也高了**，在[本周小结！（回溯算法系列三） (opens new window)](https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201112%E5%9B%9E%E6%BA%AF%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html)中分析过，组合，子集，排列问题的空间复杂度都是O(n)，但如果使用set去重，空间复杂度就变成了O(n^2)，因为每一层递归都有一个set集合，系统栈空间是n，每一个空间都有set集合。

那有同学可能疑惑 用used数组也是占用O(n)的空间啊？

used数组可是全局变量，每层与每层之间公用一个used数组，所以空间复杂度是O(n + n)，最终空间复杂度还是O(n)。

## [\#](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html#%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B-%E5%9B%BE%E8%AE%BA%E9%A2%9D%E5%A4%96%E6%8B%93%E5%B1%95)重新安排行程（图论额外拓展）

之前说过，有递归的地方就有回溯，深度优先搜索也是用递归来实现的，所以往往伴随着回溯。

在[回溯算法：重新安排行程 (opens new window)](https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html)其实也算是图论里深搜的题目，但是我用回溯法的套路来讲解这道题目，算是给大家拓展一下思路，原来回溯法还可以这么玩！

以输入：[["JFK", "KUL"], ["JFK", "NRT"], ["NRT", "JFK"]为例，抽象为树形结构如下：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/2020111518065555.png)

本题可以算是一道hard的题目了，关于本题的难点我在文中已经详细列出。

**如果单纯的回溯搜索（深搜）并不难，难还难在容器的选择和使用上！**

本题其实是一道深度优先搜索的题目，但是我完全使用回溯法的思路来讲解这道题题目，**算是给大家拓展一下思维方式，其实深搜和回溯也是分不开的，毕竟最终都是用递归**。

## [\#](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html#%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98)棋盘问题

### [\#](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html#n%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98)N皇后问题

在[回溯算法：N皇后问题 (opens new window)](https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html)中终于迎来了传说中的N皇后。

下面我用一个3 * 3 的棋盘，将搜索过程抽象为一棵树，如图：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201118225433127.png)

从图中，可以看出，二维矩阵中矩阵的高就是这棵树的高度，矩阵的宽就是树形结构中每一个节点的宽度。

那么我们用皇后们的约束条件，来回溯搜索这棵树，**只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了**。

如果从来没有接触过N皇后问题的同学看着这样的题会感觉无从下手，可能知道要用回溯法，但也不知道该怎么去搜。

**这里我明确给出了棋盘的宽度就是for循环的长度，递归的深度就是棋盘的高度，这样就可以套进回溯法的模板里了**。

相信看完本篇[回溯算法：N皇后问题 (opens new window)](https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html)也没那么难了，传说已经不是传说了。

### [\#](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html#%E8%A7%A3%E6%95%B0%E7%8B%AC%E9%97%AE%E9%A2%98)解数独问题

在[回溯算法：解数独 (opens new window)](https://programmercarl.com/0037.%E8%A7%A3%E6%95%B0%E7%8B%AC.html)中要征服回溯法的最后一道山峰。

解数独应该是棋盘很难的题目了，比N皇后还要复杂一些，但只要理解 “二维递归”这个过程，其实发现就没那么难了。

大家已经跟着「代码随想录」刷过了如下回溯法题目，例如：[77.组合（组合问题） (opens new window)](https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html)，[131.分割回文串（分割问题） (opens new window)](https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html)，[78.子集（子集问题） (opens new window)](https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html)，[46.全排列（排列问题） (opens new window)](https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html)，以及[51.N皇后（N皇后问题） (opens new window)](https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html)，其实这些题目都是一维递归。

其中[N皇后问题 (opens new window)](https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html)是因为每一行每一列只放一个皇后，只需要一层for循环遍历一行，递归来遍历列，然后一行一列确定皇后的唯一位置。

本题就不一样了，**本题中棋盘的每一个位置都要放一个数字，并检查数字是否合法，解数独的树形结构要比N皇后更宽更深**。

因为这个树形结构太大了，我抽取一部分，如图所示：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/2020111720451790.png)

解数独可以说是非常难的题目了，如果还一直停留在一维递归的逻辑中，这道题目可以让大家瞬间崩溃。

**所以我在**[**回溯算法：解数独 (opens new window)**](https://programmercarl.com/0037.%E8%A7%A3%E6%95%B0%E7%8B%AC.html)**中开篇就提到了二维递归，这也是我自创词汇**，希望可以帮助大家理解解数独的搜索过程。

一波分析之后，在看代码会发现其实也不难，唯一难点就是理解**二维递归**的思维逻辑。

**这样，解数独这么难的问题也被我们攻克了**。

## [\#](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90)性能分析

**关于回溯算法的复杂度分析在网上的资料鱼龙混杂，一些所谓的经典面试书籍不讲回溯算法，算法书籍对这块也避而不谈，感觉就像是算法里模糊的边界**。

**所以这块就说一说我个人理解，对内容持开放态度，集思广益，欢迎大家来讨论！**

以下在计算空间复杂度的时候我都把系统栈（不是数据结构里的栈）所占空间算进去。

子集问题分析：

- 时间复杂度：O(2^n)，因为每一个元素的状态无外乎取与不取，所以时间复杂度为O(2^n)
- 空间复杂度：O(n)，递归深度为n，所以系统栈所用空间为O(n)，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为O(n)

排列问题分析：

- 时间复杂度：O(n!)，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * ..... 1 = n!。
- 空间复杂度：O(n)，和子集问题同理。

组合问题分析：

- 时间复杂度：O(2^n)，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。
- 空间复杂度：O(n)，和子集问题同理。

N皇后问题分析：

- 时间复杂度：O(n!) ，其实如果看树形图的话，直觉上是O(n^n)，但皇后之间不能见面所以在搜索的过程中是有剪枝的，最差也就是O（n!），n!表示n * (n-1) * .... * 1。
- 空间复杂度：O(n)，和子集问题同理。

解数独问题分析：

- 时间复杂度：O(9^m) , m是'.'的数目。
- 空间复杂度：O(n^2)，递归的深度是n^2

**一般说道回溯算法的复杂度，都说是指数级别的时间复杂度，这也算是一个概括吧！**

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20211030124742.png)

### 第八章：贪心算法

#### 代码随想录算法训练营第三十一天 | 455.分发饼干，376. 摆动序列，53. 最大子序和

#### ● day 31 任务以及具体安排：[第八章 贪心算法 part01](https://docs.qq.com/doc/DUG1PQ1ZZY2xXY1ly) (1.12)

# 第八章 贪心算法 part01

●  理论基础

●  455.分发饼干

●  376. 摆动序列

●  53. 最大子序和

贪心算法其实就是没有什么规律可言，所以大家了解贪心算法 就了解它没有规律的本质就够了。

不用花心思去研究其规律， 没有思路就立刻看题解。

基本贪心的题目 有两个极端，要不就是特简单，要不就是死活想不出来。

学完贪心之后再去看动态规划，就会了解贪心和动规的区别。

# 详细布置

## 理论基础

[代码随想录](https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)

## 455.分发饼干

[代码随想录](https://programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html)

## 376. 摆动序列

[代码随想录](https://programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html)

## 53. 最大子序和

[代码随想录](https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html)

[ChatGPT](https://chat.openai.com/share/6954769f-fdb2-4778-a075-dbd4954b6170)

#### 理论基础

**贪心的本质是选择每一阶段的局部最优，从而达到全局最优**。

**说实话贪心算法并没有固定的套路**。

所以唯一的难点就是如何通过局部最优，推出整体最优。

那么如何能看出局部最优是否能推出整体最优呢？有没有什么固定策略或者套路呢？

**不好意思，也没有！** 靠自己手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划。

有同学问了如何验证可不可以用贪心算法呢？

**最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧**。

贪心算法一般分为如下四步：

- 将问题分解为若干个子问题
- 找出适合的贪心策略
- 求解每一个子问题的最优解
- 将局部最优解堆叠成全局最优解

**不好意思了，贪心没有套路，说白了就是常识性推导加上举反例**。

---

### [455.分发饼干](https://leetcode.com/problems/assign-cookies/description/)

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

**示例 1:**

**输入:** g = [1,2,3], s = [1,1]

**输出:** 1

**解释:**

你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。

虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。

所以你应该输出1。

**示例 2:**

**输入:** g = [1,2], s = [1,2,3]

**输出:** 2

**解释:**

你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。

你拥有的饼干数量和尺寸都足以让所有孩子满足。

所以你应该输出2.

**提示：**

- `1 <= g.length <= 3 * 104`
- `0 <= s.length <= 3 * 104`
- `1 <= g[i], s[j] <= 231 - 1`

#### 解题思路：

这个问题是一个典型的贪心算法问题，关键在于如何有效地分配饼干以满足尽可能多的孩子。我们可以按照以下步骤解决这个问题：

1. **排序**：首先对孩子的胃口值数组 `g` 和饼干尺寸数组 `s` 进行排序。
2. **分配饼干**：使用两个指针分别遍历 `g` 和 `s`。如果当前饼干能满足当前孩子的胃口，则将满足孩子的数量加一，并移动两个指针；如果不能满足，则移动饼干指针到下一块饼干，尝试下一块更大的饼干。
3. **计数**：记录满足的孩子数量。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20230405225628.png)

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20230112102848.png)

```python
def findContentChildren(g, s):
    # 将孩子的胃口值和饼干尺寸排序
    g.sort()
    s.sort()
    child = 0  # 孩子的指针
    cookie = 0  # 饼干的指针
    while child < len(g) and cookie < len(s):
        # 如果当前饼干可以满足当前孩子
        if g[child] <= s[cookie]:
            child += 1  # 满足一个孩子
        cookie += 1  # 移动到下一块饼干
    return child  # 返回满足的孩子数量

# 测试用例
print(findContentChildren([1,2,3], [1,1]))  # 输出应为 1
print(findContentChildren([1,2], [1,2,3]))  # 输出应为 2
```

**时间复杂度**：排序的时间复杂度为`O(nlogn)`，遍历数组的时间复杂度为`O(n)`，所以总的时间复杂度为`O(nlogn)`。

**空间复杂度**：除了输入的数组外，只使用了固定的额外空间，所以空间复杂度为`O(1)`。

**常见错误**：

- 不对数组进行排序，这样可能错过更优的分配方案。
- 不正确地移动指针，例如在饼干不能满足孩子时也移动孩子指针。

这个问题的关键在于理解贪心算法的核心思想：局部最优解能导致全局最优解。在这个场景中，尽可能用小饼干满足胃口小的孩子是一个有效的策略。

---

### [376. 摆动序列](https://leetcode.com/problems/wiggle-subsequence/description/)

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

**示例 1：**

输入：nums = [1,7,4,9,2,5]

输出：6

解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。

**示例 2：**

输入：nums = [1,17,5,10,13,15,10,5,16,8]

输出：7

解释：这个序列包含几个长度为 7 摆动序列。

其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。

**示例 3：**

输入：nums = [1,2,3,4,5,6,7,8,9]

输出：2

**提示：**

- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`

进阶：你能否用 `O(n)` 时间复杂度完成此题?

#### 解题思路：

为了解决摆动序列问题，我们可以应用贪心算法。关键在于理解摆动序列的定义：序列中的每个元素要么是比前一个元素大，要么是比前一个元素小。这个问题可以通过跟踪序列中的局部极点（局部最大值和局部最小值）来解决，因为这些极点构成了摆动序列的核心。

解题步骤如下：

1. **初始化**：创建两个变量来跟踪摆动序列中的上升和下降部分的长度。由于序列至少有一个元素，所以初始长度设置为1。
2. **遍历数组**：从第二个元素开始遍历数组。对于每个元素，比较它与前一个元素的差异。
3. **更新计数器**：
   - 如果当前元素比前一个元素大，则说明是上升摆动，更新上升摆动的长度为下降摆动长度加1。
   - 如果当前元素比前一个元素小，则说明是下降摆动，更新下降摆动的长度为上升摆动长度加1。
4. **返回结果**：最后，最长的摆动序列长度是上升摆动和下降摆动长度中的较大者。

```python
def wiggleMaxLength(nums):
    # 当数组长度小于2时，直接返回数组的长度
    if len(nums) < 2:
        return len(nums)

    # 初始化上升和下降序列的长度为1
    up = down = 1

    # 遍历数组中的每个元素
    for i in range(1, len(nums)):
        if nums[i] > nums[i - 1]:
            # 如果当前元素比前一个元素大，更新上升摆动的长度
            up = down + 1
        elif nums[i] < nums[i - 1]:
            # 如果当前元素比前一个元素小，更新下降摆动的长度
            down = up + 1

    # 返回最长摆动序列的长度
    return max(up, down)

# 测试用例
print(wiggleMaxLength([1,7,4,9,2,5]))  # 应输出 6
print(wiggleMaxLength([1,17,5,10,13,15,10,5,16,8]))  # 应输出 7
print(wiggleMaxLength([1,2,3,4,5,6,7,8,9]))  # 应输出 2
```

**时间复杂度**：`O(n)`，其中 `n` 是数组 `nums` 的长度。我们只需要遍历数组一次。

**空间复杂度**：`O(1)`，只使用了常数个额外空间。

**注意事项**：

- 本题的关键在于理解摆动序列的定义和如何通过局部极点来找到最长的摆动序列。
- 当数组中存在连续相等的元素时，它们不会对摆动序列的长度产生影响，因为它们不会增加序列的摆动。

---

### [53. 最大子序和](https://leetcode.com/problems/maximum-subarray/description/)

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

**示例 1：**

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]

输出：6

解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

**示例 2：**

输入：nums = [1]

输出：1

**示例 3：**

输入：nums = [5,4,-1,7,8]

输出：23

**提示：**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

进阶：如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。

#### 解题思路：

这个问题是著名的最大子序和问题，可以使用动态规划来解决。我们将问题分解为更小的子问题：对于数组中的每个位置，我们需要确定以该位置元素结尾的子数组的最大和是多少。最后，从所有这些子数组中选择最大的和作为答案。

解题步骤如下：

1. **初始化**：创建一个变量 `max_sum` 来记录最大子序和，初始时设置为数组的第一个元素。同时，创建一个变量 `current_sum` 来存储以当前元素结尾的最大子序和。
2. **遍历数组**：从第二个元素开始，更新 `current_sum` 和 `max_sum`：
   - `current_sum` 应该是 `current_sum + nums[i]` 和 `nums[i]` 中的较大者。这是因为我们要决定是继续累加当前子序列，还是从当前元素开始一个新的子序列。
   - 更新 `max_sum` 为 `max(max_sum, current_sum)`。
3. **返回结果**：遍历完成后，`max_sum` 就是我们要找的最大子序和。

```python
def maxSubArray(nums):
    # 初始化最大子序和为数组的第一个元素
    max_sum = current_sum = nums[0]
    
    # 遍历数组，从第二个元素开始
    for i in range(1, len(nums)):
        # 更新当前子序列和，选择继续累加或从当前元素开始新序列
        current_sum = max(current_sum + nums[i], nums[i])
        # 更新最大子序和
        max_sum = max(max_sum, current_sum)

    # 返回最大子序和
    return max_sum

# 测试用例
print(maxSubArray([-2,1,-3,4,-1,2,1,-5,4]))  # 应输出 6
print(maxSubArray([1]))  # 应输出 1
print(maxSubArray([5,4,-1,7,8]))  # 应输出 23
```

**时间复杂度**：`O(n)`，其中 `n` 是数组 `nums` 的长度。我们只需要遍历数组一次。

**空间复杂度**：`O(1)`，只使用了常数个额外空间。

**分治法**：虽然这个问题可以用分治法求解，但是分治法的复杂度和直接的动态规划相比并没有明显优势，而且实现起来更为复杂。动态规划方法更为直观和高效，是解决这个问题的首选方法。

#### 疑难点：

#### 为什么current_sum = max(current_sum + nums[i], nums[i])而不是current_sum = current_sum + nums[i]？

在这个问题中，`current_sum = max(current_sum + nums[i], nums[i])` 之所以优于 `current_sum = current_sum + nums[i]`，是因为这样的处理可以有效处理包含负数的情况。

让我们详细解释一下这个选择的原因：

- `current_sum + nums[i]` 表示将当前元素 `nums[i]` 加到当前的子序列和中。这在当前子序列和为正数时是有意义的，因为它会增加子序列的总和。
- `nums[i]` 单独表示从当前元素开始一个新的子序列。这在 `current_sum` 为负数时非常重要。假设 `current_sum` 为负数，那么无论 `nums[i]` 是正是负，加上一个负数的 `current_sum` 都不会得到最优的子序列。在这种情况下，放弃之前的子序列和，从当前元素开始一个新的子序列更有可能得到更大的子序列和。

通过这种方式，我们可以确保 `current_sum` 始终存储着到当前元素为止的最大子序列和。如果我们只使用 `current_sum = current_sum + nums[i]`，则会在子序列和变为负数时继续累加，这可能导致不包含最优子序列的结果。

例如，考虑数组 `[-2, 1]`：

- 使用 `current_sum = max(current_sum + nums[i], nums[i])`，当 i = 1 时，`current_sum` 更新为 `max(-2 + 1, 1)`，即 `1`。
- 使用 `current_sum = current_sum + nums[i]`，当 i = 1 时，`current_sum` 更新为 `-2 + 1`，即 `-1`。

显然，在这个例子中，使用 `max` 函数能够正确地识别从第二个元素开始的更优子序列。

#### 代码随想录算法训练营第三十二天 | 122.买卖股票的最佳时机II，55. 跳跃游戏，45.跳跃游戏II

● day 32 任务以及具体安排：[第八章 贪心算法 part02](https://docs.qq.com/doc/DUGFEdGFWeVhleFF1) (1.13)

[ChatGPT](https://chat.openai.com/share/8d670c8c-1dfe-4aee-b7e6-cd8e6cc80878)

---

### [122.买卖股票的最佳时机II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/)

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

**示例 1：**

输入：prices = [7,1,5,3,6,4]

输出：7

解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。

随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
总利润为 4 + 3 = 7 。

**示例 2：**

输入：prices = [1,2,3,4,5]

输出：4

解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。

总利润为 4 。

**示例 3：**

输入：prices = [7,6,4,3,1]

输出：0

解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。

**提示：**

- `1 <= prices.length <= 3 * 104`
- `0 <= prices[i] <= 104`

#### 解题思路：

这个问题是一个典型的动态规划问题，也可以用贪心算法来解决。这里我们采用贪心算法，因为它更简单直观。贪心算法的核心思路是：只要明天的价格比今天高，我们就今天买入，明天卖出，这样可以获得最大利润。

步骤如下：

1. 初始化总利润为0。
2. 遍历价格数组，从第二天开始比较。
3. 如果第二天的价格比第一天的高，就把差价加到总利润中。
4. 最后返回总利润。

```python
def maxProfit(prices):
    total_profit = 0  # 初始化总利润为0
    for i in range(1, len(prices)):
        if prices[i] > prices[i - 1]:  # 如果第二天的价格比第一天高
            total_profit += prices[i] - prices[i - 1]  # 加上差价
    return total_profit  # 返回总利润
```

时间复杂度是 O(n)，因为我们只需要遍历一次数组，n 是数组的长度。空间复杂度是 O(1)，因为我们只需要常数空间来存储总利润。

常见错误：

- 忽略了可以在同一天买入和卖出的情况。
- 尝试寻找最低买点和最高卖点，而不是考虑连续的增长。

---

### [55. 跳跃游戏](https://leetcode.com/problems/jump-game/description/)

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

**示例 1：**

输入：nums = [2,3,1,1,4]

输出：true

解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。

**示例 2：**

输入：nums = [3,2,1,0,4]

输出：false

解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。

**提示：**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 105`

#### 解题思路：

这个问题可以通过贪心算法来解决。贪心算法在这里的核心思想是：在每一步都计算出从当前位置能够到达的最远位置，并更新这个最远位置。如果在某一步这个最远位置超过了数组的最后一个下标，或者与当前位置相同且不是数组的最后一个下标，那么就可以决定是否能到达数组的最后一个下标。

步骤如下：

1. 初始化最远位置 `farthest` 为 0。
2. 遍历数组，对于每个元素，更新 `farthest` 为当前元素能到达的最远位置和 `farthest` 中的较大值。
3. 如果在遍历过程中 `farthest` 已经大于或等于数组的最后一个下标，返回 `true`。
4. 如果在遍历过程中 `farthest` 等于当前位置且不是数组的最后一个下标，返回 `false`。
5. 遍历结束后，返回 `true`。

```python
def canJump(nums):
    farthest = 0  # 初始化最远位置为0
    for i in range(len(nums)):
        if farthest < i:  # 如果最远位置小于当前位置，无法到达当前位置
            return False
        farthest = max(farthest, i + nums[i])  # 更新最远位置
        if farthest >= len(nums) - 1:  # 如果最远位置大于等于数组的最后一个下标
            return True
    return True
```

时间复杂度是 O(n)，因为我们只需要遍历一次数组，n 是数组的长度。空间复杂度是 O(1)，因为我们只需要常数空间来存储 `farthest`。

常见错误：

- 未考虑到最远位置小于当前位置的情况。
- 未正确处理最远位置等于当前位置的情况。
- 这道题我不太明白为什么farthest < i就得return False. 难道不应该是farthest < len(nums)才说明无法抵达数列的末尾吗？

关于您的疑问，我来解释一下为什么在 `farthest < i` 的情况下需要返回 `False`。

在跳跃游戏中，`farthest` 表示从数组开始到当前位置，你能够到达的最远距离。这个最远距离是基于之前每一步可以跳跃的最大长度来计算的。当进行到数组的第 `i` 个位置时，如果 `farthest` 小于 `i`，这意味着你无法到达第 `i` 个位置。换句话说，你在之前的某一步就已经无法再前进了。

举个例子，如果数组是 `[3, 2, 1, 0, 4]`，当你到达数组的第 3 个元素（值为 0）时，`farthest` 的值只能达到 3（从第一个元素起跳，最远能跳到第四个元素位置）。但是你现在在第 4 个位置（数组下标从 0 开始），意味着你无法跳到这里（因为第 3 个元素是 0，不能从这里跳出去）。因此，`farthest < i` 在这里成立，表明你无法到达数组的最后。

而 `farthest < len(nums)` 的条件是用来判断你是否能到达数组末尾的。在遍历的过程中，只要 `farthest` 至少和 `len(nums) - 1`（数组最后一个元素的下标）一样大，就意味着你可以到达数组末尾。

综上所述，`farthest < i` 是用来判断在达到数组末尾之前，是否存在某个位置你无法到达。这是跳跃游戏的一个关键判断点。

---

### [45.跳跃游戏II](https://leetcode.com/problems/jump-game-ii/description/)

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]`
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

**示例 1:**

**输入:** nums = [2,3,1,1,4]

**输出:** 2

**解释:** 跳到最后一个位置的最小跳跃数是 `2`。

从下标为 0 跳到下标为 1 的位置，跳 `1` 步，然后跳 `3` 步到达数组的最后一个位置。

**示例 2:**

**输入:** nums = [2,3,0,1,4]

**输出:** 2

**提示:**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 1000`
- 题目保证可以到达 `nums[n-1]`

#### 解题思路：

这个问题是“跳跃游戏 II”，它要求找出到达数组最后一个元素的最小跳跃次数。这可以通过使用贪心算法来解决。与简单的跳跃游戏（检查是否可以到达末尾）不同，这里我们需要记录跳跃的次数，并在每一步都尽可能远地跳跃。

贪心算法的核心思路是：在每一步都选择能跳得最远的位置。为此，我们需要维护当前能够到达的最远位置和从当前位置出发下一步能到达的最远位置。当我们到达当前步能到达的最远位置时，就需要进行一次跳跃，并更新这两个变量。

具体步骤如下：

1. 初始化当前能够到达的最远位置 `end` 为 0，下一步能到达的最远位置 `farthest` 为 0，跳跃次数 `jumps` 为 0。
2. 遍历数组，但不包括最后一个元素，因为到达最后一个元素后不需要再跳跃。
3. 更新下一步能到达的最远位置 `farthest`。
4. 当到达当前步的最远位置时，如果它不是数组的最后一个位置，就增加跳跃次数，并更新 `end` 为 `farthest`。
5. 返回跳跃次数。

```python
def jump(nums):
    end = 0  # 当前能到达的最远位置
    farthest = 0  # 下一步能到达的最远位置
    jumps = 0  # 跳跃次数
    for i in range(len(nums) - 1):  # 遍历数组，但不包括最后一个元素
        farthest = max(farthest, i + nums[i])  # 更新下一步能到达的最远位置
        if i == end:  # 到达当前步能到达的最远位置
            jumps += 1  # 增加跳跃次数
            end = farthest  # 更新当前能到达的最远位置
    return jumps
```

#### 时空复杂度：

时间复杂度是 O(n)，因为我们只需要遍历一次数组，n 是数组的长度。

空间复杂度是 O(1)，因为我们只使用了常数个变量。

#### 疑难点：

#### 我不太明白为什么 if i == end: jumps += 1 end = farthest？你能结合具体例子详细解释一下为什么i == end的情况下jumps就能递增，而end 要更新为farthest吗？

当然可以。让我们结合一个具体的例子来解释这段代码的逻辑。

假设 `nums = [2, 3, 1, 1, 4]`，我们要找到到达数组最后一个元素的最小跳跃次数。

1. 初始化 `end = 0`，`farthest = 0`，`jumps = 0`。
2. 开始遍历数组。对于每个位置 `i`，我们计算在这一跳中能达到的最远位置，即 `i + nums[i]`，并更新 `farthest`。
3. 如果我们到达了 `end`（当前步能到达的最远位置），这意味着我们需要进行另一次跳跃（除非我们已经在数组的末尾），因为当前的这一跳无法再带我们更远了。

举个例子：

- 从 `nums[0] = 2` 开始，最远可以跳到 `nums[2]`。所以，`end = 2`，`farthest = 2`。
- 遍历到 `nums[1]` 时，我们发现从这里可以跳到 `nums[4]`（`1 + 3 = 4`），所以 `farthest` 更新为 4。
- 当 `i` 达到 2（即 `end`），我们发现我们需要进行另一次跳跃来到达更远的位置。因此，`jumps` 增加 1，`end` 更新为当前的 `farthest`，即 4。

通过这种方式，我们可以在每次必须跳跃时增加 `jumps`，并更新下一

一步跳跃的最远范围。这是因为在每一步中，我们都尽可能地跳到最远，以确保总跳跃次数最少。

继续刚才的例子：

- 初始时，我们在位置 0，可以跳到位置 1 或 2（因为 `nums[0] = 2`）。我们选择跳到位置 2，因为这是当前能跳到的最远位置。
- 在位置 2（`nums[2] = 1`），我们只能跳到位置 3。但在之前的步骤中，我们已经知道从位置 1 可以跳到更远的位置 4（因为 `nums[1] = 3`）。所以，我们的下一步是从位置 1 跳到位置 4，而不是从位置 2 跳到位置 3。
- 当 `i` 达到之前的 `end`（即 2）时，我们知道必须进行另一次跳跃（因为我们不能仅仅依靠之前的跳跃到达数组末尾）。于是，我们增加 `jumps`，并将 `end` 更新为 `farthest`（即 4，从位置 1 跳跃可达）。

在每一步中，我们都在计算“如果现在跳跃，能达到的最远位置是哪里？”并在必要时增加跳

跃次数。`end` 的更新确保了我们在每次跳跃时都达到了当前所能达到的最远位置，而 `farthest` 保证了我们总是知道下一步能跳到的最远位置。

继续例子：

- 当 `i` 为 3 时，我们发现 `farthest` 仍然是 4，因为从位置 3 只能跳到位置 4。
- 最终，当 `i` 达到 `end`（现在为 4），我们发现已经到达数组末尾，所以不需要再跳跃。

在这个过程中，我们跳了两次：第一次从位置 0 到位置 2，然后从位置 1 到位置 4。这就是为什么当 `i == end` 时 `jumps` 递增，并且 `end` 更新为 `farthest` 的原因。我们总是在达到当前跳跃所能达到的最远位置时，更新跳跃次数，并计划下一次跳跃能达到的最远位置。

#### 代码随想录算法训练营第三十四天 | 1005.K次取反后最大化的数组和，134. 加油站，135. 分发糖果

#### ● day 34 任务以及具体安排：[第八章 贪心算法 part03](https://docs.qq.com/doc/DUEh5WFVlQkp1U0p4) (1.15)

# 第八章 贪心算法 part03

●  1005.K次取反后最大化的数组和

●  134. 加油站

●  135. 分发糖果

详细布置

1005.K次取反后最大化的数组和

本题简单一些，估计大家不用想着贪心 ，用自己直觉也会有思路。

[代码随想录](https://programmercarl.com/1005.K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C.html)

134. 加油站

本题有点难度，不太好想，推荐大家熟悉一下方法二

[代码随想录](https://programmercarl.com/0134.%E5%8A%A0%E6%B2%B9%E7%AB%99.html)

135. 分发糖果

本题涉及到一个思想，就是想处理好一边再处理另一边，不要两边想着一起兼顾，后面还会有题目用到这个思路

[代码随想录](https://programmercarl.com/0135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html)

[ChatGPT](https://chat.openai.com/share/743c356f-b26d-4d55-a10c-26c62761e9ec)

---

### [1005.K次取反后最大化的数组和](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/description/)

给你一个整数数组 `nums` 和一个整数 `k` ，按以下方法修改该数组：

- 选择某个下标 `i` 并将 `nums[i]` 替换为 `-nums[i]` 。

重复这个过程恰好 `k` 次。可以多次选择同一个下标 `i` 。

以这种方式修改数组后，返回数组 **可能的最大和** 。

**示例 1：**

输入：nums = [4,2,3], k = 1

输出：5

解释：选择下标 1 ，nums 变为 [4,-2,3] 。

**示例 2：**

输入：nums = [3,-1,0,2], k = 3

输出：6

解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。

**示例 3：**

输入：nums = [2,-3,-1,5,-4], k = 2

输出：13

解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。

**提示：**

- `1 <= nums.length <= 104`
- `-100 <= nums[i] <= 100`
- `1 <= k <= 104`

#### 解题思路：

这个问题是关于数组操作的，我们的目标是在执行 K 次取反操作后，获得数组可能的最大和。下面是解决这个问题的步骤：

#### 解题步骤：

1. **排序数组**：首先，将数组 `nums` 排序。这样，我们可以确保负数位于数组的前面。
2. **取反负数**：接下来，我们从数组的开始位置遍历，对负数进行取反操作，直到所有的负数都被取反或者我们已经执行了 K 次操作。
3. **处理剩余的 K 次操作**：如果还有剩余的操作次数（即 K 次操作未用完），则需要注意：
   - 如果剩余操作次数为偶数，可以忽略，因为两次取反会抵消。
   - 如果剩余操作次数为奇数，那么我们应该对数组中最小的元素（此时已经是最接近于 0 的元素）执行一次取反操作。
4. **计算总和**：最后，计算并返回处理后的数组的总和。

```python
def largestSumAfterKNegations(nums, k):
    # 对数组进行排序
    nums.sort()

    # 遍历数组，对负数进行取反
    for i in range(len(nums)):
        if nums[i] < 0 and k > 0:
            nums[i] = -nums[i]
            k -= 1

    # 如果剩余操作次数为奇数，则对最小元素取反
    if k % 2 == 1:
        nums.sort()  # 再次排序，确保最小元素在前
        nums[0] = -nums[0]

    # 计算总和并返回
    return sum(nums)

# 测试用例
print(largestSumAfterKNegations([4,2,3], 1))  # 示例 1
print(largestSumAfterKNegations([3,-1,0,2], 3)) # 示例 2
print(largestSumAfterKNegations([2,-3,-1,5,-4], 2)) # 示例 3
```

#### 复杂度分析：

- 时间复杂度：`O(NlogN)`，主要是排序操作的复杂度。
- 空间复杂度：`O(1)`，未使用额外空间。

#### 常见错误：

- 不正确处理剩余的 K 次操作，特别是当 K 为奇数时。
- 未对数组重新排序以找到最小元素进行取反。

---

### [134. 加油站](https://leetcode.com/problems/gas-station/description/)

在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。

**示例 1:**

**输入:** gas = [1,2,3,4,5], cost = [3,4,5,1,2]

**输出:** 3

**解释:** 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油

开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油

开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油

开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油

开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油

开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。

因此，3 可为起始索引。

**示例 2:**

**输入:** gas = [2,3,4], cost = [3,4,3]

**输出:** -1

**解释:** 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。

我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油

开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油

开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油

你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。

因此，无论怎样，你都不可能绕环路行驶一周。

**提示:**

- `gas.length == n`
- `cost.length == n`
- `1 <= n <= 105`
- `0 <= gas[i], cost[i] <= 104`

#### 解题思路：

这个问题是关于加油站和汽车的环路行驶，我们需要找出是否存在一个加油站作为起点，使汽车能够环绕一圈回到出发点。下面是解决这个问题的步骤：

#### 解题步骤：

1. **总体思路**：首先，我们需要理解一个关键的概念：如果汽车从加油站 A 出发到不了加油站 B，那么 A 和 B 之间的任何一个加油站都不能作为出发点到达加油站 B。基于这个逻辑，我们可以逐个检查每个加油站。
2. **检查是否有解**：如果所有加油站的汽油总和小于行驶总消耗，则无法环绕一圈，返回 -1。
3. **寻找起始点**：从加油站 0 开始尝试，遍历每个加油站，记录当前的油量。如果在某个加油站的油量不够到达下一个加油站，就把下一个加油站作为新的起点，并重置当前油量。
4. **返回结果**：遍历完成后，返回最后确定的起始加油站编号。

```python
def canCompleteCircuit(gas, cost):
    # 检查是否有解
    if sum(gas) < sum(cost):
        return -1

    start, total_gas = 0, 0
    for i in range(len(gas)):
        total_gas += gas[i] - cost[i]
        # 如果油量不够到下一个加油站
        if total_gas < 0:
            start = i + 1
            total_gas = 0

    return start

# 测试用例
print(canCompleteCircuit([1,2,3,4,5], [3,4,5,1,2])) # 示例 1
print(canCompleteCircuit([2,3,4], [3,4,3])) # 示例 2
```

#### 复杂度分析：

- 时间复杂度：`O(N)`，其中 `N` 是加油站的数量。我们只需要遍历一次所有加油站。
- 空间复杂度：`O(1)`，使用了常数个额外空间。

#### 常见错误：

- 没有提前检查总油量是否足够。
- 未正确理解如果从 A 到不了 B，则 A 和 B 之间任何点都不可能作为出发点。

---

### [135. 分发糖果](https://leetcode.com/problems/candy/description/)

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

**示例 1：**

输入：ratings = [1,0,2]

输出：5

解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。

**示例 2：**

输入：ratings = [1,2,2]

输出：4

解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。

**提示：**

- `n == ratings.length`
- `1 <= n <= 2 * 104`
- `0 <= ratings[i] <= 2 * 104`

#### 解题思路：

这个问题是关于如何有效地分配糖果给孩子们，以满足特定的规则并且最小化糖果的总数。我们可以使用贪心算法来解决这个问题。下面是解决这个问题的步骤：

#### 解题步骤：

1. **初始化糖果分配**：首先，给每个孩子初始化一个糖果。
2. **从左到右遍历**：接着，从左到右遍历数组。如果当前孩子的评分比前一个孩子的评分高，那么就给当前孩子比前一个孩子多一个糖果。
3. **从右到左遍历**：然后，从右到左再次遍历数组。如果当前孩子的评分比后一个孩子的评分高，并且当前孩子的糖果数不多于后一个孩子，那么就给当前孩子比后一个孩子多一个糖果。
4. **计算总糖果数**：最后，计算所有孩子的糖果总数。

```python
def candy(ratings):
    n = len(ratings)
    candies = [1] * n

    # 从左到右遍历
    for i in range(1, n):
        if ratings[i] > ratings[i - 1]:
            candies[i] = candies[i - 1] + 1

    # 从右到左遍历
    for i in range(n - 2, -1, -1):
        if ratings[i] > ratings[i + 1]:
            candies[i] = max(candies[i], candies[i + 1] + 1)

    # 计算总糖果数
    return sum(candies)

# 测试用例
print(candy([1,0,2])) # 示例 1
print(candy([1,2,2])) # 示例 2
```

#### 复杂度分析：

- 时间复杂度：`O(N)`，其中 `N` 是孩子的数量。我们需要两次遍历数组。
- 空间复杂度：`O(N)`，用于存储

#### 代码随想录算法训练营第三十五天 | 860.柠檬水找零，406.根据身高重建队列，452. 用最少数量的箭引爆气球

#### ● day 35 任务以及具体安排：[第八章 贪心算法 part04](https://docs.qq.com/doc/DUFRWc3BGRHFXZ1pO) (1.16)

# 第八章 贪心算法 part04

●  860.柠檬水找零

●  406.根据身高重建队列

●  452. 用最少数量的箭引爆气球

详细布置

860.柠檬水找零

本题看上好像挺难，其实挺简单的，大家先尝试自己做一做。

[代码随想录](https://programmercarl.com/0860.%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html)

406.根据身高重建队列

本题有点难度，和分发糖果类似，不要两头兼顾，处理好一边再处理另一边。

[代码随想录](https://programmercarl.com/0406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html)

452. 用最少数量的箭引爆气球

本题是一道 重叠区间的题目，好好做一做，因为明天三道题目，都是 重叠区间。

[代码随想录](https://programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html)

[ChatGPT](https://chat.openai.com/share/0131bb00-bf12-4f27-b26d-d96fa6d4bace)

---

### [860.柠檬水找零](https://leetcode.com/problems/lemonade-change/)

在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 `5` 美元、`10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。

注意，一开始你手头没有任何零钱。

给你一个整数数组 `bills` ，其中 `bills[i]` 是第 `i` 位顾客付的账。如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。

**示例 1：**

输入：bills = [5,5,5,10,20]

输出：true

**解释：** 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。

第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。

第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。

由于所有客户都得到了正确的找零，所以我们输出 true。

**示例 2：**

输入：bills = [5,5,10,10,20]

输出：false

**解释：**

前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。

对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。

对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。

由于不是每位顾客都得到了正确的找零，所以答案是 false。

**提示：**

- `1 <= bills.length <= 105`
- `bills[i]` 不是 `5` 就是 `10` 或是 `20`

#### 解题思路：

这个问题是一个典型的贪心算法问题，可以通过维护对不同面额钞票的计数来解决。我们需要确保在每次交易中都能给顾客正确地找零。下面是解决这个问题的步骤：

1. 初始化两个变量，分别用于追踪手头上的 5 美元和 10 美元钞票数量（初始时都为 0）。
2. 遍历 bills 数组，对于每个 bill：
   - 如果 bill 是 5 美元，增加 5 美元钞票的数量。
   - 如果 bill 是 10 美元，需要检查是否有 5 美元钞票来找零。如果有，减少 5 美元钞票的数量，增加 10 美元钞票的数量；如果没有，返回 false。
   - 如果 bill 是 20 美元，首先尝试使用一张 10 美元和一张 5 美元钞票找零。如果不行，尝试使用三张 5 美元钞票。如果都不行，返回 false。
3. 如果能够成功遍历完整个数组，则返回 true。

```python
def lemonadeChange(bills):
    five, ten = 0, 0  # 初始化 5 美元和 10 美元的计数
    for bill in bills:
        if bill == 5:  # 如果顾客支付 5 美元
            five += 1
        elif bill == 10:  # 如果顾客支付 10 美元
            if five == 0:  # 没有 5 美元找零
                return False
            five -= 1
            ten += 1
        else:  # 如果顾客支付 20 美元
            if ten > 0 and five > 0:  # 优先使用 10 美元和 5 美元找零
                ten -= 1
                five -= 1
            elif five >= 3:  # 否则尝试使用三张 5 美元找零
                five -= 3
            else:
                return False
    return True
```

#### 时间和空间复杂度分析：

- 时间复杂度：O(n)，其中 n 是 bills 数组的长度。我们需要遍历一次数组。
- 空间复杂度：O(1)，我们只需要常数级别的额外空间来存储 5 美元和 10 美元的计数。

#### 常见错误或困难：

- 在处理 20 美元的情况时，首先要尝试用一张 10 美元和一张 5 美元的组合来找零，这是因为这样可以更有效地保留 5 美元的钞票，以便于后面的找零。
- 如果顾客支付了 20 美元，但手头上没有足够的零钱找零，就直接返回 false。

---

### [406.根据身高重建队列](https://leetcode.com/problems/queue-reconstruction-by-height/description/)

假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。

请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。

**示例 1：**

输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]

**输出：**[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]

**解释：**

编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。

编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。

编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。

编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。

编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。

编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。

因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。

**示例 2：**

输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]

**输出：**[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]

**提示：**

- `1 <= people.length <= 2000`
- `0 <= hi <= 106`
- `0 <= ki < people.length`
- 题目数据确保队列可以被重建

#### 解题思路：

这个问题可以通过贪心算法来解决。首先，我们需要理解题目的核心要求：对于每个人 `[h, k]`，在他前面应该恰好有 `k` 个人的身高大于或等于 `h`。基于这个条件，我们可以采取以下步骤来解决这个问题：

1. 先按照身高降序排列数组 `people`。在身高相同的情况下，按照 `k` 升序排列。
2. 初始化一个空数组 `queue` 用来构建最终的队列。
3. 遍历排好序的 `people` 数组，对于每个 `[h, k]`，将其插入到 `queue` 的第 `k` 个位置。

为什么这个策略有效呢？因为按身高降序排序后，我们首先放置的是最高的人。当放置同样高度的人时，由于他们的 `k` 值是升序的，因此我们可以直接按照 `k` 值插入到 `queue` 中。对于较矮的人，由于他们只会计算比他们高或相等的人数，因此插入他们时，较高的人已经在正确的位置，不会影响较矮的人的相对位置。

下面是这个逻辑的 Python 实现，并加上中文注释：

```python
def reconstructQueue(people):
    # 按身高降序排列，身高相同则按 k 升序排列
    people.sort(key=lambda x: (-x[0], x[1]))
    queue = []
    for p in people:
        # 将每个人插入到队列的第 k 个位置
        queue.insert(p[1], p)
    return queue

# 测试
print(reconstructQueue([[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]))
print(reconstructQueue([[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]))
```

#### 时间和空间复杂度分析：

- 时间复杂度：O(n log n) + O(n^2)，其中 O(n log n) 是排序的时间复杂度，O(n^2) 是因为插入操作的时间复杂度。对于每个人，我们需要 O(n) 的时间将其插入队列。
- 空间复杂度：O(n)，用于存储最终的队列。

#### 常见错误或困难：

- 没有按照正确的排序策略进行排序。正确的策略是先按身高降序，再按 `k` 值升序。
- 在插入过程中没有正确地处理 `k` 值。应该将人插入到队列的第 `k` 个位置。

这个问题的关键在于理解如何通过排序来简化插入的复杂性。排序后，我们能够保证在每一步插入操作中，所有已经在队列中的人都是比当前正在插入的人高的，因此我们可以直接根据 `k` 值插入到正确的位置。

---

### [452. 用最少数量的箭引爆气球](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/description/)

有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。

一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `x``start`，`x``end`， 且满足  `xstart ≤ x ≤ x``end`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。

给你一个数组 `points` ，*返回引爆所有气球所必须射出的 **最小** 弓箭数* 。

**示例 1：**

输入：points = [[10,16],[2,8],[1,6],[7,12]]

输出：2

解释：气球可以用2支箭来爆破:

\-在x = 6处射出箭，击破气球[2,8]和[1,6]。

\-在x = 11处发射箭，击破气球[10,16]和[7,12]。

**示例 2：**

输入：points = [[1,2],[3,4],[5,6],[7,8]]

输出：4

解释：每个气球需要射出一支箭，总共需要4支箭。

**示例 3：**

输入：points = [[1,2],[2,3],[3,4],[4,5]]

输出：2

解释：气球可以用2支箭来爆破:

- 在x = 2处发射箭，击破气球[1,2]和[2,3]。
- 在x = 4处射出箭，击破气球[3,4]和[4,5]。

**提示:**

- `1 <= points.length <= 105`
- `points[i].length == 2`
- `-231 <= xstart < xend <= 231 - 1`

#### 解题思路：

这个问题是一个区间问题，可以通过贪心算法来解决。核心思想是优先考虑气球重叠区域最小的部分，这样可以用最少的箭引爆最多的气球。

解决步骤如下：

1. 将所有气球按照结束坐标升序排序。
2. 遍历排序后的气球数组。使用一个变量记录当前的箭射出的位置，初始时这个位置是第一个气球的结束坐标。
3. 对于每个气球，如果它的起始坐标大于当前箭的位置，这意味着需要额外射出一支箭，更新箭的位置为这个气球的结束坐标。
4. 最后返回所需的箭的数量。

```python
def findMinArrowShots(points):
    if not points:
        return 0

    # 按照气球的结束坐标升序排序
    points.sort(key=lambda x: x[1])
    count = 1  # 至少需要一支箭
    arrow_pos = points[0][1]  # 第一支箭的位置

    for x_start, x_end in points:
        # 如果当前气球的起始位置大于箭的位置，射出新的箭，并更新箭的位置
        if x_start > arrow_pos:
            count += 1
            arrow_pos = x_end

    return count

# 测试
print(findMinArrowShots([[10,16],[2,8],[1,6],[7,12]]))  # 应该返回 2
print(findMinArrowShots([[1,2],[3,4],[5,6],[7,8]]))  # 应该返回 4
print(findMinArrowShots([[1,2],[2,3],[3,4],[4,5]]))  # 应该返回 2
```

#### 时间和空间复杂度分析：

- 时间复杂度：O(n log n)，其中 n 是 `points` 数组的长度。这是因为我们需要对数组进行排序。
- 空间复杂度：O(1)，我们只需要常数级别的额外空间。

#### 常见错误或困难：

- 没有正确排序气球。必须按照气球的结束坐标排序，这样可以确保尽可能多的气球被一支箭引爆。
- 在遍历气球时没有正确处理箭的位置。必须在当前箭无法引爆新气球时射出新的箭，并更新箭的位置。

这个问题的关键在于理解如何通过排序和贪心算法减少所需的箭的数量。通过排序，我们可以很容易地找出哪些气球可以被同一支箭引爆，从而最小化所需的箭的总数。

#### 代码随想录算法训练营第三十六天 | 435. 无重叠区间, 763.划分字母区间, 56. 合并区间

#### ● day 36 任务以及具体安排：[第八章 贪心算法 part05](https://docs.qq.com/doc/DUERGbnhhRkFRVENZ) (1.17)

# 第八章 贪心算法 part05

●  435. 无重叠区间

●  763.划分字母区间

●  56. 合并区间

详细布置

今天的三道题目，都算是 重叠区间 问题，大家可以好好感受一下。 都属于那种看起来好复杂，但一看贪心解法，惊呼：这么巧妙！

还是属于那种，做过了也就会了，没做过就很难想出来。

不过大家把如下三题做了之后， 重叠区间 基本上差不多了

435. 无重叠区间

[代码随想录](https://programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html)

763.划分字母区间

[代码随想录](https://programmercarl.com/0763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html)

56. 合并区间

本题相对来说就比较难了。

[代码随想录](https://programmercarl.com/0056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html)

[ChatGPT](https://chat.openai.com/share/97b528d7-dc9a-402b-87b0-b542132289ad)

---

### [435. 无重叠区间](https://leetcode.com/problems/non-overlapping-intervals/description/)

给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 *需要移除区间的最小数量，使剩余区间互不重叠* 。

**示例 1:**

**输入:** intervals = [[1,2],[2,3],[3,4],[1,3]]

**输出:** 1

**解释:** 移除 [1,3] 后，剩下的区间没有重叠。

**示例 2:**

**输入:** intervals = [ [1,2], [1,2], [1,2] ]

**输出:** 2

**解释:** 你需要移除两个 [1,2] 来使剩下的区间没有重叠。

**示例 3:**

**输入:** intervals = [ [1,2], [2,3] ]

**输出:** 0

**解释:** 你不需要移除任何区间，因为它们已经是无重叠的了。

**提示:**

- `1 <= intervals.length <= 105`
- `intervals[i].length == 2`
- `-5 * 104 <= starti < endi <= 5 * 104`

#### 解题思路：

这个问题是一个典型的贪心算法问题。我们需要找出最小数量的区间，使得移除它们之后，剩下的区间互不重叠。下面是解决这个问题的步骤：

1. **排序**：首先，根据区间的结束时间对区间进行排序。这样做的原因是，选择结束时间早的区间，留给其他区间的空间就越大，因此后续出现重叠的可能性就越小。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20230201164134.png)

2. **贪心选择**：接下来，我们遍历每个区间，如果一个区间与前一个区间重叠（即它的开始时间小于前一个区间的结束时间），我们就需要移除一个区间。为了保留更多的空间，我们总是移除结束时间晚的那个区间（在我们的排序策略下，这意味着移除当前考察的区间）。
3. **计数**：每次移除一个区间时，计数器加一。最终，计数器的值就是需要移除的区间的最小数量。

```python
def eraseOverlapIntervals(intervals):
    if not intervals:
        return 0

    # 根据区间的结束时间进行排序
    intervals.sort(key=lambda x: x[1])

    count = 0  # 需要移除的区间数量
    end = intervals[0][1]  # 当前不重叠区间的结束时间

    for i in range(1, len(intervals)):
        if intervals[i][0] < end:
            # 如果当前区间与前一个区间重叠，则需要移除一个区间
            count += 1
        else:
            # 更新不重叠区间的结束时间
            end = intervals[i][1]

    return count

# 测试示例
print(eraseOverlapIntervals([[1,2],[2,3],[3,4],[1,3]]))  # 输出: 1
print(eraseOverlapIntervals([[1,2], [1,2], [1,2]]))      # 输出: 2
print(eraseOverlapIntervals([[1,2], [2,3]]))             # 输出: 0
```

#### 时间复杂度和空间复杂度分析：

- 时间复杂度：O(NlogN)，主要是排序的时间复杂度，其中 N 是区间的数量。
- 空间复杂度：O(1)，只使用了常数级别的额外空间。

#### 常见错误或难点：

- 不正确的排序策略：一些解决方案可能会根据区间的开始时间排序，但这不是最优策略。
- 忽略对空输入的处理：当输入数组为空时，应返回 0，因为没有区间需要移除。

这种贪心算法的关键在于正确地选择区间，以及理解为何根据结束时间排序是最优的策略。

---

### [763.划分字母区间](https://leetcode.com/problems/partition-labels/description/)

给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。

返回一个表示每个字符串片段的长度的列表。

**示例 1：**

输入：s = "ababcbacadefegdehijhklij"

**输出：**[9,7,8]

**解释：**

划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。

每个字母最多出现在一个片段中。

像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。

**示例 2：**

输入：s = "eccbbbbdec"

**输出：**[10]

**提示：**

- `1 <= s.length <= 500`
- `s` 仅由小写英文字母组成

#### 解题思路：

要解决这个问题，我们可以遵循以下步骤：

1. **建立映射**：首先遍历字符串，为每个字符建立一个映射，记录该字符最后一次出现的位置。
2. **扫描并划分**：再次遍历字符串，并用一个变量跟踪当前片段的最远结束位置。当遍历到一个字符时，更新当前片段的结束位置为该字符最远出现位置和当前记录的结束位置中较大的一个。
3. **判断划分点**：遍历到的位置与当前片段的结束位置相同时，就找到了一个划分点。记录这个片段的长度，并开始寻找下一个片段。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201222191924417.png)

```python
def partitionLabels(s):
    last = {c: i for i, c in enumerate(s)}  # 建立字符到最后出现位置的映射
    end = start = 0
    ans = []

    for i, c in enumerate(s):
        end = max(end, last[c])  # 更新当前片段的最远结束位置
        if i == end:
            # 找到划分点，记录片段长度
            ans.append(i - start + 1)
            start = i + 1  # 更新下一个片段的起始位置

    return ans

# 测试示例
print(partitionLabels("ababcbacadefegdehijhklij"))  # 输出: [9,7,8]
print(partitionLabels("eccbbbbdec"))               # 输出: [10]
```

#### 时间复杂度和空间复杂度分析：

- 时间复杂度：O(N)，其中 N 是字符串的长度。我们需要两次遍历字符串，每次 O(N)。
- 空间复杂度：O(1)，映射所用的空间大小与字符集的大小有关，在本题中字符集为小写英文字母，因此是常数空间。

#### 常见错误或难点：

- 错误地划分字符串，导致同一个字母出现在多个片段中。
- 未能正确更新片段的最远结束位置。

这个问题的关键在于找到每个片段的确切结束位置，确保所有的字符都在正确的片段中。

---

### [56. 合并区间](https://leetcode.com/problems/merge-intervals/description/)

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

**示例 1：**

输入：intervals = [[1,3],[2,6],[8,10],[15,18]]

**输出：**[[1,6],[8,10],[15,18]]

解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

**示例 2：**

输入：intervals = [[1,4],[4,5]]

**输出：**[[1,5]]

解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。

**提示：**

- `1 <= intervals.length <= 104`
- `intervals[i].length == 2`
- `0 <= starti <= endi <= 104`

#### 解题思路：

要解决这个问题，我们可以采用排序和贪心算法的思路。基本步骤如下：

1. **排序**：首先按照区间的起始位置对区间进行排序。这样做的目的是将可能重叠的区间放置在一起，方便后续的合并操作。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201223200632791.png)

2. **合并区间**：然后遍历排序后的区间列表，对于每个区间，如果它与前一个区间重叠（即当前区间的起始位置小于或等于前一个区间的结束位置），则将它们合并。合并的方式是更新当前合并区间的结束位置为两个区间结束位置的较大值。
3. **构建结果**：如果当前区间不与前一个区间重叠，那么就将前一个合并区间添加到结果列表中，并开始一个新的合并区间。

```python
def merge(intervals):
    if not intervals:
        return []

    # 根据区间起始位置排序
    intervals.sort(key=lambda x: x[0])
    merged = []

    for interval in intervals:
        # 如果列表为空，或者当前区间与前一个区间不重叠，则直接添加
        if not merged or merged[-1][1] < interval[0]:
            merged.append(interval)
        else:
            # 否则，有重叠，合并当前区间和前一个区间
            merged[-1][1] = max(merged[-1][1], interval[1])

    return merged

# 测试示例
print(merge([[1,3],[2,6],[8,10],[15,18]]))  # 输出: [[1,6],[8,10],[15,18]]
print(merge([[1,4],[4,5]]))                 # 输出: [[1,5]]
```

#### 时间复杂度和空间复杂度分析：

- 时间复杂度：O(NlogN)，其中 N 是区间的数量。主要时间花费在排序上，排序的时间复杂度是 O(NlogN)，遍历合并区间的时间复杂度是 O(N)。
- 空间复杂度：O(logN) 或 O(N)，取决于排序实现的空间复杂度。例如，如果使用的是堆排序，空间复杂度为 O(1)；如果使用的是归并排序，空间复杂度为 O(N)。

#### 常见错误或难点：

- 不正确地处理重叠区间：重叠区间的合并需要更新结束位置为两个区间结束位置的较大值。
- 忽略排序步骤：未对区间按起始位置排序会导致无法正确识别所有重叠区间。

---

### 区间排序总结：

当然，让我们通过今天讨论的三道区间问题来深入理解什么时候使用起始位置排序，什么时候使用结束位置排序，以及各自的优缺点。

### 1. 无重叠区间（问题 435）

- **问题概述**：给定多个区间，求移除最少的区间数量使剩下的区间互不重叠。
- **排序策略**：按结束位置排序。
- **原因**：为了使剩下的区间数量最大化，我们需要保留结束时间早的区间，因为它们留给其他区间的空间更大，减少了重叠的可能性。
- **优点**：更容易找到最优解，即最大化保留的区间数量。
- **缺点**：不适用于需要明确区间起始顺序的问题。

### 2. 划分字母区间（问题 763）

- **问题概述**：划分字符串，使得每个字符最多出现在一个片段中。
- **排序策略**：实际上这个问题不涉及到对区间的排序，而是通过映射字符最后出现位置来确定切分点。
- **原因**：这个问题关注的是字符在字符串中的出现位置，目的是最小化片段数，同时保证字符不在多个片段中重复出现。
- **优点**：能够准确地划分出满足条件的最小片段数。
- **缺点**：需要额外的空间来存储字符的最后出现位置。

### 3. 合并区间（问题 56）

- **问题概述**：合并所有重叠的区间。
- **排序策略**：按起始位置排序。
- **原因**：按起始位置排序可以将可能重叠的区间放在一起，方便合并。这样做可以保证在遍历排序后的区间时，每个区间只需要和它前面的区间比较是否重叠。
- **优点**：能够有效地合并重叠区间，简化合并逻辑。
- **缺点**：不适用于需要优化其他方面（如区间长度、空间利用率等）的问题。

### 总结

- **起始位置排序** 适用于需要按顺序合并或处理区间的问题，如合并重叠区间。
- **结束位置排序** 更适合于需要优化区间覆盖或利用率的问题，如寻找最少的区间来避免重叠。
- 每种策略都有其特定的应用场景，选择合适的排序策略对于高效解决问题至关重要。

#### 代码随想录算法训练营第三十七天 | 738.单调递增的数字，968.监控二叉树，总结

#### ● day 37 任务以及具体安排：[第八章 贪心算法 part06](https://docs.qq.com/doc/DUFVRd3p5SHFMSExQ) (1.18)

# 第八章 贪心算法 part06

●  738.单调递增的数字

●  968.监控二叉树

●  总结

详细布置

738.单调递增的数字

[代码随想录](https://programmercarl.com/0738.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97.html)

968.监控二叉树 （可以跳过）

本题是贪心和二叉树的一个结合，比较难，一刷大家就跳过吧。

[代码随想录](https://programmercarl.com/0968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html)

总结

可以看看贪心算法的总结，贪心本来就没啥规律，能写出个总结篇真的不容易了。

[代码随想录](https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E7%AF%87.html)

[ChatGPT](https://chat.openai.com/share/4f82d6ea-d225-461e-aeb0-ae4a7190bf34)

---

### [738.单调递增的数字](https://leetcode.com/problems/monotone-increasing-digits/description/)

当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是**单调递增**的。

给定一个整数 `n` ，返回 *小于或等于 `n` 的最大数字，且数字呈 **单调递增*** 。

**示例 1:**

**输入:** n = 10

**输出:** 9

**示例 2:**

**输入:** n = 1234

**输出:** 1234

**示例 3:**

**输入:** n = 332

**输出:** 299

**提示:**

- `0 <= n <= 109`

#### 解题思路：

- 从右向左遍历数字，比较相邻的两个数字。
- 当发现前一个数字大于后一个数字时，将前一个数字减一，并且将该数字右边的所有数字改为9，以保持单调递增。
- 继续向左遍历直到处理完所有数字。

```python
def monotoneIncreasingDigits(n):
    nums = list(str(n))
    # 标记从右到左，最后一个违反单调递增的位置
    flag = len(nums)
    for i in range(len(nums) - 1, 0, -1):
        if nums[i] < nums[i - 1]:
            flag = i
            nums[i - 1] = str(int(nums[i - 1]) - 1)
    
    for i in range(flag, len(nums)):
        nums[i] = '9'
    
    return int(''.join(nums))

# 示例
print(monotoneIncreasingDigits(10))  # 9
print(monotoneIncreasingDigits(1234))  # 1234
print(monotoneIncreasingDigits(332))  # 299
```

**时间和空间复杂度**：

- 时间复杂度：O(N)，其中 N 是数字的位数。
- 空间复杂度：O(N)，因为我们将数字转换成字符数组来处理。

**常见错误**：

- 未考虑将前一个数字减一后，右边数字需要全改为9的情况。
- 边界处理不当，例如输入数字为0或最大值时。

---

### [968.监控二叉树](https://leetcode.com/problems/binary-tree-cameras/description/)

给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视**其父对象、自身及其直接子对象。**

计算监控树的所有节点所需的最小摄像头数量。

**示例 1：**

![Image.png](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_01.png)

**输入：**[0,0,null,0,0]

输出：1

解释：如图所示，一台摄像头足以监控所有节点。

**示例 2：**

![Image.png](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/bst_cameras_02.png)

**输入：**[0,0,null,0,null,0,null,null,0]

输出：2

解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。

**提示：**

1. 给定树的节点数的范围是 `[1, 1000]`。
2. 每个节点的值都是 0。

#### 解题思路：

这个问题是关于在二叉树中安装摄像头以监控所有节点的最小数量。我们可以采用一种递归的策略来解决这个问题。我们可以为每个节点定义三种状态：

1. **状态 0**：节点没有被摄像头覆盖。
2. **状态 1**：节点安装了摄像头。
3. **状态 2**：节点没有安装摄像头，但是被摄像头覆盖。

对于每个节点，我们递归地处理它的左右子节点。然后，根据子节点的状态来确定当前节点的最优状态。这里的“最优”是指在满足所有节点都被覆盖的前提下，使用的摄像头数量最小。

解题步骤如下：

1. **递归函数定义**：对于每个节点，返回一个大小为 3 的数组，表示三种状态下的最小摄像头数量。
2. **递归终止条件**：如果遇到空节点，则返回 `[0, 0, float('inf')]`。这意味着空节点不需要摄像头，也不会增加摄像头的数量，但自身不能放摄像头。
3. **递归逻辑**：
   - 首先递归处理左右子节点。
   - 然后根据左右子节点返回的数组，计算当前节点的三种状态下的最小摄像头数量。
4. **返回结果**：最后返回根节点状态 1 和状态 2 中的最小值，因为根节点不能是状态 0（即没有被覆盖）。

```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def minCameraCover(root):
    def dfs(node):
        if not node:
            return [0, 0, float('inf')]
        left = dfs(node.left)
        right = dfs(node.right)
        dp0 = left[1] + right[1]
        dp1 = min(left[2] + min(right[1], right[2]), right[2] + min(left[1], left[2]))
        dp2 = 1 + min(left) + min(right)
        return [dp0, dp1, dp2]

    return min(dfs(root)[1:])

# 示例代码使用
# 构建示例二叉树，对应题目中的示例
root = TreeNode(0)
root.left = TreeNode(0)
root.left.left = TreeNode(0)
root.left.left.left = TreeNode(0)
root.left.left.right = TreeNode(0)

print(minCameraCover(root))  # 输出应该为 2
```

**时间和空间复杂度分析**：

- 时间复杂度：O(N)，其中 N 是树中的节点数量。我们需要遍历每个节点来确定其状态。
- 空间复杂度：O(H)，其中 H 是树的高度，这是因为递归栈的深度由树的高度决定。

**注意事项**：

- 递归过程中要正确处理每个节点的三种状态。
- 考虑到根节点不能是状态 0，所以最后的结果是根节点状态 1 和状态 2 中的最小值。
- 空节点不需要摄像头，也不会增加摄像头数量，但自身不能放摄像头。

---

## 贪心算法总结篇

### 贪心简单题

以下三道题目就是简单题，大家会发现贪心感觉就是常识。是的，如下三道题目，就是靠常识，但我都具体分析了局部最优是什么，全局最优是什么，贪心也要贪的有理有据！

- [贪心算法：分发饼干(opens new window)](https://programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html)
- [贪心算法：K次取反后最大化的数组和(opens new window)](https://programmercarl.com/1005.K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C.html)
- [贪心算法：柠檬水找零(opens new window)](https://programmercarl.com/0860.%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html)

### 贪心中等题

贪心中等题，靠常识可能就有点想不出来了。开始初现贪心算法的难度与巧妙之处。

- [贪心算法：摆动序列(opens new window)](https://programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html)
- [贪心算法：单调递增的数字(opens new window)](https://programmercarl.com/0738.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97.html)

### 贪心解决股票问题

大家都知道股票系列问题是动规的专长，其实用贪心也可以解决，而且还不止就这两道题目，但这两道比较典型，我就拿来单独说一说

- [贪心算法：买卖股票的最佳时机II(opens new window)](https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html)
- [贪心算法：买卖股票的最佳时机含手续费 (opens new window)](https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9.html)本题使用贪心算法比较绕，建议后面学习动态规划章节的时候，理解动规就好

### 两个维度权衡问题

在出现两个维度相互影响的情况时，两边一起考虑一定会顾此失彼，要先确定一个维度，再确定另一个一个维度。

- [贪心算法：分发糖果(opens new window)](https://programmercarl.com/0135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html)
- [贪心算法：根据身高重建队列(opens new window)](https://programmercarl.com/0406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html)

在讲解本题的过程中，还强调了编程语言的重要性，模拟插队的时候，使用C++中的list（链表）替代了vector(动态数组)，效率会高很多。

所以在[贪心算法：根据身高重建队列（续集） (opens new window)](https://programmercarl.com/%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97%EF%BC%88vector%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3%EF%BC%89.html)详细讲解了，为什么用list（链表）更快！

**大家也要掌握自己所用的编程语言，理解其内部实现机制，这样才能写出高效的算法！**

### 贪心难题

这里的题目如果没有接触过，其实是很难想到的，甚至接触过，也一时想不出来，所以题目不要做一遍，要多练！

### 贪心解决区间问题

关于区间问题，大家应该印象深刻，有一周我们专门讲解的区间问题，各种覆盖各种去重。

- [贪心算法：跳跃游戏(opens new window)](https://programmercarl.com/0055.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.html)
- [贪心算法：跳跃游戏II(opens new window)](https://programmercarl.com/0045.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII.html)
- [贪心算法：用最少数量的箭引爆气球(opens new window)](https://programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html)
- [贪心算法：无重叠区间(opens new window)](https://programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html)
- [贪心算法：划分字母区间(opens new window)](https://programmercarl.com/0763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html)
- [贪心算法：合并区间(opens new window)](https://programmercarl.com/0056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html)

### 其他难题

[贪心算法：最大子序和 (opens new window)](https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html)其实是动态规划的题目，但贪心性能更优，很多同学也是第一次发现贪心能比动规更优的题目。

[贪心算法：加油站 (opens new window)](https://programmercarl.com/0134.%E5%8A%A0%E6%B2%B9%E7%AB%99.html)可能以为是一道模拟题，但就算模拟其实也不简单，需要把while用的很娴熟。但其实是可以使用贪心给时间复杂度降低一个数量级。

最后贪心系列压轴题目[贪心算法：我要监控二叉树！ (opens new window)](https://programmercarl.com/0968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html)，不仅贪心的思路不好想，而且需要对二叉树的操作特别娴熟，这就是典型的交叉类难题了。

### 贪心每周总结

周总结里会对每周的题目中大家的疑问、相关难点或者笔误之类的进行复盘和总结。

如果大家发现文章哪里有问题，那么在周总结里或者文章评论区一定进行了修正，保证不会因为我的笔误或者理解问题而误导大家。

所以周总结一定要看！

- [本周小结！（贪心算法系列一）(opens new window)](https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201126%E8%B4%AA%E5%BF%83%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html)
- [本周小结！（贪心算法系列二）(opens new window)](https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201203%E8%B4%AA%E5%BF%83%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html)
- [本周小结！（贪心算法系列三）(opens new window)](https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201217%E8%B4%AA%E5%BF%83%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html)
- [本周小结！（贪心算法系列四）(opens new window)](https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20201224%E8%B4%AA%E5%BF%83%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html)

### 总结

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/%E8%B4%AA%E5%BF%83%E6%80%BB%E7%BB%93water.png)

### 第九章：动态规划

#### 代码随想录算法训练营第三十八天 | 理论基础，509. 斐波那契数，70. 爬楼梯，746. 使用最小花费爬楼梯

#### ● day 38 任务以及具体安排：[第九章 动态规划part01](https://docs.qq.com/doc/DUGNUdVpoT0VJR01l) (1.19)

# 第九章 动态规划part01

●  理论基础

●  509. 斐波那契数

●  70. 爬楼梯

●  746. 使用最小花费爬楼梯

详细布置

今天正式开始动态规划！

理论基础

无论大家之前对动态规划学到什么程度，一定要先看 我讲的 动态规划理论基础。

如果没做过动态规划的题目，看我讲的理论基础，会有感觉 是不是简单题想复杂了？

其实并没有，我讲的理论基础内容，在动规章节所有题目都有运用，所以很重要！

如果做过动态规划题目的录友，看我的理论基础 就会感同身受了。

[代码随想录](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)

视频：[https://www.bilibili.com/video/BV13Q4y197Wg](https://www.bilibili.com/video/BV13Q4y197Wg)

509. 斐波那契数

很简单的动规入门题，但简单题使用来掌握方法论的，还是要有动规五部曲来分析。

[代码随想录](https://programmercarl.com/0509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.html)

视频：[https://www.bilibili.com/video/BV1f5411K7mo](https://www.bilibili.com/video/BV1f5411K7mo)

70. 爬楼梯

本题大家先自己想一想， 之后会发现，和 斐波那契数 有点关系。

[代码随想录](https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html)

视频：[https://www.bilibili.com/video/BV17h411h7UH](https://www.bilibili.com/video/BV17h411h7UH)

746. 使用最小花费爬楼梯

这道题目力扣改了题目描述了，现在的题目描述清晰很多，相当于明确说 第一步是不用花费的。

更改题目描述之后，相当于是 文章中 「拓展」的解法

[代码随想录](https://programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html)

视频讲解：[https://www.bilibili.com/video/BV16G411c7yZ](https://www.bilibili.com/video/BV16G411c7yZ)

#### 动态规划理论基础

#### 问题类型

- 背包问题
- 打家劫舍
- 股票问题
- 子序列问题

**对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！**

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

**做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。

然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。

如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。

如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。

**这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了**。

[ChatGPT](https://chat.openai.com/share/75766ae5-bf9f-42f0-ae6f-5d4247d8182f)

---

### [509. 斐波那契数](https://leetcode.com/problems/fibonacci-number/description/)

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1

F(n) = F(n - 1) + F(n - 2)，其中 n > 1

给定 `n` ，请计算 `F(n)` 。

**示例 1：**

输入：n = 2

输出：1

解释：F(2) = F(1) + F(0) = 1 + 0 = 1

**示例 2：**

输入：n = 3

输出：2

解释：F(3) = F(2) + F(1) = 1 + 1 = 2

**示例 3：**

输入：n = 4

输出：3

解释：F(4) = F(3) + F(2) = 2 + 1 = 3

**提示：**

- `0 <= n <= 30`

这个问题是关于计算斐波那契数列中第 `n` 个数的值。斐波那契数列是一个经典的递归问题，但递归解法效率低下，因为它包含大量的重复计算。一个更高效的解法是使用动态规划或迭代方法。

#### 解题思路

1. **递归法（效率低）**：直接根据定义递归计算 `F(n) = F(n-1) + F(n-2)`，但当 `n` 较大时，会有很多重复计算，导致效率低下。
2. **动态规划**：创建一个数组，存储从 0 到 `n` 的斐波那契数。首先填充初始值 `F(0)` 和 `F(1)`，然后从 2 迭代到 `n`，每次计算 `F(i)`，并存储在数组中。
3. **迭代法**：使用两个变量存储 `F(n-1)` 和 `F(n-2)` 的值，并在每次迭代中更新这两个变量。这种方法空间复杂度更低。

这里是迭代法的实现。

```python
def fibonacci(n):
    if n <= 1:
        return n
    a, b = 0, 1
    for i in range(2, n + 1):
        a, b = b, a + b
    return b

# 测试用例
print(fibonacci(2))  # 输出：1
print(fibonacci(3))  # 输出：2
print(fibonacci(4))  # 输出：3
```

#### 复杂度分析

- 时间复杂度：O(n)，只需要遍历一次即可。
- 空间复杂度：O(1)，使用了固定数量的额外空间。

#### 常见错误

- 不处理好基本情况，比如 `n = 0` 或 `n = 1` 时的情况。
- 在递归法中没有使用记忆化，导致效率极低。

---

### [70. 爬楼梯](https://leetcode.com/problems/climbing-stairs/description/)

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1：**

输入：n = 2

输出：2

解释：有两种方法可以爬到楼顶。

1. 1 阶 + 1 阶
2. 2 阶

**示例 2：**

输入：n = 3

输出：3

解释：有三种方法可以爬到楼顶。

1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶

**提示：**

- `1 <= n <= 45`

爬楼梯问题是一个经典的动态规划问题。这个问题可以通过观察每一步的可能性来简化。对于爬到第 `n` 阶楼梯，有两种方式：从第 `n-1` 阶爬一阶上来，或者从第 `n-2` 阶爬两阶上来。因此，到达第 `n` 阶的方法总数就是到达第 `n-1` 阶和第 `n-2` 阶方法数的和。

#### 解题思路

1. **基础情况**：如果 `n` 是 1 或 2，答案分别是 1 和 2，因为只有一种或两种方式上楼。
2. **递归法（效率较低）**：直接使用递归公式 `f(n) = f(n-1) + f(n-2)`，但会有很多重复计算。
3. **动态规划**：创建一个数组，存储到达每一阶的方法数。从第 3 阶开始迭代，直到第 `n` 阶。
4. **迭代法**：使用两个变量来存储前两个状态（即 `f(n-1)` 和 `f(n-2)`），在每次迭代中更新这两个变量。

这里使用动态规划的迭代方法来实现：

```python
def climbStairs(n):
    if n <= 2:
        return n
    a, b = 1, 2
    for i in range(3, n + 1):
        a, b = b, a + b
    return b

# 测试用例
print(climbStairs(2))  # 输出：2
print(climbStairs(3))  # 输出：3
```

#### 复杂度分析

- 时间复杂度：O(n)，只需要遍历一次。
- 空间复杂度：O(1)，只使用了有限的额外空间。

#### 常见错误

- 在处理边界情况时出错，如不正确处理 `n = 1` 或 `n = 2` 的情况。
- 在递归解法中没有使用记忆化导致时间复杂度过高。

---

### [746. 使用最小花费爬楼梯](https://leetcode.com/problems/min-cost-climbing-stairs/description/)

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

**示例 1：**

输入：cost = [10,***15***,20]

输出：15

解释：你将从下标为 1 的台阶开始。

- 支付 15 ，向上爬两个台阶，到达楼梯顶部。

总花费为 15 。

**示例 2：**

输入：cost = [***1***,100,***1***,1,***1***,100,***1***,***1***,100,***1***]

输出：6

解释：你将从下标为 0 的台阶开始。

- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。

总花费为 6 。

**提示：**

- `2 <= cost.length <= 1000`
- `0 <= cost[i] <= 999`

这个问题是关于找到爬楼梯的最低成本的动态规划问题。与传统的爬楼梯问题不同的是，这里每一步都有一个成本，并且可以选择从第一个或第二个台阶开始。

#### 解题思路

1. **动态规划**：创建一个数组 `dp`，其中 `dp[i]` 表示达到第 `i` 个台阶的最小成本。
2. **状态转移方程**：要到达第 `i` 个台阶，可以从第 `i-1` 个台阶爬上来，也可以从第 `i-2` 个台阶爬上来。因此，`dp[i]` 等于 `dp[i-1]` 和 `dp[i-2]` 中的较小者加上当前台阶的成本 `cost[i]`。
3. **初始化**：可以从第 0 个或第 1 个台阶开始，因此 `dp[0] = cost[0]`，`dp[1] = cost[1]`。
4. **迭代**：从第 2 个台阶开始，根据状态转移方程计算每个台阶的最小成本。
5. **结果**：最终结果是 `dp` 数组最后两个元素的最小值，因为可以结束在最后一个台阶或者超过最后一个台阶。

```python
def minCostClimbingStairs(cost):
    # 获取楼梯的总层数
    n = len(cost)
    # 初始化动态规划数组，dp[i] 表示达到第 i 个台阶的最小成本
    dp = [0] * n
    # 可以选择从第一个或第二个台阶开始，因此初始化 dp[0] 和 dp[1]
    dp[0], dp[1] = cost[0], cost[1]
    # 从第 2 个台阶开始计算到达每个台阶的最小成本
    for i in range(2, n):
        # dp[i] 是到达第 i-1 或 i-2 个台阶的最小成本加上当前台阶的成本
        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]
    # 最终结果是到达最后一个台阶或者超过最后一个台阶的最小成本
    return min(dp[-1], dp[-2])

# 测试用例
print(minCostClimbingStairs([10, 15, 20]))  # 输出：15
print(minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1]))  # 输出：6
```

#### 复杂度分析

- 时间复杂度：O(n)，只需要遍历一次数组。
- 空间复杂度：O(n)，使用了一个额外的数组来存储每个台阶的最小成本。

#### 常见错误

- 没有正确处理起始台阶的成本。
- 在进行最小成本计算时，没有考虑所有可能的情况（即从 `i-1` 或 `i-2` 台阶上来）。

#### 代码随想录算法训练营第三十九天 | 62.不同路径，63. 不同路径 II

#### ● day 39 任务以及具体安排：[第九章 动态规划part02](https://docs.qq.com/doc/DUE55cVJ5WkNoREhS) (1.20)

# 第九章 动态规划part02

●  62.不同路径

●  63. 不同路径 II

今天开始逐渐有 dp的感觉了，题目不多，就两个 不同路径，可以好好研究一下

详细布置

62.不同路径

本题大家掌握动态规划的方法就可以。 数论方法 有点非主流，很难想到。

[代码随想录](https://programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html)

视频讲解：[https://www.bilibili.com/video/BV1ve4y1x7Eu](https://www.bilibili.com/video/BV1ve4y1x7Eu)

63. 不同路径 II

[网页不存在——百度云主机服务](https://programmercarl.com/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.htmlhttps://programmercarl.com/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.html)

视频讲解：[https://www.bilibili.com/video/BV1Ld4y1k7c6](https://www.bilibili.com/video/BV1Ld4y1k7c6)

[ChatGPT](https://chat.openai.com/share/1a3c032e-410e-43f2-a947-5ffcefb49871)

---

### [62.不同路径](https://leetcode.com/problems/unique-paths/description/)

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**示例 1：**

![Image.png](https://pic.leetcode.cn/1697422740-adxmsI-image.png)

输入：m = 3, n = 7

输出：28

**示例 2：**

输入：m = 3, n = 2

输出：3

**解释：**

从左上角开始，总共有 3 条路径可以到达右下角。

1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下

**示例 3：**

输入：m = 7, n = 3

输出：28

**示例 4：**

输入：m = 3, n = 3

输出：6

**提示：**

- `1 <= m, n <= 100`
- 题目数据保证答案小于等于 `2 * 109`

这个问题是一个经典的动态规划问题。我们的目标是计算从网格的左上角到右下角有多少种不同的路径。让我们逐步解决这个问题：

#### 问题概述

- **问题描述**：一个机器人从一个 `m x n` 网格的左上角开始移动，每次只能向下或向右移动一步，计算到达右下角有多少种不同的路径。
- **示例**：例如，当 `m = 3, n = 7` 时，路径总数是 `28`。

#### 解题步骤

1. **定义状态**：我们定义 `dp[i][j]` 为到达网格位置 `(i, j)` 的路径总数。
2. **状态转移方程**：对于每个位置 `(i, j)`，机器人只能从上方 `(i-1, j)` 或左方 `(i, j-1)` 到达，因此 `dp[i][j] = dp[i-1][j] + dp[i][j-1]`。
3. **初始化**：对于第一行和第一列，机器人只有一种方式到达，因此 `dp[0][j] = 1` 和 `dp[i][0] = 1`。
4. **计算顺序**：从左上角开始，按行或列逐步计算到右下角。
5. **结果**：`dp[m-1][n-1]` 是我们需要的答案。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20201209113631392.png)

```python
def uniquePaths(m, n):
    # 初始化一个 m 行 n 列的二维数组，用于存储到达每个格子的路径数
    dp = [[1] * n for _ in range(m)]

    # 遍历数组，从第二行第二列开始计算，因为第一行和第一列的路径数都是 1
    for i in range(1, m):
        for j in range(1, n):
            # 状态转移方程：到达当前格子的路径数等于到达左边格子的路径数加上到达上面格子的路径数
            dp[i][j] = dp[i-1][j] + dp[i][j-1]

    # 返回到达右下角格子的路径数
    return dp[m-1][n-1]

# 测试示例
print(uniquePaths(3, 7))  # 应输出 28
print(uniquePaths(3, 2))  # 应输出 3
```

#### 复杂度分析

- **时间复杂度**：O(m*n)，因为需要遍历整个 `m x n` 网格。
- **空间复杂度**：O(m*n)，用于存储每个位置的路径总数。

#### 常见错误

- 不正确地初始化第一行和第一列。
解释初始化 `m x n` 二维数组的初始值为 `1` 的原因是很重要的，因为这关系到动态规划解决方案的正确性。这里的初始化步骤是基于问题的特定规则和逻辑。

在这个问题中，机器人只能向下或向右移动。当考虑到达网格的第一行和第一列的任何位置时，只存在一种路径：

1. **对于第一行**：机器人只能一直向右移动到达第一行的任何一个位置。因为它不能向上移动，所以到达第一行任意一点的路径只有一条。
2. **对于第一列**：同理，机器人只能一直向下移动到达第一列的任何一个位置。因为它不能向左移动，所以到达第一列任意一点的路径也只有一条。

因此，我们将 `dp` 数组的第一行和第一列的所有元素初始化为 `1`。这意味着到达第一行或第一列中任何位置的路径数都是 `1`。

这种初始化确保了在计算其他位置 `(i, j)` 的路径数时，`dp[i][j] = dp[i-1][j] + dp[i][j-1]` 这一状态转移方程能够正确地工作。如果我们不将第一行和第一列初始化为 `1`，那么状态转移方程在计算这些边界位置时会得到错误的结果，因为它依赖于这些边界位置的值。

- 在状态转移方程中没有考虑边界情况。

---

### [63. 不同路径 II](https://leetcode.com/problems/unique-paths-ii/description/)

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

**示例 1：**

![Image.jpg](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)

输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]

输出：2

解释：3x3 网格的正中间有一个障碍物。

从左上角到右下角一共有 `2` 条不同的路径：

1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右

**示例 2：**

![Image.jpg](https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg)

输入：obstacleGrid = [[0,1],[0,0]]

输出：1

**提示：**

- `m == obstacleGrid.length`
- `n == obstacleGrid[i].length`
- `1 <= m, n <= 100`
- `obstacleGrid[i][j]` 为 `0` 或 `1`

这个问题是 "不同路径" 问题的一个变种，其中引入了障碍物。解决这个问题仍然可以使用动态规划的方法，但需要对障碍物进行处理。

#### 问题概述

- **问题描述**：在一个 `m x n` 网格中，某些位置有障碍物。计算从左上角到右下角的不同路径数量。障碍物和空位置分别用 `1` 和 `0` 表示。
- **示例**：例如，当 `obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]` 时，路径总数是 `2`。

#### 解题步骤

1. **定义状态**：`dp[i][j]` 表示到达网格位置 `(i, j)` 的路径总数。
2. **状态转移方程**：如果位置 `(i, j)` 没有障碍物，则 `dp[i][j] = dp[i-1][j] + dp[i][j-1]`；如果有障碍物，则 `dp[i][j] = 0`。
3. **初始化**：第一行和第一列的初始化需要考虑障碍物。如果某个位置或其之前的位置有障碍物，则该位置的路径数为 `0`。
4. **计算顺序**：从左上角开始，按行或列逐步计算到右下角。
5. **结果**：`dp[m-1][n-1]` 是所求答案。

```python
def uniquePathsWithObstacles(obstacleGrid):
    m, n = len(obstacleGrid), len(obstacleGrid[0])
    dp = [[0] * n for _ in range(m)]

    # 初始化第一行和第一列
    for i in range(m):
        if obstacleGrid[i][0] == 1:
            break
        dp[i][0] = 1
    for j in range(n):
        if obstacleGrid[0][j] == 1:
            break
        dp[0][j] = 1

    # 动态规划填表
    for i in range(1, m):
        for j in range(1, n):
            if obstacleGrid[i][j] == 0:
                dp[i][j] = dp[i-1][j] + dp[i][j-1]

    return dp[m-1][n-1]

# 测试示例
print(uniquePathsWithObstacles([[0,0,0],[0,1,0],[0,0,0]]))  # 应输出 2
print(uniquePathsWithObstacles([[0,1],[0,0]]))             # 应输出 1
```

#### 复杂度分析

- **时间复杂度**：O(m*n)，因为需要遍历整个网格。
- **空间复杂度**：O(m*n)，用于存储路径数量的二维数组。

这种方法有效地处理了障碍物的存在，确保了在计算路径数时正确地考虑了障碍物的影响。

#### 疑难点：

- 为什么要专门初始化第一行和第一列并且判断是否存在障碍物吗？为什么不跳过这一步，直接像接下去的步骤一样遍历整个obstacleGrid，找到障碍物，设定障碍物以外位置的独特路径数量呢？

初始化第一行和第一列是动态规划解决这类问题的关键步骤之一，特别是在处理网格路径问题时。在 "不同路径 II" 这个问题中，由于障碍物的存在，我们不能简单地将所有的 `dp[0][j]` 和 `dp[i][0]` 设置为 `1`。我们来具体分析一下为什么需要这样做：

1. **路径的依赖性**：在动态规划中，每个格子的路径数依赖于其上方和左方的格子。特别是对于第一行和第一列，其路径数完全依赖于它们之前的格子。例如，如果 `obstacleGrid[0][3]` 是障碍物，那么 `obstacleGrid[0][4]`、`obstacleGrid[0][5]` 等位置都无法到达，因为机器人不能穿过障碍物。
2. **障碍物的影响**：障碍物的存在会中断路径。如果我们不事先初始化第一行和第一列，我们可能会错误地计算某些无法到达的格子的路径数。例如，如果第一列的某个格子是障碍物，那么这个障碍物下方的所有格子都应该被设置为 `0` 路径数，因为机器人无法到达这些位置。
3. **简化问题**：通过初始化第一行和第一列，我们可以简化接下来的动态规划过程。这样，当我们开始填充剩余的 `dp` 表时，我们可以确保所有的边界情况都已经被正确处理，不需要在后续的循环中再次检查每个格子是否位于第一行或第一列。

如果跳过这一步，直接遍历整个 `obstacleGrid` 并设置路径数，我们可能会遇到一些边界情况的处理错误，尤其是在障碍物位于第一行或第一列时。因此，初始化第一行和第一列是一个必要步骤，以确保动态规划的正确性和效率。

#### 代码随想录算法训练营第四十一天 | 343. 整数拆分，96.不同的二叉搜索树

#### ● day 41 任务以及具体安排：[第九章 动态规划part03](https://docs.qq.com/doc/DUFhIUXRFYnVGUkFp) (1.22)

# 第九章 动态规划part03

●  343. 整数拆分

●  96.不同的二叉搜索树

详细布置

今天两题都挺有难度，建议大家思考一下没思路，直接看题解，第一次做，硬想很难想出来。

343. 整数拆分

[代码随想录](https://programmercarl.com/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html)

视频讲解：[https://www.bilibili.com/video/BV1Mg411q7YJ](https://www.bilibili.com/video/BV1Mg411q7YJ)

96.不同的二叉搜索树

[代码随想录](https://programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html)

视屏讲解：[https://www.bilibili.com/video/BV1eK411o7QA](https://www.bilibili.com/video/BV1eK411o7QA)

[ChatGPT](https://chat.openai.com/share/b00eacaf-6aba-453a-a3c0-c983fc628515)

---

### [343. 整数拆分](https://leetcode.com/problems/integer-break/description/)

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

**示例 1:**

**输入:** n = 2

**输出:** 1

**解释:** 2 = 1 + 1, 1 × 1 = 1。

**示例 2:**

**输入:** n = 10

**输出:** 36

**解释:** 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。

**提示:**

- `2 <= n <= 58`

#### 解题思路：

为了解决整数拆分问题，我们可以采用动态规划的方法。下面我将详细解释这个问题的解题步骤：

1. **理解问题**：给定一个正整数 `n`，需要将其拆分为至少两个正整数的和，使得这些整数的乘积最大化。
2. **确定动态规划状态**：定义 `dp[i]` 为将正整数 `i` 拆分为至少两个正整数的和后，得到的最大乘积。
3. **确定状态转移方程**：对于每个整数 `i`，遍历所有可能的拆分方法（例如，拆分为 `j` 和 `i-j`），然后取这些拆分方法中乘积最大的一个。因此，状态转移方程为 `dp[i] = max(dp[i], j * (i-j), j * dp[i-j])`，其中 `1 <= j < i`。
4. **初始化和边界情况**：初始化 `dp[0] = dp[1] = 0`，因为 0 和 1 不能拆分成至少两个正整数的和。
5. **计算顺序**：从小到大计算 `dp[i]`。
6. **返回结果**：最后 `dp[n]` 就是我们要求的答案。

```python
def integerBreak(n):
    # 初始化dp数组
    dp = [0] * (n + 1)
    for i in range(2, n + 1):
        curMax = 0
        for j in range(1, i):
            # 更新最大乘积
            curMax = max(curMax, j * (i - j), j * dp[i - j])
        dp[i] = curMax
    return dp[n]

# 测试用例
print(integerBreak(2))  # 输出: 1
print(integerBreak(10)) # 输出: 36
```

**时间复杂度和空间复杂度分析**：

- 时间复杂度是 (O(n^2))，因为我们需要双层循环来计算 `dp` 数组。
- 空间复杂度是 (O(n))，因为我们使用了一个长度为 `n + 1` 的数组。

**常见错误**：

- 忘记初始化 `dp[0]` 和 `dp[1]`。
- 在状态转移方程中没有考虑所有的拆分情况。
- 为什么这个解法只需要考虑拆成j和i-j两个数字的情况，而不是更多数字的情况？
这个问题的核心在于理解动态规划的状态转移方程。当我们在解决整数拆分问题时，实际上是在考虑所有可能的拆分方式，而不仅仅是拆分成两个数字的情况。我将通过以下几点来解释这个过程：

1. **子问题重叠**：在动态规划中，我们把大问题拆分成小问题来求解。对于整数拆分问题，当我们考虑将整数 `i` 拆分为两部分时，这两部分分别是 `j` 和 `i-j`。这里的关键是理解，`i-j` 这部分本身就可以进一步拆分成更小的整数和。
2. **状态转移方程**：状态转移方程 `dp[i] = max(dp[i], j * (i - j), j * dp[i - j])` 实际上已经隐含了所有可能的拆分方式。这里的 `j * (i - j)` 表示直接将 `i` 拆分成两个数字 `j` 和 `i-j`，而 `j * dp[i - j]` 表示将 `i` 拆分为 `j` 和将 `i-j` 进一步拆分的最大乘积。
3. **递归的本质**：当我们计算 `dp[i-j]` 时，实际上是在考虑将 `i-j` 这个数拆分成任意数量的整数的最大乘积，这个过程是递归进行的。因此，即使我们只显式地考虑将 `i` 拆分为两部分，实际上我们已经隐式地考虑了所有可能的拆分方式。
4. **最优子结构**：动态规划的另一个关键概念是最优子结构。在整数拆分问题中，最优子结构意味着 `i` 的最大乘积可以通过其子问题（即更小的整数拆分）的最大乘积组合而来。

总的来说，虽然表面上我们看起来只是在将整数拆分为两个数字，但实际上通过动态规划的状态转移方程和递归的本质，我们已经考虑了所有可能的拆分方式，并找到了乘积最大的那种方式。

- 为什么初始化的数组长度是n+1而不是n?
- 在动态规划中，通常我们使用一个数组 `dp` 来存储子问题的解。当数组的索引代表具体的问题规模（例如这里的整数拆分问题中的整数 `i`）时，我们需要确保数组能够容纳从 `0` 到 `n` 所有可能的问题规模。
- 由于数组索引是从 `0` 开始的，要存储 `n` 这个规模的问题解，数组的长度需要是 `n+1`。这样，`dp[n]` 才能正确存储整数 `n` 拆分后的最大乘积。

- 为什么遍历i的范围是包括n在内？这样岂不是拆不出另一个数字了吗？

- 在这个问题中，我们的目标是找到将整数 `n` 拆分后的最大乘积。为了实现这一点，我们需要计算从 `2` 到 `n` 所有整数拆分的最大乘积。
- 遍历到 `n` 并不意味着我们在拆分时没有留下另一个数字。这是因为在计算 `dp[i]`（其中 `i` 可能等于 `n`）时，我们是在遍历所有可能的拆分方式。例如，如果 `i = n`，那么在计算 `dp[n]` 时，我们会考虑拆分为 `1` 和 `n-1`，`2` 和 `n-2`，依此类推，直到 `n-1` 和 `1`。在这个过程中，我们确保了每次拆分都留下了至少两个正整数。

---

### [96.不同的二叉搜索树](https://leetcode.com/problems/unique-binary-search-trees/description/)

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

**示例 1：**

![Image.jpg](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

输入：n = 3

输出：5

**示例 2：**

输入：n = 1

输出：1

**提示：**

- `1 <= n <= 19`

#### 解题思路：

这个问题是一个典型的动态规划问题，我们可以通过以下步骤来求解：

1. **问题概述**：求由 `n` 个不同节点组成的二叉搜索树有多少种不同的结构。
2. **确定动态规划状态**：定义 `dp[i]` 为有 `i` 个节点的二叉搜索树的种数。
3. **确定状态转移方程**：
   - 对于有 `i` 个节点的二叉搜索树，我们可以选择任意一个节点作为根节点。假设根节点的值为 `j`，那么左子树将包含 `j-1` 个节点，右子树将包含 `i-j` 个节点。
   - 因此，左子树的种数为 `dp[j-1]`，右子树的种数为 `dp[i-j]`。
   - 对于固定的 `j`，不同的二叉搜索树的数量为 `dp[j-1] * dp[i-j]`。
   - 由于 `j` 可以从 `1` 取到 `i`，我们需要将所有可能的 `j` 的结果累加起来，因此状态转移方程为 `dp[i] = ∑dp[j-1] * dp[i-j]`（其中 `j` 从 `1` 到 `i`）。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20210107093226241.png)

4. **初始化和边界情况**：
   - 初始化 `dp[0] = 1` 和 `dp[1] = 1`。没有节点和只有一个节点的二叉搜索树分别只有一种结构。
5. **计算顺序**：
   - 从小到大计算 `dp[i]`，直到 `n`。
6. **返回结果**：
   - 返回 `dp[n]`。

```python
def numTrees(n):
    # 初始化dp数组，长度为n+1，因为我们需要考虑从0到n的所有情况
    dp = [0] * (n + 1)
    # 初始化基础情况
    dp[0], dp[1] = 1, 1

    # 从2开始，计算每个数的不同二叉搜索树数量
    for i in range(2, n + 1):
        # 遍历所有可能的根节点
        for j in range(1, i + 1):
            # 累加每种情况的二叉搜索树数量
            # dp[j-1] 表示左子树的数量，dp[i-j] 表示右子树的数量
            dp[i] += dp[j - 1] * dp[i - j]

    # 返回n个节点的二叉搜索树数量
    return dp[n]

# 测试用例
print(numTrees(3))  # 输出: 5
print(numTrees(1))  # 输出: 1
```

**时间复杂度和空间复杂度分析**：

- 时间复杂度是 (O(n^2))，因为我们需要双层循环来填充 `dp` 数组。
- 空间复杂度是 (O(n))，因为我们使用了一个长度为 `n + 1` 的数组。

**常见错误**：

- 初始化 `dp[0]` 和 `dp[1]` 的值错误。
- 状态转移方程没有正确累加所有可能的 `j` 的结果。

#### 代码随想录算法训练营第四十二天 | 背包问题，416. 分割等和子集

#### ● day 42 任务以及具体安排：[第九章 动态规划part04](https://docs.qq.com/doc/DUGdkaEl5dFN1QnBl) (1.23)

# 第九章 动态规划part04

●  01背包问题，你该了解这些！

●  01背包问题，你该了解这些！ 滚动数组

●  416. 分割等和子集

正式开始背包问题，背包问题还是挺难的，虽然大家可能看了很多背包问题模板代码，感觉挺简单，但基本理解的都不够深入。

如果是直接从来没听过背包问题，可以先看文字讲解慢慢了解 这是干什么的。

如果做过背包类问题，可以先看视频，很多内容，是自己平时没有考虑到位的。

背包问题，力扣上没有原题，大家先了解理论，今天就安排一道具体题目。

详细布置

01背包问题 二维

[代码随想录](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html)

视频讲解：[https://www.bilibili.com/video/BV1cg411g7Y6](https://www.bilibili.com/video/BV1cg411g7Y6)

01背包问题 一维

[代码随想录](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html)

视频讲解：[https://www.bilibili.com/video/BV1BU4y177kY](https://www.bilibili.com/video/BV1BU4y177kY)

416. 分割等和子集

本题是 01背包的应用类题目

[](https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html)

视频讲解：[https://www.bilibili.com/video/BV1rt4y1N7jE](https://www.bilibili.com/video/BV1rt4y1N7jE)

[ChatGPT](https://chat.openai.com/share/391c274e-53df-4405-8ec4-2e8cf3337272)

---

### 背包问题 一维

有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

![Image.jpg](https://code-thinking-1253855093.file.myqcloud.com/pics/20210117175428387.jpg)

背包问题是经典的动态规划问题。这里，我们关注的是一维的背包问题。我将首先概括问题，然后逐步提供解决方案。

#### 问题概括

- **输入**:
   - 物品的总数 `n`
   - 每个物品的重量 `weight[i]`
   - 每个物品的价值 `value[i]`
   - 背包的最大承重 `w`
- **输出**: 背包能够承载的最大价值

#### 解决方案步骤

1. **定义状态**：
   - `dp[j]` 表示对于给定的最大承重 `j`，背包能够承载的最大价值。
2. **状态转移方程**：
   - 对于每个物品 `i`，考虑是否将其放入背包中：
      - 如果不放入，则 `dp[j]` 保持不变。
      - 如果放入，那么 `dp[j] = max(dp[j], dp[j - weight[i]] + value[i])`。
3. **初始化状态**：
   - `dp[0] = 0`，因为最大承重为0时，无法装入任何物品。
   - 其他 `dp[j]` 初始为0。
4. **遍历顺序**：
   - 物品 `i` 从 1 到 `n` 遍历。
   - 背包重量 `j` 从 `w` 到 `weight[i]` 逆向遍历（为了确保每件物品只用一次）。
5. **返回结果**：
   - 结果为 `dp[w]`，表示最大承重为 `w` 时背包的最大价值。

```python
def knapsack(weight, value, w):
    # 物品总数
    n = len(weight)
    # 初始化动态规划数组，大小为背包最大承重+1
    dp = [0] * (w + 1)

    # 遍历所有物品
    for i in range(n):
        # 从背包最大承重开始逆向遍历到当前物品重量
        for j in range(w, weight[i] - 1, -1):
            # 更新dp[j]：不放入当前物品或放入当前物品后的最大价值
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i])

    # 返回最大承重下的最大价值
    return dp[w]
```

#### 复杂度分析

- 时间复杂度：`O(n*w)`，其中 `n` 是物品数量，`w` 是背包最大承重。
- 空间复杂度：`O(w)`，仅使用了一维数组。

#### 常见错误

- 忘记逆序遍历背包重量，导致一个物品被多次使用。
- 初始化 `dp` 数组时错误地给出了不合适的初始值。

现在，你可以使用不同的 `weight`、`value` 和 `w` 值来测试这个解决方案。这种类型的问题在数据结构和算法的面试中非常常见，因此理解和练习这种解决方案是非常重要的。

---

### 背包问题 二维

有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

一个例子：

背包最大重量为4。

物品为：

|     | 重量 | 价值 |
| --- | -- | -- |
| 物品0 | 1  | 15 |
| 物品1 | 3  | 20 |
| 物品2 | 4  | 30 |

问背包能背的物品最大价值是多少？

#### 解题思路：

使用二维数组结合动态规划来解决背包问题是一种常见的方法。这种方法的主要思想是使用一个二维数组来存储在不同背包容量和不同物品数量情况下的最大价值。

#### 问题概述

- 目标：找出在不超过背包最大重量限制的情况下，可以获得的最大价值。
- 输入：物品总数 `n`，每个物品的重量 `weight[i]`，每个物品的价值 `value[i]`，背包的最大承重 `w`。
- 输出：背包的最大价值。

#### 解决方案步骤

1. **定义状态**：
   - `dp[i][j]` 表示在前 `i` 个物品中，背包容量为 `j` 时的最大价值。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103003361.png)

2. **初始化状态**：
   - 初始化二维数组 `dp[n+1][w+1]`，初始值为0。

![Image.jpg](https://code-thinking-1253855093.file.myqcloud.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%9810.jpg)

3. **状态转移方程**：
   - 当 `weight[i-1] <= j` 时（即当前物品可以放入背包），`dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i-1]] + value[i-1])`；
   - 当 `weight[i-1] > j` 时（即当前物品无法放入背包），`dp[i][j] = dp[i-1][j]`。
4. **遍历顺序**：
   - 先遍历物品，再遍历背包容量。

![Image.jpg](https://code-thinking-1253855093.file.myqcloud.com/pics/20210118163425129.jpg)

5. **返回结果**：
   - 返回 `dp[n][w]`。

```python
def knapsack(weight, value, w):
    n = len(weight)
    # 初始化二维动态规划数组
    dp = [[0 for _ in range(w + 1)] for _ in range(n + 1)]

    # 遍历物品
    for i in range(1, n + 1):
        # 遍历背包容量
        for j in range(1, w + 1):
            if weight[i-1] <= j:
                # 当前物品可以放入背包
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i-1]] + value[i-1])
            else:
                # 当前物品无法放入背包
                dp[i][j] = dp[i-1][j]

    return dp[n][w]
```

#### 复杂度分析

- 时间复杂度：O(n*w)，其中 `n` 是物品数量，`w` 是背包最大承重。
- 空间复杂度：O(n*w)，使用了二维数组存储中间状态。

#### 常见错误

- 初始化 `dp` 数组时忽略第一行和第一列的默认值，这些值对于建立正确的状态转移至关重要。
- 在状态转移方程中混淆了物品的索引，导致数组越界或逻辑错误。

---

### 416. 分割等和子集

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**示例 1：**

输入：nums = [1,5,11,5]

输出：true

解释：数组可以分割成 [1, 5, 5] 和 [11] 。

**示例 2：**

输入：nums = [1,2,3,5]

输出：false

解释：数组不能分割成两个元素和相等的子集。

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`

这个问题是一个典型的动态规划问题，特别是与背包问题有着密切的关联。问题的核心是判断数组是否能分割成两个和相等的子集，这可以转化为一个子集和问题 —— 即是否存在一个子集的和等于数组总和的一半。

#### 问题分析

- 数组需要被分割成两个和相等的子集，因此数组总和必须是偶数，否则不可能分割成两个和相等的子集。
- 如果数组总和是偶数，问题就转化为是否可以从数组中选择一些数字，使得这些数字的和等于总和的一半。

#### 解决方案步骤

1. **检查和是否为偶数**：
   - 如果数组总和是奇数，则直接返回 `false`。
2. **定义状态**：
   - `dp[i][j]` 表示从数组的前 `i` 个数中选取若干个，是否能使得它们的和等于 `j`。
3. **初始化**：
   - 初始化二维数组 `dp`，大小为 `len(nums) x (sum(nums)//2 + 1)`。
   - 对于所有 `j`，`dp[0][j] = False`（因为没有数可选时，不可能达到非零的和）。
   - 设置 `dp[i][0] = True`（因为总和为0总是可能的）。
4. **状态转移方程**：
   - 如果 `nums[i-1] <= j`，`dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]`。
   - 如果 `nums[i-1] > j`，`dp[i][j] = dp[i-1][j]`。
5. **返回结果**：
   - 返回 `dp[len(nums)][sum(nums)//2]`。

```python
def canPartition(nums):
    # 计算数组总和
    total_sum = sum(nums)
    # 如果总和是奇数，则无法分割成两个和相等的子集
    if total_sum % 2 != 0:
        return False

    # 目标和为总和的一半
    target = total_sum // 2
    n = len(nums)
    # 初始化动态规划数组，大小为 n+1 行，target+1 列
    dp = [[False for _ in range(target + 1)] for _ in range(n + 1)]
    # 当子集和为0时，总是可能的
    dp[0][0] = True

    # 遍历数组中的每个数字
    for i in range(1, n + 1):
        # 遍历所有可能的子集和
        for j in range(1, target + 1):
            # 如果当前数字小于等于子集和
            if nums[i-1] <= j:
                # 当前数字可以选择加入子集或不加入
                dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]
            else:
                # 当前数字无法加入子集
                dp[i][j] = dp[i-1][j]

    # 返回能否找到和为 target 的子集
    return dp[n][target]
```

#### 复杂度分析

- 时间复杂度：O(n*sum/2)，其中 `n` 是数组的长度。
- 空间复杂度：O(n*sum/2)，使用了二维数组。

#### 常见错误

- 没有先检查总和是否为偶数。
- 在状态转移方程中错误处理边界条件。

#### 代码随想录算法训练营第四十三天 | 1049. 最后一块石头的重量 II，494. 目标和，474.一和零

#### ● day 43 任务以及具体安排：[第九章 动态规划 part05](https://docs.qq.com/doc/DUEVMRHZOemN5S2Vm) (1.24)

# 第九章 动态规划 part05

●  1049. 最后一块石头的重量 II

●  494. 目标和

●  474.一和零

详细布置

1049. 最后一块石头的重量 II

本题就和 昨天的 416. 分割等和子集 很像了，可以尝试先自己思考做一做。

视频讲解：[https://www.bilibili.com/video/BV14M411C7oV](https://www.bilibili.com/video/BV14M411C7oV)

[代码随想录](https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html)

494. 目标和

大家重点理解 递推公式：dp[j] += dp[j - nums[i]]，这个公式后面的提问 我们还会用到。

视频讲解：[https://www.bilibili.com/video/BV1o8411j73x](https://www.bilibili.com/video/BV1o8411j73x)

[网页不存在——百度云主机服务](https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html)

474.一和零

通过这道题目，大家先粗略了解， 01背包，完全背包，多重背包的区别，不过不用细扣，因为后面 对于 完全背包，多重背包 还有单独讲解。

视频讲解：[https://www.bilibili.com/video/BV1rW4y1x7ZQ](https://www.bilibili.com/video/BV1rW4y1x7ZQ)

[代码随想录](https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html)

[ChatGPT](https://chat.openai.com/share/d765e0e6-0af1-46dd-bd12-63fffded3292)

---

### [1049. 最后一块石头的重量 II](https://leetcode.com/problems/last-stone-weight-ii/description/)

有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

**示例 1：**

输入：stones = [2,7,4,1,8,1]

输出：1

**解释：**

组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，

组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，

组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，

组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。

**示例 2：**

输入：stones = [31,26,33,21,40]

输出：5

**提示：**

- `1 <= stones.length <= 30`
- `1 <= stones[i] <= 100`

#### 问题概述

给定一个整数数组 `stones`，其中 `stones[i]` 表示第 i 块石头的重量。每次操作中，选择两块石头并将它们粉碎。如果石头重量相同，两块石头都粉碎；如果不同，则较轻的石头粉碎，较重的石头减去较轻石头的重量。求最后可能剩下的石头的最小重量。

#### 解题步骤

1. **定义状态**：
   - 创建一个一维数组 `dp`，其中 `dp[j]` 表示在不超过重量 `j` 的条件下，能够选择的石头的最大总重量。
2. **初始化**：
   - 初始化 `dp` 为长度为 `total_sum // 2 + 1` 的数组，所有元素初始值为 0。这里 `total_sum` 是所有石头的总重量。
3. **状态转移**：
   - 遍历每块石头 `stone`，并更新 `dp` 数组。对于每个 `stone`，从 `target` 到 `stone` 倒序遍历 `j`：
      - 更新 `dp[j] = max(dp[j], dp[j - stone] + stone)`。这表示对于每个 `j`，我们可以选择不拿当前的石头（保持 `dp[j]` 不变），或者拿当前的石头（更新为 `dp[j - stone] + stone`）。
4. **计算结果**：
   - 最终的结果是 `total_sum - 2 * dp[target]`。这里 `dp[target]` 是在总重量不超过 `total_sum // 2` 的条件下能达到的最大重量，因此 `total_sum - 2 * dp[target]` 就是两堆石头重量差的最小值。

```python
def lastStoneWeightII(stones):
    total_sum = sum(stones)
    target = total_sum // 2
    dp = [0] * (target + 1)
    for stone in stones:
        for j in range(target, stone - 1, -1):
            # 在不超过重量j的条件下，尝试放入当前石头，取最大值
            dp[j] = max(dp[j], dp[j - stone] + stone)
    # 计算最终结果，即两堆石头重量差的最小值
    return total_sum - 2 * dp[-1]
```

#### 时间和空间复杂度

- 时间复杂度：O(n * sum/2)，其中 n 是石头数量，sum 是石头的总重量。
- 空间复杂度：O(sum/2)，用于存储动态规划的状态。

#### 常见错误或难点

- 动态规划的状态转移方程需要正确理解和实现，特别是在更新 `dp[j]` 时，理解为何选择 `max(dp[j], dp[j - stone] + stone)`。
- 在实际编码时，要注意数组的索引是否会越界。

---

### [494. 目标和](https://leetcode.com/problems/target-sum/description/)

给你一个非负整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

**示例 1：**

输入：nums = [1,1,1,1,1], target = 3

输出：5

解释：一共有 5 种方法让最终目标和为 3 。

\-1 + 1 + 1 + 1 + 1 = 3

\+1 - 1 + 1 + 1 + 1 = 3

\+1 + 1 - 1 + 1 + 1 = 3

\+1 + 1 + 1 - 1 + 1 = 3

\+1 + 1 + 1 + 1 - 1 = 3

**示例 2：**

输入：nums = [1], target = 1

输出：1

**提示：**

- `1 <= nums.length <= 20`
- `0 <= nums[i] <= 1000`
- `0 <= sum(nums[i]) <= 1000`
- `-1000 <= target <= 1000`

这个问题是一个典型的动态规划问题，其本质上可以转换为一个子集划分问题。我们的目标是找到将数组 `nums` 分为两个子集（一个子集中的数字前面加 '+'，另一个子集中的数字前面加 '-'），使得这两个子集的数字总和之差等于 `target`。下面是解决这个问题的步骤：

#### 问题转换

首先，我们可以将这个问题转换为求子集的问题：

- 假设将所有加 '+' 的数字总和为 `sumP`，加 '-' 的数字总和为 `sumN`，则有 `sumP - sumN = target`。
- 同时我们知道 `sumP + sumN = sum(nums)`，其中 `sum(nums)` 是数组 `nums` 的总和。
- 通过联立这两个等式，可以得到 `sumP = (target + sum(nums)) / 2`。
- 因此，问题转换为在数组 `nums` 中找到和为 `sumP` 的子集数量。

#### 解题步骤

1. **状态定义**：
   - 定义动态规划数组 `dp`，其中 `dp[i]` 表示和为 `i` 的子集数量。
2. **初始化**：
   - 初始化 `dp[0] = 1`，因为和为 0 总是有一种方式（不选择任何数字）。
3. **状态转移**：
   - 遍历 `nums` 中的每个数字，对于每个数字，更新 `dp` 数组。

```python
def findTargetSumWays(nums, target):
    total_sum = sum(nums)
    
    # 检查是否可能存在符合条件的子集（(target + total_sum) 必须是偶数且非负）
    if total_sum < abs(target) or (target + total_sum) % 2 != 0:
        return 0
    
    # 计算正数子集应达到的目标和
    sumP = (target + total_sum) // 2
    # 初始化动态规划数组，dp[i] 表示和为 i 的子集数量
    dp = [0] * (sumP + 1)
    # 和为0的子集只有一种（空集）
    dp[0] = 1

    # 遍历数组中的每个数字，更新 dp 数组
    for num in nums:
        # 从后向前更新，以避免重复使用同一个数字
        for j in range(sumP, num - 1, -1):
            # 如果当前和减去当前数字仍大于等于0，更新 dp[j]
            dp[j] += dp[j - num]

    # 返回目标和为 sumP 的子集数量
    return dp[sumP]

# 测试用例
example1 = [1,1,1,1,1]
target1 = 3
example2 = [1]
target2 = 1

# 执行
result1 = findTargetSumWays(example1, target1)
result2 = findTargetSumWays(example2, target2)

result1, result2
```

#### 时间和空间复杂度

- 时间复杂度：O(n * sumP)，其中 n 是数组 `nums` 的长度。
- 空间复杂度：O(sumP)，用于存储动态规划数组。

#### 常见错误

- 忽略了 `(target + total_sum) % 2 != 0` 这种情况，这种情况下是无法分割成两个子集的。
- 在更新 `dp` 数组时，应该从后向前更新，以避免重复使用同一个数字。

这种方法在面试中展示了对动态规划以及问题转换的理解，特别是在处理组合问题时的灵活运用。

---

### [474.一和零](https://leetcode.com/problems/ones-and-zeroes/description/)

给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

**示例 1：**

输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3

输出：4

解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。

其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。

**示例 2：**

输入：strs = ["10", "0", "1"], m = 1, n = 1

输出：2

解释：最大的子集是 {"0", "1"} ，所以答案是 2 。

**提示：**

- `1 <= strs.length <= 600`
- `1 <= strs[i].length <= 100`
- `strs[i]` 仅由 `'0'` 和 `'1'` 组成
- `1 <= m, n <= 100`

这个问题可以通过动态规划来解决，本质上是一个典型的 0-1 背包问题的变体。我们需要找到一个字符串子集，使得子集中所有字符串的 0 的总数不超过 `m`，1 的总数不超过 `n`，同时这个子集的大小尽可能大。

#### 解题步骤

1. **预处理**：
   - 遍历 `strs` 数组，对每个字符串计算其中 0 和 1 的数量。
2. **定义状态**：
   - 定义一个三维动态规划数组 `dp`，其中 `dp[i][j][k]` 表示在前 `i` 个字符串中，使用不超过 `j` 个 0 和 `k` 个 1 时，能够得到的最大子集大小。
3. **初始化**：
   - 初始化 `dp[0][j][k] = 0`，表示没有字符串时，子集大小为 0。
4. **状态转移**：
   - 遍历字符串，对于每个字符串，更新 `dp` 数组。对于每个 `i, j, k`，考虑是否选择当前字符串。

```python
def findMaxForm(strs, m, n):
    # 预处理：计算每个字符串中 0 和 1 的数量
    count = [(s.count('0'), s.count('1')) for s in strs]

    # 初始化动态规划数组
    dp = [[[0] * (n + 1) for _ in range(m + 1)] for _ in range(len(strs) + 1)]

    # 动态规划填表
    for i in range(1, len(strs) + 1):
        zeros, ones = count[i - 1]
        for j in range(m + 1):
            for k in range(n + 1):
                # 不选择当前字符串
                dp[i][j][k] = dp[i - 1][j][k]
                # 选择当前字符串（如果0和1的数量允许）
                if j >= zeros and k >= ones:
                    dp[i][j][k] = max(dp[i][j][k], 1 + dp[i - 1][j - zeros][k - ones])

    # 返回结果
    return dp[-1][m][n]
```

#### 时间和空间复杂度

- 时间复杂度：O(l * m * n)，其中 `l` 是字符串数组 `strs` 的长度。
- 空间复杂度：O(l * m * n)，用于存储动态规划数组。

#### 常见错误

- 忽略了字符串长度可能不同，导致在统计 0 和 1 的数量时出错。
- 在更新动态规划数组时，没有正确处理选择和不选择当前字符串的情况。

这个方法在面试中展示了对动态规划的理解，特别是在处理具有多维限制的组合问题时的应用。

#### 代码随想录算法训练营第四十四天 | 完全背包，518. 零钱兑换 II，377. 组合总和 Ⅳ

#### ● day 44 任务以及具体安排：[第九章 动态规划part06](https://docs.qq.com/doc/DUHBSRVRUc0Vsck1z) (1.25)

# 第九章 动态规划part06

●  完全背包

●  518. 零钱兑换 II

●  377. 组合总和 Ⅳ

详细布置

力扣上没有纯粹的完全背包的题目，所以大家看本篇了解一下 完全背包的理论

后面的两道题目，都是完全背包的应用，做做感受一下

完全背包

视频讲解：[https://www.bilibili.com/video/BV1uK411o7c9](https://www.bilibili.com/video/BV1uK411o7c9)

[代码随想录](https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html)

518. 零钱兑换 II

视频讲解：[https://www.bilibili.com/video/BV1KM411k75j](https://www.bilibili.com/video/BV1KM411k75j)

[代码随想录](https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html)

377. 组合总和 Ⅳ

视频讲解：[https://www.bilibili.com/video/BV1V14y1n7B6](https://www.bilibili.com/video/BV1V14y1n7B6)

[代码随想录](https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html)

[ChatGPT](https://chat.openai.com/share/970cd598-7d91-426b-a442-14caf0b605ad)

---

### 完全背包

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。

同样leetcode上没有纯完全背包问题，都是需要完全背包的各种应用，需要转化成完全背包问题，所以我这里还是以纯完全背包问题进行讲解理论和原理。

在下面的讲解中，我依然举这个例子：

背包最大重量为4。

物品为：

|     | 重量 | 价值 |
| --- | -- | -- |
| 物品0 | 1  | 15 |
| 物品1 | 3  | 20 |
| 物品2 | 4  | 30 |

**每件商品都有无限个！**

问背包能背的物品最大价值是多少？

针对完全背包问题，我们首先需要理解其基本概念。这个问题是动态规划问题中的一个经典案例。让我们逐步分解这个问题：

#### 问题概述

- **目标**: 在不超过背包最大承重的前提下，选择物品以最大化背包中物品的总价值。
- **条件**: 每种物品可以选无限次。

#### 示例

- 背包最大重量: `W = 4`
- 物品详情（重量和价值）:
   - 物品0: 重量 = 1, 价值 = 15
   - 物品1: 重量 = 3, 价值 = 20
   - 物品2: 重量 = 4, 价值 = 30

#### 解题思路

1. **定义状态**:
   - `dp[i][j]` 表示对于前 `i` 个物品，当背包容量为 `j` 时的最大价值。
2. **状态转移方程**:
   - `dp[i][j] = max(dp[i-1][j], dp[i][j-weight[i]] + value[i])`
   - 解释: 要么不选择当前物品（保持上一状态），要么选择当前物品（在剩余重量下的最大价值加上当前物品的价值）。
3. **初始化**:
   - `dp[0][..] = 0`：没有物品时，价值为0。
4. **迭代顺序**:
   - 物品遍历：外层循环。
   - 背包容量遍历：内层循环，正向遍历（因为每种物品可以选无限次）。
5. **优化**:
   - 可以将二维 `dp` 数组优化为一维数组，因为每个状态只与上一个状态相关。

```python
def complete_knapsack(weights, values, W):
    # 物品的数量
    N = len(weights)
    # 初始化dp数组
    dp = [0] * (W + 1)

    # 遍历所有物品
    for i in range(N):
        # 遍历背包容量
        for j in range(weights[i], W + 1):
            # 状态转移方程
            dp[j] = max(dp[j], dp[j - weights[i]] + values[i])

    return dp[W]

# 测试数据
weights = [1, 3, 4]
values = [15, 20, 30]
W = 4

# 计算结果
max_value = complete_knapsack(weights, values, W)
print(f"背包能背的物品最大价值是: {max_value}")
```

#### 时间和空间复杂度

- 时间复杂度：`O(N*W)`，其中 `N` 是物品数量，`W` 是背包容量。
- 空间复杂度：`O(W)`，使用了一维数组来存储状态。

#### 常见错误

- 不正确处理每个物品可以选无限次的情况。
- 状态转移方程理解错误。

---

### [518. 零钱兑换 II](https://leetcode.com/problems/coin-change-ii/description/)

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。

题目数据保证结果符合 32 位带符号整数。

**示例 1：**

输入：amount = 5, coins = [1, 2, 5]

输出：4

解释：有四种方式可以凑成总金额：

5=5

5=2+2+1

5=2+1+1+1

5=1+1+1+1+1

**示例 2：**

输入：amount = 3, coins = [2]

输出：0

解释：只用面额 2 的硬币不能凑成总金额 3 。

**示例 3：**

输入：amount = 10, coins = [10]

输出：1

**提示：**

- `1 <= coins.length <= 300`
- `1 <= coins[i] <= 5000`
- `coins` 中的所有值 **互不相同**
- `0 <= amount <= 5000`

这个问题是一个典型的完全背包问题，其中的目标是找出组合总数而不是最大价值。我们可以使用动态规划来解决这个问题。下面是解题的步骤和思路：

#### 解题思路

1. **定义状态**:
   - `dp[i]` 表示凑成总金额为 `i` 的硬币组合数。
2. **状态转移方程**:
   - `dp[i] += dp[i - coin]` 对于每个硬币，如果当前金额大于等于硬币面额，那么当前金额的组合数可以由当前金额减去该硬币面额的组合数累加得到。
3. **初始化**:
   - `dp[0] = 1`：凑成总金额为0的方法只有1种，就是不使用任何硬币。
4. **迭代顺序**:
   - 先遍历硬币，再遍历金额。这样可以保证每种硬币在每个金额下都被考虑，符合完全背包的特点（每种物品（硬币）可以使用无限次）。
5. **边界条件**:
   - 当 `amount < 0` 或没有硬币时，应返回0，表示没有合法的组合。

```python
def change(amount, coins):
    # 初始化dp数组
    dp = [0] * (amount + 1)
    dp[0] = 1  # 初始化，总金额为0的组合数为1

    # 遍历每一种硬币
    for coin in coins:
        # 更新dp数组
        for i in range(coin, amount + 1):
            dp[i] += dp[i - coin]

    return dp[amount]

# 示例测试
amount1, coins1 = 5, [1, 2, 5]
print(change(amount1, coins1))  # 输出: 4

amount2, coins2 = 3, [2]
print(change(amount2, coins2))  # 输出: 0

amount3, coins3 = 10, [10]
print(change(amount3, coins3))  # 输出: 1
```

#### 时间和空间复杂度

- 时间复杂度：`O(N*amount)`，其中 `N` 是硬币的种类数，`amount` 是目标金额。
- 空间复杂度：`O(amount)`，用于存储每个金额对应的组合数。

#### 常见错误

- 混淆完全背包问题中物品的迭代顺序，导致结果不正确。
- 初始化错误，忘记将 `dp[0]` 设置为1。

---

### [377. 组合总和 Ⅳ](https://leetcode.com/problems/combination-sum-iv/description/)

给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

**示例 1：**

输入：nums = [1,2,3], target = 4

输出：7

**解释：**

所有可能的组合为：

(1, 1, 1, 1)

(1, 1, 2)

(1, 2, 1)

(1, 3)

(2, 1, 1)

(2, 2)

(3, 1)

请注意，顺序不同的序列被视作不同的组合。

**示例 2：**

输入：nums = [9], target = 3

输出：0

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 1000`
- `nums` 中的所有元素 **互不相同**
- `1 <= target <= 1000`

进阶：如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？

问题377 "组合总和 IV" 可以通过动态规划来解决。这个问题的特点是顺序不同的序列被视作不同的组合，这意味着它与传统的完全背包问题有所不同，传统的完全背包问题关注的是组合数，不考虑元素的排列顺序。

#### 解题思路

1. **定义状态**:
   - `dp[i]` 表示和为 `i` 的组合总数。
2. **状态转移方程**:
   - `dp[i] += dp[i - num]` 对于数组 `nums` 中的每个数 `num`，如果 `i` 大于等于 `num`，那么从 `i - num` 的状态转移过来，累加到 `dp[i]`。
3. **初始化**:
   - `dp[0] = 1`：和为0的组合总数为1，即不选择任何元素。
4. **迭代顺序**:
   - 由于顺序被视为不同组合，我们首先遍历金额，再遍历数组 `nums`。
5. **边界条件**:
   - 当 `target < 0` 或 `nums` 为空时，应返回0。

```python
def combinationSum4(nums, target):
    dp = [0] * (target + 1)
    dp[0] = 1  # 初始化

    for i in range(1, target + 1):
        for num in nums:
            if i - num >= 0:
                dp[i] += dp[i - num]

    return dp[target]

# 示例测试
nums1, target1 = [1, 2, 3], 4
print(combinationSum4(nums1, target1))  # 输出: 7

nums2, target2 = [9], 3
print(combinationSum4(nums2, target2))  # 输出: 0
```

#### 时间和空间复杂度

- 时间复杂度：`O(N*target)`，其中 `N` 是数组 `nums` 的长度。
- 空间复杂度：`O(target)`，用于存储每个目标和对应的组合总数。

#### 进阶问题分析

如果数组 `nums` 中含有负数，则问题会变得复杂，因为负数的加入可能导致无限的组合数（例如，如果 `nums` 包含 `-1` 和 `1`，则可以无限次地添加 `-1` 和 `1` 来凑成任何数）。因此，如果允许负数出现，我们需要额外的限制条件来避免无限循环，比如限制每个数字使用的次数。

#### 代码随想录算法训练营第四十五天 | 70. 爬楼梯(进阶), 322. 零钱兑换, 279.完全平方数

#### ● day 45 任务以及具体安排：[第九章 动态规划part07](https://docs.qq.com/doc/DUFVEbWRyZlpjaGty) (1.26)

# 第九章 动态规划part07

●  70. 爬楼梯 （进阶）

●  322. 零钱兑换

●  279.完全平方数

详细布置

70. 爬楼梯 （进阶）

这道题目 爬楼梯之前我们做过，这次再用完全背包的思路来分析一遍

[代码随想录](https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html)

322. 零钱兑换

如果求组合数就是外层for循环遍历物品，内层for遍历背包。

如果求排列数就是外层for遍历背包，内层for循环遍历物品。

这句话结合本题 大家要好好理解。

视频讲解：[https://www.bilibili.com/video/BV14K411R7yv](https://www.bilibili.com/video/BV14K411R7yv)

[代码随想录](https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html)

279.完全平方数

本题 和 322. 零钱兑换 基本是一样的，大家先自己尝试做一做

视频讲解：[https://www.bilibili.com/video/BV12P411T7Br](https://www.bilibili.com/video/BV12P411T7Br)

[代码随想录](https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html)

[ChatGPT](https://chat.openai.com/share/505aa3e8-df16-4504-94e8-82bf49f4efc6)

---

### [70. 爬楼梯 （进阶）](https://kamacoder.com/problempage.php?pid=1067)

#### 题目描述

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬至多m (1 <= m < n)个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

#### 输入描述

输入共一行，包含两个正整数，分别表示n, m

#### 输出描述

输出一个整数，表示爬到楼顶的方法数。

#### 输入示例

```other
3 2
```

#### 输出示例

```other
3
```

#### 提示信息

数据范围：

1 <= m < n <= 32;

当 m = 2，n = 3 时，n = 3 这表示一共有三个台阶，m = 2 代表你每次可以爬一个台阶或者两个台阶。

此时你有三种方法可以爬到楼顶。

1. 1 阶 + 1 阶 + 1 阶段
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶

这个问题是爬楼梯问题的一个变种，它要求计算从底部到达n阶楼顶的方法数，每次可以爬1到m个台阶。这个问题可以通过动态规划来解决。下面是解题的步骤：

#### 解题思路

1. **定义状态**: 设`dp[i]`表示达到第i阶楼梯的方法数。
2. **状态转移方程**: `dp[i]`可以从前m个状态转移过来，即`dp[i] = dp[i-1] + dp[i-2] + ... + dp[i-m]`，需要注意的是，当`i < m`时，不所有的前m个状态都存在。
3. **初始化**: `dp[0] = 1`表示不爬楼梯也算一种方法，对于`i <= m`且`i <= n`的初始情况，应该考虑到只有少于m阶楼梯时的情况，这时候的方法数是`2^(i-1)`（考虑到每一阶楼梯爬或不爬的情况，除了第一阶必须爬）。
4. **结果**: 最终`dp[n]`即为答案。

```python
def climbStairs(n, m):
    # 初始化dp数组，长度为n+1，初始值为0
    # dp[i]表示到达第i阶楼梯的方法数
    dp = [0] * (n + 1)
    dp[0] = 1  # 设置基础情况，不爬楼梯也算一种方法

    # 遍历从1到n的每一阶楼梯
    for i in range(1, n + 1):
        # 遍历从1到m的每一步可能性，但不能超过当前阶数i
        for j in range(1, min(i, m) + 1):
            # 状态转移方程，累加到达当前阶梯的所有可能方法数
            dp[i] += dp[i - j]

    # 返回到达第n阶楼梯的方法数
    return dp[n]

# 示例输入
n, m = 3, 2
# 输出爬到楼顶的方法数
print(climbStairs(n, m))
```

#### 复杂度分析

- **时间复杂度**: O(nm)，因为每计算一个`dp[i]`需要遍历m个状态。
- **空间复杂度**: O(n)，存储了从0到n的所有状态。

#### 注意点

- 初始化时要特别注意`dp[0]`的设定，这里`dp[0] = 1`是因为不爬楼梯也被视为一种方法。
- 当`i < m`时，不能从不存在的状态转移过来，因此转移时的条件是`min(i, m)`。
- 需要考虑到大量的重复计算，特别是当`m`和`n`都很大时，可以通过记忆化递归或迭代加缓存的方式来优化。

#### 测试用例

- 输入: `n = 3, m = 2`，输出: `3`
- 输入: `n = 4, m = 2`，输出: `5`（1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2）
- 输入: `n = 3, m = 3`，输出: `4`（1+1+1, 1+2, 2+1, 3）

---

### [322. 零钱兑换](https://leetcode.com/problems/coin-change/description/)

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

**示例 1：**

输入：coins = `[1, 2, 5]`, amount = `11`

**输出：**`3`

解释：11 = 5 + 5 + 1

**示例 2：**

输入：coins = `[2]`, amount = `3`

**输出：**-1

**示例 3：**

输入：coins = [1], amount = 0

输出：0

**提示：**

- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 231 - 1`
- `0 <= amount <= 104`

这个问题是一个经典的动态规划问题，我们可以通过定义状态和状态转移方程来解决。

#### 解题思路

1. **定义状态**: 设`dp[i]`为组成金额`i`所需的最少硬币数量。
2. **状态转移方程**: 对于每个状态`dp[i]`，它可以由`dp[i - coin] + 1`转换而来，其中`coin`是`coins`数组中的每个硬币面额，且`i - coin >= 0`。状态转移方程为：`dp[i] = min(dp[i], dp[i - coin] + 1)`。
3. **初始化**: `dp[0] = 0`，因为组成金额0所需的硬币数为0。其余的`dp[i]`初始化为一个很大的数，例如`amount + 1`，表示初始时除了0以外的金额都无法达成。
4. **结果**: 如果`dp[amount]`大于`amount`，说明没有任何硬币组合能够组成总金额，返回`-1`；否则，返回`dp[amount]`。

```python
def coinChange(coins, amount):
    # 初始化dp数组，长度为amount+1，初始值设为amount+1表示无法达成的状态
    dp = [amount + 1] * (amount + 1)
    dp[0] = 0  # 组成金额0所需的硬币数为0

    # 遍历从1到amount的每个金额
    for i in range(1, amount + 1):
        # 遍历每种硬币面额
        for coin in coins:
            # 如果当前硬币可以被使用
            if i - coin >= 0:
                # 更新dp[i]
                dp[i] = min(dp[i], dp[i - coin] + 1)

    # 如果dp[amount]的值没有被更新，说明无法达成总金额
    return dp[amount] if dp[amount] <= amount else -1

# 示例输入
coins = [1, 2, 5]
amount = 11
# 输出最少硬币个数
print(coinChange(coins, amount))
```

#### 复杂度分析

- **时间复杂度**: O(n*m)，其中n是`amount`的大小，m是`coins`数组的长度。我们需要对每个金额计算最少硬币数，每次计算需要遍历所有硬币。
- **空间复杂度**: O(n)，`dp`数组的大小。

#### 注意点

- 初始化`dp[i]`为一个较大的数，以便于在状态转移时能够正确取最小值。
- 仔细处理边界条件，例如`dp[0] = 0`和返回值的条件判断。

---

### [279.完全平方数](https://leetcode.com/problems/perfect-squares/description/)

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

**示例 1：**

输入：n = `12`

输出：3

**解释：**`12 = 4 + 4 + 4`

**示例 2：**

输入：n = `13`

输出：2

**解释：**`13 = 4 + 9`

**提示：**

- `1 <= n <= 104`

这个问题也是一个经典的动态规划问题，我们可以通过定义状态和状态转移方程来找到解决方案。

#### 解题思路

1. **定义状态**: 设`dp[i]`为组成数字`i`所需的最少完全平方数的数量。
2. **状态转移方程**: 对于每个状态`dp[i]`，它可以由`dp[i - j*j] + 1`转换而来，其中`j*j`是不超过`i`的完全平方数，且`i - j*j >= 0`。状态转移方程为：`dp[i] = min(dp[i], dp[i - j*j] + 1)`。
3. **初始化**: `dp[0] = 0`，因为组成数字0所需的完全平方数数量为0。其余的`dp[i]`初始化为一个很大的数，例如`n+1`，表示初始时除了0以外的数字都未找到最少完全平方数的组合。
4. **结果**: 返回`dp[n]`。

```python
def numSquares(n):
    # 初始化dp数组，长度为n+1，初始值设为n+1表示无法达成的状态
    dp = [n + 1] * (n + 1)
    dp[0] = 0  # 组成数字0所需的完全平方数数量为0

    # 遍历从1到n的每个数字
    for i in range(1, n + 1):
        # 遍历可能的完全平方数
        j = 1
        while j * j <= i:
            # 更新dp[i]
            dp[i] = min(dp[i], dp[i - j * j] + 1)
            j += 1

    # 返回组成n所需的最少完全平方数的数量
    return dp[n]

# 示例输入
n = 12
# 输出和为n的完全平方数的最少数量
print(numSquares(n))
```

#### 复杂度分析

- **时间复杂度**: O(n√n)，其中n是输入的数字。对于每个`i`（1到n），内部循环需要遍历所有小于等于`i`的完全平方数。
- **空间复杂度**: O(n)，存储`dp`数组所需的空间。

#### 注意点

- 这个问题实际上是求解最少数量的完全平方数，其和为`n`。这可以看作是一个“组合”问题，而不是“排列”问题，因此我们只关心组成`n`的完全平方数的数量，而不关心它们的顺序。
- 初始化时，`dp[0] = 0`是一个重要的基案，因为任何数字的0次方都是0，这也意味着组成数字0不需要任何完全平方数。
- 当处理大数时，要注意内存和时间限制，可能需要优化算法以避免超时。

#### 代码随想录算法训练营第四十六天 | 139.单词拆分, 多重背包, 背包问题总结

#### ● day 46 任务以及具体安排：[第九章 动态规划part08](https://docs.qq.com/doc/DUHhuT2RTTEtBeGhX) (1.27)

# 第九章 动态规划part08

●  139.单词拆分

●  关于多重背包，你该了解这些！

●  背包问题总结篇！

详细布置

关于 多重背包，力扣上没有相关的题目，所以今天大家的重点就是回顾一波 自己做的背包题目吧。

139.单词拆分

视频讲解：[https://www.bilibili.com/video/BV1pd4y147Rh](https://www.bilibili.com/video/BV1pd4y147Rh)

[代码随想录](https://programmercarl.com/0139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.html)

关于多重背包，你该了解这些！

[代码随想录](https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85.html)

背包问题总结篇！

[代码随想录](https://programmercarl.com/%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93%E7%AF%87.html)

[ChatGPT](https://chat.openai.com/share/1c230c04-8031-4de4-bd72-e0dfb5e5d974)

---

### [139.单词拆分](https://leetcode.com/problems/word-break/description/)

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**示例 1：**

**输入:** s = "leetcode", wordDict = ["leet", "code"]

**输出:** true

**解释:** 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。

**示例 2：**

**输入:** s = "applepenapple", wordDict = ["apple", "pen"]

**输出:** true

**解释:** 返回 true 因为 `"`applepenapple`"` 可以由 `"`apple" "pen" "apple`" 拼接成`。

注意，你可以重复使用字典中的单词。

**示例 3：**

**输入:** s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]

**输出:** false

**提示：**

- `1 <= s.length <= 300`
- `1 <= wordDict.length <= 1000`
- `1 <= wordDict[i].length <= 20`
- `s` 和 `wordDict[i]` 仅由小写英文字母组成
- `wordDict` 中的所有字符串 **互不相同**

#### 解题思路：

1. **理解问题**：给定一个字符串 `s` 和一个字符串列表 `wordDict`，需要判断 `s` 是否可以被拆分成一个或多个在 `wordDict` 中出现的单词。
2. **定义状态**：定义 `dp[i]` 表示字符串 `s` 的前 `i` 个字符能否被拆分成 `wordDict` 中的单词。
3. **状态转移方程**：`dp[i] = dp[j] && check(s[j..i-1])`，其中 `0 <= j < i`，`check(s[j..i-1])` 表示子串 `s[j..i-1]` 是否在 `wordDict` 中。如果存在一个 `j` 满足 `dp[j]` 为真且 `s[j..i-1]` 在字典中，那么 `dp[i]` 也为真。
4. **初始化**：`dp[0] = true`，因为空字符串总是字典的一部分。
5. **遍历顺序**：从左到右遍历字符串 `s`，对于每个位置，再从当前位置向前遍历检查。
6. **返回结果**：`dp[s.length()]`，表示整个字符串 `s` 能否被拆分。

```python
def wordBreak(s, wordDict):
    wordSet = set(wordDict)  # 将 wordDict 转换为集合，加快检索速度
    dp = [False] * (len(s) + 1)  # 初始化 dp 数组
    dp[0] = True  # 空字符串总是字典的一部分

    for i in range(1, len(s) + 1):
        for j in range(i):
            if dp[j] and s[j:i] in wordSet:
                dp[i] = True
                break  # 找到一个满足条件的 j 就可以停止当前循环

    return dp[len(s)]  # 返回整个字符串的拆分结果

# 示例测试
s = "leetcode"
wordDict = ["leet", "code"]
print(wordBreak(s, wordDict))  # 输出: True
```

#### **时间复杂度分析**：

- 时间复杂度：`O(n^2 * m)`，其中 `n` 是字符串 `s` 的长度，`m` 是 `wordDict` 中字符串的平均长度。因为需要遍历 `s` 的每个子串，并且每次检查子串是否在 `wordDict` 中的时间复杂度为 `O(m)`。
- 空间复杂度：`O(n)`，`n` 是字符串 `s` 的长度。主要空间开销在于 `dp` 数组。

#### **常见错误**：

- 不正确初始化 `dp[0]`。`dp[0]` 应该为 `True`，因为空字符串可以认为是任何字典的一部分。
- 忽略了 `wordDict` 转换为集合以提高查找效率的步骤。
- 在内层循环中，没有在找到第一个使 `dp[i]` 为真的 `j` 后跳出循环，导致不必要的计算。

这个解法提供了一种高效的方式来解决单词拆分问题，通过动态规划避免了冗余的计算，确保了算法的效率。

---

### [关于多重背包 (56.携带矿石资源)](https://kamacoder.com/problempage.php?pid=1066)

#### 题目描述

你是一名宇航员，即将前往一个遥远的行星。在这个行星上，有许多不同类型的矿石资源，每种矿石都有不同的重要性和价值。你需要选择哪些矿石带回地球，但你的宇航舱有一定的容量限制。

给定一个宇航舱，最大容量为 C。现在有 N 种不同类型的矿石，每种矿石有一个重量 w[i]，一个价值 v[i]，以及最多 k[i] 个可用。不同类型的矿石在地球上的市场价值不同。你需要计算如何在不超过宇航舱容量的情况下，最大化你所能获取的总价值。

#### 输入描述

输入共包括四行，第一行包含两个整数 C 和 N，分别表示宇航舱的容量和矿石的种类数量。

接下来的三行，每行包含 N 个正整数。具体如下：

第二行包含 N 个整数，表示 N 种矿石的重量。

第三行包含 N 个整数，表示 N 种矿石的价格。

第四行包含 N 个整数，表示 N 种矿石的可用数量上限。

#### 输出描述

输出一个整数，代表获取的最大价值。

#### 输入示例

```other
10 3
1 3 4
15 20 30
2 3 2
```

#### 输出示例

```other
90
```

#### 提示信息

数据范围：

1 <= C <= 10000;

1 <= N <= 10000;

1 <= w[i], v[i], k[i] <= 10000;

#### 解题思路：

多重背包问题是背包问题的一个变种，在这个问题中，每种物品都有一定数量的限制。这个问题可以通过以下几个步骤来解决：

1. **理解问题**：给定一个背包容量 `C`，`N` 种物品，每种物品有其重量 `w[i]`，价值 `v[i]`，和数量限制 `k[i]`。目标是在不超过背包容量的前提下，最大化背包内物品的总价值。
2. **确定状态和选择**：定义 `dp[i][j]` 表示前 `i` 种物品，在容量为 `j` 的情况下的最大价值。每次加入物品时，可以选择加入 0 到 `k[i]` 个第 `i` 种物品。
3. **状态转移方程**：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i], ..., dp[i-1][j-k[i]*w[i]] + k[i]*v[i])`。这里要遍历每种可能加入的物品数量，选择能够使 `dp[i][j]` 最大的方案。
4. **初始化**：`dp[0][j] = 0`（没有物品时价值为 0），`dp[i][0] = 0`（容量为 0 时价值为 0）。
5. **遍历顺序**：首先遍历物品，对每种物品再遍历背包容量。在处理每种物品时，需要逆向遍历背包容量，以避免重复计算。
6. **优化空间复杂度**：注意到状态转移方程中 `dp[i][j]` 只依赖于 `dp[i-1][...]` 的值，因此可以通过滚动数组的方式将空间复杂度从 `O(N*C)` 优化到 `O(C)`。

```python
def max_value(C, N, weights, values, quantities):
    dp = [0] * (C + 1)  # 初始化 dp 数组，大小为 C+1，初始值为 0

    for i in range(N):  # 遍历每一种物品
        for count in range(1, quantities[i] + 1):  # 对每种物品的每个数量
            for j in range(C, weights[i] * count - 1, -1):  # 逆向遍历背包容量
                dp[j] = max(dp[j], dp[j - weights[i] * count] + values[i] * count)

    return dp[C]

# 输入示例
C, N = 10, 3
weights = [1, 3, 4]
values = [15, 20, 30]
quantities = [2, 3, 2]

# 输出最大价值
print(max_value(C, N, weights, values, quantities))  # 输出: 90
```

#### **时间复杂度分析**：

- 时间复杂度：最坏情况下为 `O(N*C*K)`，其中 `K` 是物品数量的平均值。但由于内部的循环是基于物品数量的，实际时间复杂度可能低于此值。
- 空间复杂度：`O(C)`，使用了滚动数组优化空间复杂度。

#### **常见错误**：

- 在更新 `dp[j]` 时未正确处理物品数量，导致重复计算或遗漏可能的物品组合。
- 未逆向遍历背包容量，导致同一物品被多次加入背包。

通过以上方法，可以有效解决多重背包问题，并在给定的背包容量内实现最大价值的获取。

---

### 背包问题总结篇

关于这几种常见的背包，其关系如下：

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/20230310000726.png)

在讲解背包问题的时候，我们都是按照如下五部来逐步分析，相信大家也体会到，把这五部都搞透了，算是对动规来理解深入了。

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

#### 背包递推公式

问能否能装满背包（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]); ，对应题目如下：

- [动态规划：416.分割等和子集(opens new window)](https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html)
- [动态规划：1049.最后一块石头的重量 II(opens new window)](https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html)

问装满背包有几种方法：dp[j] += dp[j - nums[i]] ，对应题目如下：

- [动态规划：494.目标和(opens new window)](https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html)
- [动态规划：518. 零钱兑换 II(opens new window)](https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html)
- [动态规划：377.组合总和Ⅳ(opens new window)](https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html)
- [动态规划：70. 爬楼梯进阶版（完全背包）(opens new window)](https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html)

问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); ，对应题目如下：

- [动态规划：474.一和零(opens new window)](https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html)

问装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j]); ，对应题目如下：

- [动态规划：322.零钱兑换(opens new window)](https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html)
- [动态规划：279.完全平方数](https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html)

#### 遍历顺序

#### 01背包

在[动态规划：关于01背包问题，你该了解这些！ (opens new window)](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html)中我们讲解二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。

和[动态规划：关于01背包问题，你该了解这些！（滚动数组） (opens new window)](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html)中，我们讲解一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。

**一维dp数组的背包在遍历顺序上和二维dp数组实现的01背包其实是有很大差异的，大家需要注意！**

#### 完全背包

说完01背包，再看看完全背包。

在[动态规划：关于完全背包，你该了解这些！ (opens new window)](https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html)中，讲解了纯完全背包的一维dp数组实现，先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。

但是仅仅是纯完全背包的遍历顺序是这样的，题目稍有变化，两个for循环的先后顺序就不一样了。

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

相关题目如下：

- 求组合数：[动态规划：518.零钱兑换II(opens new window)](https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html)
- 求排列数：[动态规划：377. 组合总和 Ⅳ (opens new window)](https://mp.weixin.qq.com/s/Iixw0nahJWQgbqVNk8k6gA)、[动态规划：70. 爬楼梯进阶版（完全背包）(opens new window)](https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html)

如果求最小数，那么两层for循环的先后顺序就无所谓了，相关题目如下：

- 求最小数：[动态规划：322. 零钱兑换 (opens new window)](https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html)、[动态规划：279.完全平方数(opens new window)](https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html)

**对于背包问题，其实递推公式算是容易的，难是难在遍历顺序上，如果把遍历顺序搞透，才算是真正理解了**。

#### 代码随想录算法训练营第四十八天 | 198.打家劫舍，213.打家劫舍II，337.打家劫舍III

#### ● day 48 任务以及具体安排：[第九章 动态规划part09](https://docs.qq.com/doc/DUGd5ZkNZS1NsYkFk) (1.29)

# 第九章 动态规划part09

●  198.打家劫舍

●  213.打家劫舍II

●  337.打家劫舍III

详细布置

今天就是打家劫舍的一天，这个系列不算难，大家可以一口气拿下。

198.打家劫舍

视频讲解：[https://www.bilibili.com/video/BV1Te411N7SX](https://www.bilibili.com/video/BV1Te411N7SX)

[代码随想录](https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html)

213.打家劫舍II

视频讲解：[https://www.bilibili.com/video/BV1oM411B7xq](https://www.bilibili.com/video/BV1oM411B7xq)

[代码随想录](https://programmercarl.com/0213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII.html)

337.打家劫舍III

视频讲解：[https://www.bilibili.com/video/BV1H24y1Q7sY](https://www.bilibili.com/video/BV1H24y1Q7sY)

[代码随想录](https://programmercarl.com/0337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII.html)

[ChatGPT](https://chat.openai.com/share/bb3cb29c-c440-4297-9e1c-42560dbe8d38)

---

### [198.打家劫舍](https://leetcode.com/problems/house-robber/description/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

- 示例 1：
- 输入：[1,2,3,1]
- 输出：4

解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。   偷窃到的最高金额 = 1 + 3 = 4 。

- 示例 2：
- 输入：[2,7,9,3,1]
- 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。   偷窃到的最高金额 = 2 + 9 + 1 = 12 。

提示：

- 0 <= nums.length <= 100
- 0 <= nums[i] <= 400

#### 解题思路：

1. **定义状态**：定义一个数组 `dp`，其中 `dp[i]` 表示到第 `i` 个房屋时能偷窃到的最高金额。
2. **状态转移方程**：对于第 `i` 个房子，有两种选择：偷或不偷。
   - 如果不偷，那么总金额就是到上一个房子为止的最高金额，即 `dp[i-1]`。
   - 如果偷，那么总金额就是当前房子的金额加上到第 `i-2` 个房子为止的最高金额，即 `nums[i] + dp[i-2]`。

   因此，`dp[i] = max(dp[i-1], nums[i] + dp[i-2])`。

3. **初始化**：`dp[0] = nums[0]`（只有一个房子时只能偷这一个），当房子数量大于1时，`dp[1] = max(nums[0], nums[1])`（两个房子时选择金额较大的那个偷）。
4. **遍历**：从第三个房子开始遍历，直到最后一个房子，计算 `dp[i]`。
5. **结果**：`dp` 数组的最后一个元素 `dp[n-1]` 就是答案，其中 `n` 是房子的总数。

```python
def rob(nums):
    # 如果房屋数组为空，则直接返回0
    if not nums:
        return 0
    # 如果房屋数量小于等于2，直接返回金额最大的房屋
    if len(nums) <= 2:
        return max(nums)
    
    # 初始化dp数组，dp[i]表示到第i个房屋时能偷窃到的最高金额
    dp = [0] * len(nums)
    dp[0] = nums[0]  # 只有一个房子时只能偷这一个
    dp[1] = max(nums[0], nums[1])  # 两个房子时选择金额较大的那个偷
    
    # 从第三个房子开始遍历
    for i in range(2, len(nums)):
        # 对于第i个房子，选择偷或不偷，取能得到的最大金额
        dp[i] = max(dp[i-1], nums[i] + dp[i-2])
    
    # dp数组的最后一个元素就是能偷窃到的最高金额
    return dp[-1]
```

**时间复杂度**：`O(n)`，其中 `n` 是数组 `nums` 的长度，因为我们只需要遍历一次数组。

**空间复杂度**：`O(n)`，用于存储 `dp` 数组。

**常见错误或难点**：

- 初始化条件设置错误，尤其是当房子数量小于2时。
- 状态转移方程理解错误，没有正确处理偷与不偷的情况。

可以使用示例输入 `[1,2,3,1]` 和 `[2,7,9,3,1]` 来验证上述代码。

---

### [213.打家劫舍II](https://leetcode.com/problems/house-robber-ii/description/)

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。

示例 1：

- 输入：nums = [2,3,2]
- 输出：3
- 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
- 示例 2：
- 输入：nums = [1,2,3,1]
- 输出：4
- 解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。偷窃到的最高金额 = 1 + 3 = 4 。
- 示例 3：
- 输入：nums = [0]
- 输出：0

提示：

- 1 <= nums.length <= 100
- 0 <= nums[i] <= 1000

#### 解题思路：

打家劫舍II的问题在于房屋形成了一个圈，意味着第一个房屋和最后一个房屋不能同时被偷窃，这增加了问题的复杂性。我们可以将其分解为两个子问题来解决：

1. 不考虑偷窃第一个房屋，即从第二个房屋到最后一个房屋中选择偷窃，这转换为一个标准的打家劫舍问题。
2. 不考虑偷窃最后一个房屋，即从第一个房屋到倒数第二个房屋中选择偷窃，同样转换为一个标准的打家劫舍问题。

对于这两种情况，我们分别计算可以偷窃到的最高金额，然后取这两个结果的最大值作为最终答案。这样我们就可以复用之前打家劫舍的解决方案。

#### 解决方案步骤：

1. **边界情况处理**：如果房屋数量不足两个，则直接返回最大金额。
2. **定义一个辅助函数**：用于计算在不形成圈的情况下，一段连续房屋中可以偷窃到的最高金额。
3. **计算两种情况**：
   - 从第一个房屋到倒数第二个房屋的最高金额。
   - 从第二个房屋到最后一个房屋的最高金额。
4. **取两种情况的最大值**：这就是在房屋形成圈的情况下，可以偷窃到的最高金额。

```python
def rob(nums):
    # 辅助函数，用于计算不形成圈的情况下的最高金额
    def rob_line(nums):
        if len(nums) == 1: return nums[0]
        dp = [0] * len(nums)
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, len(nums)):
            dp[i] = max(dp[i-1], nums[i] + dp[i-2])
        return dp[-1]
    
    n = len(nums)
    # 处理边界情况
    if n == 1:
        return nums[0]
    # 计算两种情况的最高金额并取最大值
    return max(rob_line(nums[:-1]), rob_line(nums[1:]))

# 示例测试
print(rob([2,3,2]))  # 输出: 3
print(rob([1,2,3,1]))  # 输出: 4
print(rob([0]))  # 输出: 0
```

**时间复杂度**：对于每种情况，时间复杂度都是`O(n)`，所以总的时间复杂度也是`O(n)`。

**空间复杂度**：`O(n)`，主要是辅助函数中的`dp`数组占用的空间。

**常见错误或难点**：

- 忘记处理房屋形成圈的情况，即没有将问题分解为两个子问题。
- 边界条件处理不当，比如只有一个房屋的情况。

---

### [337.打家劫舍III](https://leetcode.com/problems/house-robber-iii/description/)

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。

除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。

给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。

**示例 1:**

![Image.jpg](https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg)

**输入:** root = [3,2,3,null,3,null,1]

**输出:** 7

**解释:** 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7

**示例 2:**

![Image.jpg](https://assets.leetcode.com/uploads/2021/03/10/rob2-tree.jpg)

**输入:** root = [3,4,5,1,3,null,1]

**输出:** 9

**解释:** 小偷一晚能够盗取的最高金额 4 + 5 = 9

**提示：**

- 树的节点数在 `[1, 104]` 范围内
- `0 <= Node.val <= 104`

#### 解题思路：

打家劫舍III问题是一个在二叉树上的动态规划问题。与前两个版本的打家劫舍问题不同，这个问题中房屋是按照二叉树结构排列的，这就意味着我们不能简单地使用线性的动态规划解法。这里，我们需要采用递归的方式来解决问题，同时考虑偷窃某个节点与不偷窃某个节点时的最优解。

#### 解题思路

1. **递归函数的定义**：对于每个节点，我们需要考虑偷窃这个节点和不偷窃这个节点两种情况。因此，我们可以定义一个递归函数，它返回一个包含两个元素的数组，其中：
   - 第一个元素表示不偷当前节点时，从这个节点的子树中能够获得的最大金额。
   - 第二个元素表示偷当前节点时，从这个节点的子树中能够获得的最大金额。
2. **递归的边界条件**：当递归到空节点时，不偷窃和偷窃的收益都是0。
3. **递归逻辑**：对于任意一个节点，如果我们决定偷这个节点，那么我们就不能偷它的直接子节点，但可以继续考虑偷它的孙子节点。如果我们决定不偷这个节点，那么我们可以考虑偷它的直接子节点。

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

def rob(root):
    def helper(node):
        if not node:
            return [0, 0]  # 第一个元素表示不偷当前节点，第二个元素表示偷当前节点
        
        left = helper(node.left)
        right = helper(node.right)
        
        # 不偷当前节点，子节点可以偷也可以不偷，取决于哪种选择更有利
        rob_no = max(left[0], left[1]) + max(right[0], right[1])
        
        # 偷当前节点，那么两个子节点就不能偷
        rob_yes = node.val + left[0] + right[0]
        
        return [rob_no, rob_yes]
    
    result = helper(root)
    return max(result[0], result[1])

# 示例代码使用
# 构建示例二叉树
root = TreeNode(3)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.left.right = TreeNode(3)
root.right.right = TreeNode(1)

print(rob(root))  # 输出应为7，表示偷窃的最高金额
```

这段代码定义了一个二叉树节点类 `TreeNode` 和主函数 `rob`。主函数中定义了一个辅助函数 `helper`，用于递归计算每个节点偷与不偷时的最大收益，并返回一个包含这两种情况的数组。最后，我们从根节点调用这个辅助函数，并返回两种情况中的最大值作为最终结果。

**时间复杂度**：`O(n)`，其中 `n` 是二叉树的节点数。每个节点只访问一次。

**空间复杂度**：`O(h)`，其中 `h` 是二叉树的高度，这是因为递归调用栈的深度取决于二叉树的高度。

#### 代码随想录算法训练营第四十九天 | 121. 买卖股票的最佳时机，122.买卖股票的最佳时机II

#### ● day 49 任务以及具体安排：[第九章 动态规划part10](https://docs.qq.com/doc/DUFhzV29ZSEtFVkto) (1.30)

# 第九章 动态规划part10

●  121. 买卖股票的最佳时机

●  122.买卖股票的最佳时机II

详细布置

股票问题是一个动态规划的系列问题，今日安排的题目不多，大家可以慢慢消化。

121. 买卖股票的最佳时机

视频讲解：[https://www.bilibili.com/video/BV1Xe4y1u77q](https://www.bilibili.com/video/BV1Xe4y1u77q)

[代码随想录](https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html)

122.买卖股票的最佳时机II

视频讲解：[https://www.bilibili.com/video/BV1D24y1Q7Ls](https://www.bilibili.com/video/BV1D24y1Q7Ls)

[代码随想录](https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html)

[ChatGPT](https://chat.openai.com/share/90ca84d6-b02e-4b54-b6f6-6da35cfde38e)

---

### [121. 买卖股票的最佳时机](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/)

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

**示例 1：**

**输入：**[7,1,5,3,6,4]

输出：5

解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

**示例 2：**

输入：prices = [7,6,4,3,1]

输出：0

解释：在这种情况下, 没有交易完成, 所以最大利润为 0。

**提示：**

- `1 <= prices.length <= 105`
- `0 <= prices[i] <= 104`

#### 解题思路：

在动态规划的框架下，我们可以这样考虑问题：在第i天，我们有两种状态，持有股票和不持有股票，对于每一天，我们需要根据前一天的状态来更新这两个状态。

1. 如果我们在第i天不持有股票，那么我们可能是在第i-1天也不持有股票，然后选择在第i天什么都不做；或者是在第i-1天持有股票，然后在第i天卖出。因此，不持有股票的状态可以由前一天不持有股票的状态和前一天持有股票然后在今天卖出的状态中的最大值转移而来。
2. 如果我们在第i天持有股票，那么我们可能是在第i-1天就持有股票，然后选择在第i天什么都不做；或者是在第i天买入股票（注意由于只允许一次交易，所以买入股票的状态只能从初始状态转移过来）。

基于以上分析，我们可以定义状态转移方程如下：

- `dp[i][0]` 表示第i天不持有股票时的最大利润，`dp[i][1]` 表示第i天持有股票时的最大利润。
- 状态转移方程为：
   - `dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])`
   - `dp[i][1] = max(dp[i-1][1], -prices[i])` （因为只允许一次交易，所以买入的成本就是`-prices[i]`）

由于每一天的状态只和前一天的状态有关，我们可以用两个变量而不是数组来保存这些信息以优化空间复杂度。

```python
def maxProfit(prices):
    if not prices:
        return 0
    
    n = len(prices)
    dp = [[0, 0] for _ in range(n)]
    dp[0][0], dp[0][1] = 0, -prices[0]
    
    for i in range(1, n):
        dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])  # 不持有股票的状态转移
        dp[i][1] = max(dp[i-1][1], -prices[i])  # 持有股票的状态转移

    return dp[n-1][0]  # 最后一天不持有股票的最大利润
```

#### 时间复杂度分析：

- 由于我们只需要遍历一次价格数组，所以时间复杂度是 O(n)，其中 n 是数组的长度。

#### 空间复杂度分析：

- 我们使用了固定的几个变量来存储状态，所以空间复杂度是 O(1)。

---

### [122.买卖股票的最佳时机II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/)

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

- 示例 1:
- 输入: [7,1,5,3,6,4]
- 输出: 7

   解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

- 示例 2:
- 输入: [1,2,3,4,5]
- 输出: 4

   解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

- 示例 3:
- 输入: [7,6,4,3,1]
- 输出: 0

   解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

提示：

- 1 <= prices.length <= 3 * 10 ^ 4
- 0 <= prices[i] <= 10 ^ 4

#### 解题思路：

对于“买卖股票的最佳时机 II”问题，由于允许进行多次交易，动态规划的方法需要稍作调整。我们仍然使用`dp[i][0]`表示第`i`天结束时不持有股票的最大利润，`dp[i][1]`表示第`i`天结束时持有股票的最大利润，但状态转移方程需要根据多次交易的条件进行调整。

状态转移方程如下：

- `dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])`：第`i`天结束时不持有股票，可能是前一天也不持有，或者前一天持有但在第`i`天卖出了。
- `dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])`：第`i`天结束时持有股票，可能是前一天也持有，或者前一天不持有但在第`i`天买入了。由于允许多次交易，所以买入的成本是前一天不持有股票的利润减去当天的价格。

初始化条件：

- `dp[0][0] = 0`：第0天结束时不持有股票的利润为0。
- `dp[0][1] = -prices[0]`：第0天结束时持有股票，成本为第0天的价格。

```python
def maxProfit(prices):
    n = len(prices)  # 获取股票价格数组的长度
    if n == 0:  # 如果数组为空，直接返回利润为0
        return 0

    # 初始化dp数组，dp[i][0]表示第i天不持有股票的最大利润，dp[i][1]表示第i天持有股票的最大利润
    dp = [[0 for _ in range(2)] for _ in range(n)]
    dp[0][0], dp[0][1] = 0, -prices[0]  # 第0天的初始状态，不持有股票利润为0，持有股票的利润为负的第一天的股票价格
    
    for i in range(1, n):  # 从第1天开始遍历到最后一天
        # 第i天不持有股票的最大利润可以从两个状态转移而来：
        # 1. 第i-1天也不持有股票，第i天什么都不做；
        # 2. 第i-1天持有股票，但在第i天卖出了股票。
        dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])

        # 第i天持有股票的最大利润也可以从两个状态转移而来：
        # 1. 第i-1天已经持有股票，第i天什么都不做；
        # 2. 第i-1天不持有股票，但在第i天买入了股票（注意因为可以多次交易，所以直接从第i-1天不持有股票的状态转移过来）。
        dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
    
    # 最后一天不持有股票的情况就是我们能获得的最大利润
    return dp[n-1][0]
```

#### 时间复杂度分析：

- 这段代码遍历了一次价格数组，所以时间复杂度为O(n)，其中n是价格数组的长度。

#### 空间复杂度分析：

- 使用了一个二维数组来存储状态，所以空间复杂度为O(n)。

这个动态规划方法考虑了每一天买入或卖出股票的所有可能性，并且通过状态转移方程找到了最大利润。由于允许多次交易，关键点在于理解每天持有股票的状态可以从前一天不持有股票的状态转移而来，即在前一天的基础上购买今天的股票。

#### 代码随想录算法训练营第五十天 | 123.买卖股票的最佳时机III，188.买卖股票的最佳时机IV

#### ● day 50 任务以及具体安排：[第九章 动态规划part11](https://docs.qq.com/doc/DUEtsRGRXT2F2Y0FR) (1.31)

# 第九章 动态规划part11

●  123.买卖股票的最佳时机III

●  188.买卖股票的最佳时机IV

详细布置

123.买卖股票的最佳时机III

这道题一下子就难度上来了，关键在于至多买卖两次，这意味着可以买卖一次，可以买卖两次，也可以不买卖。

视频讲解：[https://www.bilibili.com/video/BV1WG411K7AR](https://www.bilibili.com/video/BV1WG411K7AR)

[代码随想录](https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html)

188.买卖股票的最佳时机IV

本题是123.买卖股票的最佳时机III 的进阶版

视频讲解：[https://www.bilibili.com/video/BV16M411U7XJ](https://www.bilibili.com/video/BV16M411U7XJ)

[代码随想录](https://programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html)

[ChatGPT](https://chat.openai.com/share/ca425a64-0969-4cca-9b77-4493e59da553)

---

### [123.买卖股票的最佳时机III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/)

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

- 示例 1:
- 输入：prices = [3,3,5,0,0,3,1,4]
- 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3。
- 示例 2：
- 输入：prices = [1,2,3,4,5]
- 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
- 示例 3：
- 输入：prices = [7,6,4,3,1]
- 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为0。
- 示例 4：
- 输入：prices = [1] 输出：0

提示：

- 1 <= prices.length <= 10^5
- 0 <= prices[i] <= 10^5

#### 解题思路：

为了解决这个问题，我们可以采用动态规划的方法。这个问题的关键是要理解，尽管我们只能进行两笔交易，但我们可以通过维护四个状态来跟踪到目前为止的最大利润：

1. 第一次买入后的最大利润（buy1）
2. 第一次卖出后的最大利润（sell1）
3. 第二次买入后的最大利润（buy2）
4. 第二次卖出后的最大利润（sell2）

对于每一天，我们都更新这四个状态。最终，sell2将表示完成两笔交易后能得到的最大利润。

#### 解题步骤如下：

- 初始化 buy1, sell1, buy2, sell2 为 -∞, 0, -∞, 0。因为初始时还没有进行任何交易，所以买入的利润设为负无穷大，卖出的利润设为0。
- 遍历价格数组 `prices`，对于每一天的价格 `price`，更新四个状态：
   - `buy1`：在这一天第一次买入股票能得到的最大利润，等于之前的 `buy1` 和这一天买入股票（即 `-price`）的较大者。
   - `sell1`：在这一天第一次卖出股票能得到的最大利润，等于之前的 `sell1` 和这一天卖出股票（即 `buy1 + price`）的较大者。
   - `buy2`：在这一天第二次买入股票能得到的最大利润，等于之前的 `buy2` 和这一天买入股票（即 `sell1 - price`）的较大者。
   - `sell2`：在这一天第二次卖出股票能得到的最大利润，等于之前的 `sell2` 和这一天卖出股票（即 `buy2 + price`）的较大者。
- 遍历完成后，`sell2`即为最大利润。

```python
def maxProfit(prices):
    # 初始化四个状态，分别表示第一次买入、第一次卖出、第二次买入、第二次卖出后的最大利润
    buy1, sell1, buy2, sell2 = float('-inf'), 0, float('-inf'), 0
    
    for price in prices:  # 遍历每一天的股票价格
        buy1 = max(buy1, -price)  # 第一次买入的最大利润，取之前买入的利润和当天买入的利润的较大者
        sell1 = max(sell1, buy1 + price)  # 第一次卖出的最大利润，取之前卖出的利润和当天卖出的利润的较大者
        buy2 = max(buy2, sell1 - price)  # 第二次买入的最大利润，取之前买入的利润和用第一次卖出的利润减去当天价格的较大者
        sell2 = max(sell2, buy2 + price)  # 第二次卖出的最大利润，取之前卖出的利润和用第二次买入的利润加上当天价格的较大者
    
    return sell2  # 返回最终的最大利润，即第二次卖出后的利润
```

时间复杂度是 O(N)，因为我们只需要遍历一次价格数组，其中 N 是数组的长度。空间复杂度是 O(1)，因为我们只需要常数空间来存储四个状态。

#### 常见错误或难点：

- 初始化状态时不正确。正确的初始化是将买入状态设置为负无穷大，卖出状态设置为0。
- 更新状态时的顺序错误。应该先更新买入状态，再更新卖出状态。
- 不理解为何要进行四次状态更新。这是因为题目允许进行两次交易，每次交易包含买入和卖出两个动作，所以总共有四个状态。

---

### [188.买卖股票的最佳时机IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/)

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

- 示例 1：
- 输入：k = 2, prices = [2,4,1]
- 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2。
- 示例 2：
- 输入：k = 2, prices = [3,2,6,5,0,3]
- 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4。随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。

提示：

- 0 <= k <= 100
- 0 <= prices.length <= 1000
- 0 <= prices[i] <= 1000

#### 解题思路：

为了解决这个问题，我们可以使用动态规划。这个问题是"买卖股票的最佳时机 III"的一个更通用的形式，其中交易次数由2变为了任意k次。我们可以使用一个二维数组`dp[i][j]`来表示在第i天结束时，进行了j次交易并且当前手上没有股票时的最大利润。这里`dp[i][j]`可以分为两种情况：

1. 第i天没有进行任何操作，即第i-1天就已经完成了j次交易，此时的利润就是`dp[i-1][j]`。
2. 第i天卖出了股票，那么我们需要找到一个最优的买入点，这个买入点在第i天之前的某一天，我们假设是第m天（0 <= m < i）。那么在第m天买入股票后的利润为`dp[m][j-1] - prices[m]`，再加上第i天卖出股票的利润`prices[i]`。

因此，状态转移方程为：

$$[ dp[i][j] = \max(dp[i-1][j], \max_{0 \leq m < i}(dp[m][j-1] - prices[m] + prices[i])) ]$$

#### 解题步骤如下：

1. 初始化dp数组，`dp[0][...] = 0`，因为在第0天时不可能完成任何交易，所以利润为0。
2. 遍历每一天，对于每一天，再遍历从1到k的每一次交易。
3. 更新`dp[i][j]`，考虑不操作和卖出两种情况，取二者的最大值。
4. 最终答案为`dp[n-1][k]`，其中n为prices的长度。

```python
def maxProfit(k, prices):
    if not prices:  # 如果prices为空，则无法进行交易，利润为0
        return 0

    n = len(prices)
    # 当k大于等于n/2时，相当于没有交易次数限制，因为n天最多进行n/2次交易
    if k >= n // 2:
        # 使用贪心算法计算最大利润，即只要后一天比前一天价格高，就执行买卖
        return sum(max(prices[i+1] - prices[i], 0) for i in range(n-1))

    # 初始化dp数组，dp[i][j]表示第i天结束时，最多进行j次交易，且手上不持有股票的最大利润
    dp = [[0] * (k+1) for _ in range(n)]
    for j in range(1, k+1):  # 遍历每一次交易
        max_buy = -prices[0]  # 初始化第一天买入股票的成本
        for i in range(1, n):  # 遍历每一天
            # 更新dp[i][j]，考虑在第i天卖出或不操作的情况，取二者的最大值
            dp[i][j] = max(dp[i-1][j], prices[i] + max_buy)
            # 更新买入成本，考虑在第i天买入或保持之前的买入状态的情况，取二者的最大值
            max_buy = max(max_buy, dp[i-1][j-1] - prices[i])
    # 返回第n-1天，最多进行k次交易的最大利润
    return dp[n-1][k]
```

这里有一个优化点：当k非常大时，其实相当于不限交易次数，所以可以简化为贪心算法，只要后一天的价格比前一天高，就执行一次买卖操作。

#### 时空复杂度：

时间复杂度是 O(nk)，其中n是天数，k是交易次数上限。

空间复杂度是 O(nk)，用于存储dp数组。

#### 常见错误或难点：

- 初始化`dp`数组时出错。
- 没有考虑到当k非常大时，问题可以简化为不限交易次数的情况。
- 在更新`dp[i][j]`时，没有正确地处理买入和卖出的逻辑。

#### 代码随想录算法训练营第五十一天 | 309.最佳买卖股票时机含冷冻期，714.买卖股票的最佳时机含手续费，股票问题总结

#### ● day 51 任务以及具体安排：[第九章 动态规划part12](https://docs.qq.com/doc/DUGt6dWVUUFhHUlpH) (2.1)

# 第九章 动态规划part12

●  309.最佳买卖股票时机含冷冻期

●  714.买卖股票的最佳时机含手续费

● 总结

### 309.最佳买卖股票时机含冷冻期

本题加了一个冷冻期，状态就多了，有点难度，大家要把各个状态分清，思路才能清晰

视频讲解：[https://www.bilibili.com/video/BV1rP4y1D7ku](https://www.bilibili.com/video/BV1rP4y1D7ku)

[代码随想录](https://programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html)

### 714.买卖股票的最佳时机含手续费

相对122.买卖股票的最佳时机II ，本题只需要在计算卖出操作的时候减去手续费就可以了，代码几乎是一样的，可以尝试自己做一做。

视频讲解：[https://www.bilibili.com/video/BV1z44y1Z7UR](https://www.bilibili.com/video/BV1z44y1Z7UR)

[代码随想录](https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html)

### 股票总结

股票问题做一个总结吧

[代码随想录](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87.html)

[ChatGPT](https://chat.openai.com/share/63860c7e-353a-4352-98fd-8f82141aa0a0)

---

### [309.最佳买卖股票时机含冷冻期](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)

给定一个整数数组`prices`，其中第  `prices[i]` 表示第 `_i_` 天的股票价格 。​

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

**输入:** prices = [1,2,3,0,2]

**输出:** 3

**解释:** 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

**示例 2:**

**输入:** prices = [1]

**输出:** 0

**提示：**

- `1 <= prices.length <= 5000`
- `0 <= prices[i] <= 1000`

这个问题是一个经典的动态规划问题，我们可以用动态规划来设计算法计算出最大利润。这里，我们需要维护三个状态：持有股票、不持有股票且处于冷冻期、不持有股票且不处于冷冻期，并更新这些状态下的最大利润。

![Image.png](https://code-thinking-1253855093.file.myqcloud.com/pics/518d5baaf33f4b2698064f8efb42edbf.png)

#### 解题思路：

1. 定义三个数组：
   - `hold[i]` 表示第 i 天结束时，持有股票所得到的最大利润。
   - `freeze[i]` 表示第 i 天结束时，处于冷冻期的最大利润。
   - `idle[i]` 表示第 i 天结束时，不持有股票且不处于冷冻期的最大利润。
2. 初始化：
   - `hold[0] = -prices[0]`，因为第 0 天买入股票，利润为 -prices[0]。
   - `freeze[0] = 0`，第 0 天不可能处于冷冻期。
   - `idle[0] = 0`，第 0 天没有进行任何操作，利润为 0。
3. 状态转移方程：
   - `hold[i] = max(hold[i-1], idle[i-1] - prices[i])`，持有股票的最大利润要么是前一天就持有，要么是前一天不持有且不处于冷冻期，今天买入。
   - `freeze[i] = hold[i-1] + prices[i]`，处于冷冻期的最大利润是前一天持有股票，今天卖出。
   - `idle[i] = max(idle[i-1], freeze[i-1])`，不持有股票且不处于冷冻期的最大利润，要么是前一天也是这个状态，要么是前一天处于冷冻期。
4. 结果：最大利润为 `max(freeze[n-1], idle[n-1])`，其中 n 是天数。

```python
def maxProfit(prices):
    # 如果价格列表为空，则直接返回 0
    if not prices:
        return 0
    n = len(prices)
    # 初始化三个状态数组
    hold, freeze, idle = [0] * n, [0] * n, [0] * n  # hold:持有股票，freeze:冷冻期，idle:不持有且不在冷冻期
    hold[0] = -prices[0]  # 第一天买入股票的情况
    
    for i in range(1, n):
        # 对于持有股票状态，考虑保持前一天的持有状态或者是前一天不持有不在冷冻期且在当天买入
        hold[i] = max(hold[i - 1], idle[i - 1] - prices[i])
        # 对于冷冻期状态，只能由前一天持有股票且在今天卖出转换而来
        freeze[i] = hold[i - 1] + prices[i]
        # 对于不持有且不在冷冻期状态，考虑保持前一天的相同状态或者是从冷冻期转换过来
        idle[i] = max(idle[i - 1], freeze[i - 1])
    
    # 最终的最大利润为最后一天处于冷冻期或不持有股票且不在冷冻期状态的较大者
    return max(freeze[n - 1], idle[n - 1])

# 测试示例
prices = [1, 2, 3, 0, 2]
print(maxProfit(prices))  # 输出: 3
```

#### 时间和空间复杂度分析：

- 时间复杂度：O(n)，其中 n 是数组 `prices` 的长度，因为我们只需要遍历一次数组。
- 空间复杂度：O(n)，我们需要三个数组来记录状态。

#### 常见错误：

1. 没有考虑冷冻期的影响，即在买入前没有判断前一天是否卖出股票。
2. 在状态转移方程中没有考虑所有可能的状态，比如在计算 `idle[i]` 时，忘记了 `freeze[i-1]` 这一状态。

理解这个问题的关键在于把握住每一天结束时可能的状态，以及如何从前一天的状态转移过来。希望这个解答能帮助你理解如何解决这类动态规划问题。

---

### [714.买卖股票的最佳时机含手续费](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/)

给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

**示例 1：**

输入：prices = [1, 3, 2, 8, 4, 9], fee = 2

输出：8

解释：能够达到的最大利润:

在此处买入 prices[0] = 1

在此处卖出 prices[3] = 8

在此处买入 prices[4] = 4

在此处卖出 prices[5] = 9

总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8

**示例 2：**

输入：prices = [1,3,7,5,10,3], fee = 3

输出：6

**提示：**

- `1 <= prices.length <= 5 * 104`
- `1 <= prices[i] < 5 * 104`
- `0 <= fee < 5 * 104`

这个问题也是一个动态规划问题，与之前的股票问题类似，但这里加入了每次交易需要支付一定的手续费。我们同样可以使用动态规划的思想来解决这个问题，通过维护两个状态：持有股票和不持有股票，来计算每一天结束时的最大利润。

### 解题思路：

1. 定义两个数组：
   - `hold[i]` 表示第 i 天结束时持有股票所得到的最大利润。
   - `notHold[i]` 表示第 i 天结束时不持有股票所得到的最大利润。
2. 初始化：
   - `hold[0] = -prices[0]`，因为第 0 天买入股票，利润为 -prices[0]。
   - `notHold[0] = 0`，第 0 天不持有股票，利润为 0。
3. 状态转移方程：
   - `hold[i] = max(hold[i-1], notHold[i-1] - prices[i])`，第 i 天持有股票的利润要么是前一天就持有，要么是前一天不持有今天买入。
   - `notHold[i] = max(notHold[i-1], hold[i-1] + prices[i] - fee)`，第 i 天不持有股票的利润要么是前一天就不持有，要么是前一天持有今天卖出并支付手续费。
4. 结果：最大利润为 `notHold[n-1]`，其中 n 是天数。

```python
def maxProfit(prices, fee):
    n = len(prices)
    hold, notHold = [0] * n, [0] * n  # hold: 持有股票状态的利润，notHold: 不持有股票状态的利润
    hold[0] = -prices[0]  # 初始状态，第一天买入股票
    
    for i in range(1, n):
        # 持有股票状态的最大利润：保持前一天的持有状态或前一天不持有今天买入
        hold[i] = max(hold[i - 1], notHold[i - 1] - prices[i])
        # 不持有股票状态的最大利润：保持前一天的不持有状态或前一天持有今天卖出并扣除手续费
        notHold[i] = max(notHold[i - 1], hold[i - 1] + prices[i] - fee)
    
    return notHold[n - 1]  # 返回最后一天不持有股票的最大利润

# 测试示例
prices = [1, 3, 2, 8, 4, 9]
fee = 2
print(maxProfit(prices, fee))  # 输出: 8
```

### 时间和空间复杂度分析：

- 时间复杂度：O(n)，其中 n 是数组 `prices` 的长度，因为我们只需要遍历一次数组。
- 空间复杂度：O(n)，我们需要两个数组来记录状态。

---

股票问题总结篇

![Image.jpg](https://code-thinking.cdn.bcebos.com/pics/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.jpg)

- [动态规划：121.买卖股票的最佳时机(opens new window)](https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html)
- [动态规划：122.买卖股票的最佳时机II(opens new window)](https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html)
- [动态规划：123.买卖股票的最佳时机III(opens new window)](https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html)
- [动态规划：188.买卖股票的最佳时机IV(opens new window)](https://programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html)
- [动态规划：309.最佳买卖股票时机含冷冻期(opens new window)](https://programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html)
- [动态规划：714.买卖股票的最佳时机含手续费](https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html)

#### 解法总结

## 卖股票的最佳时机

[动态规划：121.买卖股票的最佳时机 (opens new window)](https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html)，**股票只能买卖一次，问最大利润**。

【贪心解法】

取最左最小值，取最右最大值，那么得到的差值就是最大利润，代码如下：

```other
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int low = INT_MAX;
        int result = 0;
        for (int i = 0; i < prices.size(); i++) {
            low = min(low, prices[i]);  // 取最左最小价格
            result = max(result, prices[i] - low); // 直接取最大区间利润
        }
        return result;
    }
};
```

【动态规划】

- dp[i][0] 表示第i天持有股票所得现金。
- dp[i][1] 表示第i天不持有股票所得现金。

如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来

- 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]
- 第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i] 所以dp[i][0] = max(dp[i - 1][0], -prices[i]);

如果第i天不持有股票即dp[i][1]， 也可以由两个状态推出来

- 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]
- 第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1][0] 所以dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);

代码如下：

```other
// 版本一
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        if (len == 0) return 0;
        vector<vector<int>> dp(len, vector<int>(2));
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = max(dp[i - 1][0], -prices[i]);
            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
        }
        return dp[len - 1][1];
    }
};
```

- 时间复杂度：O(n)
- 空间复杂度：O(n)

使用滚动数组，代码如下：

```other
// 版本二
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>> dp(2, vector<int>(2)); // 注意这里只开辟了一个2 * 2大小的二维数组
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]);
            dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);
        }
        return dp[(len - 1) % 2][1];
    }
};
```

- 时间复杂度：O(n)
- 空间复杂度：O(1)

## [\#](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87.html#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAii)买卖股票的最佳时机II

[动态规划：122.买卖股票的最佳时机II (opens new window)](https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html)可以多次买卖股票，问最大收益。

【贪心解法】

收集每天的正利润便可，代码如下：

```other
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        for (int i = 1; i < prices.size(); i++) {
            result += max(prices[i] - prices[i - 1], 0);
        }
        return result;
    }
};
```

- 时间复杂度：O(n)
- 空间复杂度：O(1)

【动态规划】

dp数组定义：

- dp[i][0] 表示第i天持有股票所得现金
- dp[i][1] 表示第i天不持有股票所得最多现金

如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来

- 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]
- 第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：dp[i - 1][1] - prices[i]

**注意这里和**[**121. 买卖股票的最佳时机 (opens new window)**](https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html)**唯一不同的地方，就是推导dp[i][0]的时候，第i天买入股票的情况**。

在[121. 买卖股票的最佳时机 (opens new window)](https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html)中，因为股票全程只能买卖一次，所以如果买入股票，那么第i天持有股票即dp[i][0]一定就是 -prices[i]。

而本题，因为一只股票可以买卖多次，所以当第i天买入股票的时候，所持有的现金可能有之前买卖过的利润。

代码如下：（注意代码中的注释，标记了和121.买卖股票的最佳时机唯一不同的地方）

```other
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>> dp(len, vector<int>(2, 0));
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]); // 注意这里是和121. 买卖股票的最佳时机唯一不同的地方。
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[len - 1][1];
    }
};
```

- 时间复杂度：O(n)
- 空间复杂度：O(n)

## [\#](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87.html#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAiii)买卖股票的最佳时机III

[动态规划：123.买卖股票的最佳时机III (opens new window)](https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html)最多买卖两次，问最大收益。

【动态规划】

一天一共就有五个状态，

0. 没有操作
1. 第一次买入
2. 第一次卖出
3. 第二次买入
4. 第二次卖出

dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金。

达到dp[i][1]状态，有两个具体操作：

- 操作一：第i天买入股票了，那么dp[i][1] = dp[i-1][0] - prices[i]
- 操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]

dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1]);

同理dp[i][2]也有两个操作：

- 操作一：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i]
- 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1][2]

所以dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])

同理可推出剩下状态部分：

dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);

dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);

代码如下：

```other
// 版本一
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 0) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(5, 0));
        dp[0][1] = -prices[0];
        dp[0][3] = -prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = dp[i - 1][0];
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        return dp[prices.size() - 1][4];
    }
};
```

- 时间复杂度：O(n)
- 空间复杂度：O(n × 5)

当然，大家可以看到力扣官方题解里的一种优化空间写法，我这里给出对应的C++版本：

```other
// 版本二
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 0) return 0;
        vector<int> dp(5, 0);
        dp[1] = -prices[0];
        dp[3] = -prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[1] = max(dp[1], dp[0] - prices[i]);
            dp[2] = max(dp[2], dp[1] + prices[i]);
            dp[3] = max(dp[3], dp[2] - prices[i]);
            dp[4] = max(dp[4], dp[3] + prices[i]);
        }
        return dp[4];
    }
};
```

- 时间复杂度：O(n)
- 空间复杂度：O(1)

**这种写法看上去简单，其实思路很绕，不建议大家这么写，这么思考，很容易把自己绕进去！** 对于本题，把版本一的写法研究明白，足以！

## [\#](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87.html#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAiv)买卖股票的最佳时机IV

[动态规划：188.买卖股票的最佳时机IV (opens new window)](https://programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html)最多买卖k笔交易，问最大收益。

使用二维数组 dp[i][j] ：第i天的状态为j，所剩下的最大现金是dp[i][j]

j的状态表示为：

- 0 表示不操作
- 1 第一次买入
- 2 第一次卖出
- 3 第二次买入
- 4 第二次卖出
- .....

**除了0以外，偶数就是卖出，奇数就是买入**。

2. 确定递推公式

达到dp[i][1]状态，有两个具体操作：

- 操作一：第i天买入股票了，那么dp[i][1] = dp[i - 1][0] - prices[i]
- 操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]

dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1]);

同理dp[i][2]也有两个操作：

- 操作一：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i]
- 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1][2]

dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])

同理可以类比剩下的状态，代码如下：

```other
for (int j = 0; j < 2 * k - 1; j += 2) {
    dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
    dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
}
```

整体代码如下：

```other
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {

        if (prices.size() == 0) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));
        for (int j = 1; j < 2 * k; j += 2) {
            dp[0][j] = -prices[0];
        }
        for (int i = 1;i < prices.size(); i++) {
            for (int j = 0; j < 2 * k - 1; j += 2) {
                dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
                dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
            }
        }
        return dp[prices.size() - 1][2 * k];
    }
};
```

当然有的解法是定义一个三维数组dp[i][j][k]，第i天，第j次买卖，k表示买还是卖的状态，从定义上来讲是比较直观。但感觉三维数组操作起来有些麻烦，直接用二维数组来模拟三维数组的情况，代码看起来也清爽一些。

## [\#](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F)最佳买卖股票时机含冷冻期

[动态规划：309.最佳买卖股票时机含冷冻期 (opens new window)](https://programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html)可以多次买卖但每次卖出有冷冻期1天。

相对于[动态规划：122.买卖股票的最佳时机II (opens new window)](https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html)，本题加上了一个冷冻期。

在[动态规划：122.买卖股票的最佳时机II (opens new window)](https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html)中有两个状态，持有股票后的最多现金，和不持有股票的最多现金。本题则可以花费为四个状态

dp[i][j]：第i天状态为j，所剩的最多现金为dp[i][j]。

具体可以区分出如下四个状态：

- 状态一：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）
- 卖出股票状态，这里就有两种卖出股票状态
   - 状态二：两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态
   - 状态三：今天卖出了股票
- 状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！

达到买入股票状态（状态一）即：dp[i][0]，有两个具体操作：

- 操作一：前一天就是持有股票状态（状态一），dp[i][0] = dp[i - 1][0]
- 操作二：今天买入了，有两种情况
   - 前一天是冷冻期（状态四），dp[i - 1][3] - prices[i]
   - 前一天是保持卖出股票状态（状态二），dp[i - 1][1] - prices[i]

所以操作二取最大值，即：max(dp[i - 1][3], dp[i - 1][1]) - prices[i]

那么dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);

达到保持卖出股票状态（状态二）即：dp[i][1]，有两个具体操作：

- 操作一：前一天就是状态二
- 操作二：前一天是冷冻期（状态四）

dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);

达到今天就卖出股票状态（状态三），即：dp[i][2] ，只有一个操作：

- 操作一：昨天一定是买入股票状态（状态一），今天卖出

即：dp[i][2] = dp[i - 1][0] + prices[i];

达到冷冻期状态（状态四），即：dp[i][3]，只有一个操作：

- 操作一：昨天卖出了股票（状态三）

p[i][3] = dp[i - 1][2];

综上分析，递推代码如下：

```other
dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3]- prices[i], dp[i - 1][1]) - prices[i];
dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
dp[i][2] = dp[i - 1][0] + prices[i];
dp[i][3] = dp[i - 1][2];
```

整体代码如下：

```other
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if (n == 0) return 0;
        vector<vector<int>> dp(n, vector<int>(4, 0));
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], max(dp[i - 1][3], dp[i - 1][1]) - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);
            dp[i][2] = dp[i - 1][0] + prices[i];
            dp[i][3] = dp[i - 1][2];
        }
        return max(dp[n - 1][3],max(dp[n - 1][1], dp[n - 1][2]));
    }
};
```

- 时间复杂度：O(n)
- 空间复杂度：O(n)

## [\#](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87.html#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9)买卖股票的最佳时机含手续费

[动态规划：714.买卖股票的最佳时机含手续费 (opens new window)](https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html)可以多次买卖，但每次有手续费。

相对于[动态规划：122.买卖股票的最佳时机II (opens new window)](https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html)，本题只需要在计算卖出操作的时候减去手续费就可以了，代码几乎是一样的。

唯一差别在于递推公式部分，所以本篇也就不按照动规五部曲详细讲解了，主要讲解一下递推公式部分。

这里重申一下dp数组的含义：

dp[i][0] 表示第i天持有股票所省最多现金。 dp[i][1] 表示第i天不持有股票所得最多现金

如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来

- 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]
- 第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：dp[i - 1][1] - prices[i]

所以：dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);

在来看看如果第i天不持有股票即dp[i][1]的情况， 依然可以由两个状态推出来

- 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]
- 第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金，**注意这里需要有手续费了**即：dp[i - 1][0] + prices[i] - fee

所以：dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);

**本题和**[**动态规划：122.买卖股票的最佳时机II (opens new window)**](https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html)**的区别就是这里需要多一个减去手续费的操作**。

以上分析完毕，代码如下：

```other
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);
        }
        return max(dp[n - 1][0], dp[n - 1][1]);
    }
};
```

- 时间复杂度：O(n)
- 空间复杂度：O(n)

#### 代码随想录算法训练营第五十二天 | 300.最长递增子序列，674. 最长连续递增序列，718. 最长重复子数组

#### ● day 52 任务以及具体安排：[第九章 动态规划part13](https://docs.qq.com/doc/DUFJzanBWVXNVWW1N) (2.2)

# 第九章 动态规划part13

●  300.最长递增子序列

●  674. 最长连续递增序列

●  718. 最长重复子数组

## 详细布置

### 300.最长递增子序列

今天开始正式子序列系列，本题是比较简单的，感受感受一下子序列题目的思路。

视频讲解：[https://www.bilibili.com/video/BV1ng411J7xP](https://www.bilibili.com/video/BV1ng411J7xP)

[代码随想录](https://programmercarl.com/0300.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html)

### 674. 最长连续递增序列

本题相对于昨天的动态规划：300.最长递增子序列 最大的区别在于“连续”。 先尝试自己做做，感受一下区别

视频讲解：[https://www.bilibili.com/video/BV1bD4y1778v](https://www.bilibili.com/video/BV1bD4y1778v)

[代码随想录](https://programmercarl.com/0674.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97.html)

### 718. 最长重复子数组

稍有难度，要使用二维dp数组了

视频讲解：[https://www.bilibili.com/video/BV178411H7hV](https://www.bilibili.com/video/BV178411H7hV)

[代码随想录](https://programmercarl.com/0718.%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.html)

[ChatGPT](https://chat.openai.com/share/ae261361-98a7-41c5-a69e-8da2070be09e)

---

### [300.最长递增子序列](https://leetcode.com/problems/longest-increasing-subsequence/description/)

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

输入：nums = [10,9,2,5,3,7,101,18]

输出：4

解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

**示例 2：**

输入：nums = [0,1,0,3,2,3]

输出：4

**示例 3：**

输入：nums = [7,7,7,7,7,7,7]

输出：1

**提示：**

- `1 <= nums.length <= 2500`
- `-104 <= nums[i] <= 104`

#### 解题思路：

解决这个问题，我们可以使用动态规划的方法。动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。具体到这个问题，我们可以定义一个dp数组，其中dp[i]表示以nums[i]结尾的最长递增子序列的长度。下面是解决这个问题的步骤：

1. 初始化一个长度与原数组相同的dp数组，每个元素初始化为1，因为最短的递增子序列至少包含自身。
2. 遍历数组nums，对于每个元素nums[i]，再遍历其之前的所有元素nums[j] (0 <= j < i)。
3. 如果nums[j] < nums[i]，说明nums[j]可以作为递增子序列的一个元素，此时更新dp[i] = max(dp[i], dp[j] + 1)。
4. 遍历完所有元素后，dp数组中的最大值即为最长递增子序列的长度。

```python
def lengthOfLIS(nums):
    if not nums:  # 如果数组为空，直接返回0
        return 0
    dp = [1] * len(nums)  # 初始化dp数组，每个元素代表以当前元素结尾的最长递增子序列长度，初始值为1
    for i in range(len(nums)):  # 遍历数组
        for j in range(i):  # 遍历当前元素之前的所有元素
            if nums[j] < nums[i]:  # 如果找到一个小于当前元素的数
                dp[i] = max(dp[i], dp[j] + 1)  # 更新dp[i]，选择更长的递增子序列
    return max(dp)  # dp数组中的最大值即为最长递增子序列的长度

# 以下是示例代码的执行部分
# nums = [10,9,2,5,3,7,101,18]
# print(lengthOfLIS(nums))  # 输出应该是4
```

时间复杂度为O(n^2)，因为需要双层循环遍历数组。空间复杂度为O(n)，因为需要一个长度为n的dp数组。

常见的错误或难点：

- 忘记初始化dp数组。
- 没有正确地更新dp[i]。
- 忽略了返回dp数组中的最大值，而不是dp数组的最后一个元素。

这种方法适用于大多数情况，但当数组长度非常大时，时间复杂度可能会成为瓶颈。在这种情况下，可以考虑使用二分查找来优化动态规划，降低时间复杂度。

---

### [674. 最长连续递增序列](https://leetcode.com/problems/longest-continuous-increasing-subsequence/description/)

给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

示例 1：

- 输入：nums = [1,3,5,4,7]
- 输出：3
- 解释：最长连续递增序列是 [1,3,5], 长度为3。尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。

示例 2：

- 输入：nums = [2,2,2,2,2]
- 输出：1
- 解释：最长连续递增序列是 [2], 长度为1。

提示：

- 0 <= nums.length <= 10^4
- \-10^9 <= nums[i] <= 10^9

#### 解题思路：

#### 解法一：遍历法

解决这个问题，我们可以使用一种简单的方法，即遍历数组，使用两个变量，一个用于存储当前连续递增子序列的长度，另一个用于存储遇到到目前为止的最长连续递增子序列的长度。以下是解决这个问题的步骤：

1. 如果数组为空，直接返回0。
2. 初始化两个变量，`count = 1` 用于记录当前连续递增子序列的长度（至少为1），`maxCount = 1` 用于记录最长的连续递增子序列的长度。
3. 从数组的第二个元素开始遍历数组（索引为1），比较当前元素与前一个元素：
   - 如果当前元素大于前一个元素，说明连续递增序列仍在继续，将 `count` 加1。
   - 如果当前元素小于等于前一个元素，说明连续递增序列被打断，此时需要将 `count` 重置为1。
4. 每次更新 `count` 后，比较 `count` 和 `maxCount`，如果 `count` 更大，更新 `maxCount`。
5. 遍历结束后，`maxCount` 即为最长连续递增子序列的长度。

```python
def findLengthOfLCIS(nums):
    if not nums:  # 如果数组为空，返回0
        return 0
    count = 1  # 当前连续递增子序列的长度
    maxCount = 1  # 最长连续递增子序列的长度
    for i in range(1, len(nums)):  # 从数组的第二个元素开始遍历
        if nums[i] > nums[i - 1]:  # 如果当前元素大于前一个元素
            count += 1  # 当前连续递增子序列长度加1
            maxCount = max(maxCount, count)  # 更新最长连续递增子序列的长度
        else:  # 如果当前元素小于等于前一个元素
            count = 1  # 重置当前连续递增子序列的长度为1
    return maxCount  # 返回最长连续递增子序列的长度
```

这个方法的时间复杂度是O(n)，其中n是数组`nums`的长度，因为我们只需要遍历一次数组。空间复杂度是O(1)，因为我们只使用了固定数量的额外空间。

#### 解法二：动态规划

1. 定义状态：`dp[i]` 表示以 `nums[i]` 结尾的最长连续递增子序列的长度。
2. 状态转移方程：如果 `nums[i] > nums[i - 1]`，则 `dp[i] = dp[i - 1] + 1`；否则，`dp[i] = 1`，因为连续递增序列在这里断开了。
3. 初始化：`dp[0] = 1`，因为最短的连续递增子序列至少包括它自己。
4. 遍历数组 `nums`，根据状态转移方程更新 `dp` 数组。
5. 最终答案是 `dp` 数组中的最大值，表示最长的连续递增子序列的长度。

```python
def findLengthOfLCIS(nums):
    if not nums:  # 如果数组为空
        return 0
    n = len(nums)
    dp = [1] * n  # 初始化dp数组，每个元素初始值为1
    for i in range(1, n):  # 从第二个元素开始遍历
        if nums[i] > nums[i - 1]:  # 如果当前元素大于前一个元素
            dp[i] = dp[i - 1] + 1  # 更新dp[i]
        # 否则，dp[i]保持为1，因为连续递增序列在这里断开
    return max(dp)  # 返回dp数组中的最大值，即最长连续递增子序列的长度
```

尽管这个动态规划解法在理论上是可行的，但它的时间复杂度仍然是O(n)，与之前的方法相同。然而，这个方法使用了O(n)的额外空间来存储dp数组，而之前的方法只需要O(1)的额外空间。因此，从空间效率的角度来看，这个动态规划解法不是最优解。此外，在实际应用中，由于这个问题的特殊性质（连续递增），直接遍历法更直观、更易于实现。

---

### [718. 最长重复子数组](https://leetcode.com/problems/maximum-length-of-repeated-subarray/description/)

给两个整数数组 `nums1` 和 `nums2` ，返回 *两个数组中 **公共的** 、长度最长的子数组的长度* 。

**示例 1：**

输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]

输出：3

解释：长度最长的公共子数组是 [3,2,1] 。

**示例 2：**

输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]

输出：5

**提示：**

- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 100`

#### 解题思路：

这个问题可以使用动态规划（Dynamic Programming，DP）来解决。我们定义一个二维的DP数组`dp`，其中`dp[i][j]`表示以`nums1[i-1]`和`nums2[j-1]`结尾的最长公共子数组的长度。这样定义的原因是，只有当`nums1[i-1] == nums2[j-1]`时，我们才考虑更新公共子数组的长度，因为我们想要的是连续的公共部分。

解题步骤如下：

1. 初始化一个 `(len(nums1)+1) x (len(nums2)+1)` 的二维数组`dp`，所有元素初始值为0。`+1`是因为我们要考虑`dp[0][0]`作为边界情况，这样可以避免处理数组越界的问题。
2. 遍历`nums1`和`nums2`，对于每对`(i, j)`（分别是`nums1`和`nums2`的索引），进行以下操作：
   - 如果`nums1[i-1] == nums2[j-1]`，则`dp[i][j] = dp[i-1][j-1] + 1`。这表示当前元素相等，可以在之前的公共子数组的基础上加1。
   - 否则，`dp[i][j]`保持为0，因为我们只关心连续的公共子数组。
3. 在更新`dp`数组的过程中，记录最大的`dp[i][j]`值，这将是最长公共子数组的长度。
4. 遍历完成后，返回记录的最大值。

```python
def findLength(nums1, nums2):
    m, n = len(nums1), len(nums2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]  # 初始化dp数组
    maxLength = 0  # 记录最长公共子数组的长度
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if nums1[i - 1] == nums2[j - 1]:  # 当前元素相等
                dp[i][j] = dp[i - 1][j - 1] + 1  # 更新dp[i][j]
                maxLength = max(maxLength, dp[i][j])  # 更新最长公共子数组的长度
    return maxLength  # 返回最长公共子数组的长度
```

这个动态规划解法的时间复杂度是O(mn)，其中m和n分别是`nums1`和`nums2`的长度，因为需要遍历这两个数组的每个元素。空间复杂度也是O(mn)，因为我们需要一个二维数组来存储状态。这个方法在解决最长公共子数组问题时是有效的，但当输入数组非常大时，可能需要较多的时间和空间。

#### 代码随想录算法训练营第五十三天 | 1143.最长公共子序列，1035.不相交的线，53. 最大子序和  动态规划

#### ● day 53 任务以及具体安排：[第九章 动态规划part14](https://docs.qq.com/doc/DUEVBcnBldHBKWk12) (2.3)

# 第九章 动态规划part14

●  1143.最长公共子序列

●  1035.不相交的线

●  53. 最大子序和  动态规划

## 详细布置

### 1143.最长公共子序列

体会一下本题和 718. 最长重复子数组 的区别

视频讲解：[https://www.bilibili.com/video/BV1ye4y1L7CQ](https://www.bilibili.com/video/BV1ye4y1L7CQ)

[代码随想录](https://programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html)

### 1035.不相交的线

其实本题和 1143.最长公共子序列 是一模一样的，大家尝试自己做一做。

视频讲解：[https://www.bilibili.com/video/BV1h84y1x7MP](https://www.bilibili.com/video/BV1h84y1x7MP)

[代码随想录](https://programmercarl.com/1035.%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF.html)

### 53. 最大子序和

这道题我们用贪心做过，这次 再用dp来做一遍

视频讲解：[https://www.bilibili.com/video/BV19V4y1F7b5](https://www.bilibili.com/video/BV19V4y1F7b5)

[代码随想录](https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html)

[ChatGPT](https://chat.openai.com/share/e1eec8eb-cb60-4394-a35e-2399dc404344)

---

### [1143.最长公共子序列](https://leetcode.com/problems/longest-common-subsequence/description/)

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

若这两个字符串没有公共子序列，则返回 0。

示例 1:

- 输入：text1 = "abcde", text2 = "ace"
- 输出：3
- 解释：最长公共子序列是 "ace"，它的长度为 3。

示例 2:

- 输入：text1 = "abc", text2 = "abc"
- 输出：3
- 解释：最长公共子序列是 "abc"，它的长度为 3。

示例 3:

- 输入：text1 = "abc", text2 = "def"
- 输出：0
- 解释：两个字符串没有公共子序列，返回 0。

提示:

- 1 <= text1.length <= 1000
- 1 <= text2.length <= 1000 输入的字符串只含有小写英文字符

#### 解题思路：

这个问题是典型的动态规划问题。我们可以使用动态规划的方法来解决最长公共子序列（Longest Common Subsequence, LCS）的问题。下面是解题的步骤：

1. **定义动态规划数组**：定义一个二维数组 `dp`，其中 `dp[i][j]` 表示 `text1` 的前 `i` 个字符与 `text2` 的前 `j` 个字符的最长公共子序列的长度。
2. **初始化**：由于 `dp` 数组的定义，`dp[0][j]` 和 `dp[i][0]` 应初始化为 `0`，因为空字符串与任何字符串的最长公共子序列长度都是 `0`。
3. **状态转移方程**：对于 `dp[i][j]`，有以下两种情况：
   - 如果 `text1[i-1] == text2[j-1]`，说明这两个字符匹配，所以最长公共子序列长度加1，即 `dp[i][j] = dp[i-1][j-1] + 1`。
   - 如果 `text1[i-1] != text2[j-1]`，说明这两个字符不匹配，我们需要从 `text1` 的前 `i-1` 个字符和 `text2` 的前 `j` 个字符、以及 `text1` 的前 `i` 个字符和 `text2` 的前 `j-1` 个字符中找最长的公共子序列，即 `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。
4. **填表**：按照上面的状态转移方程，从左到右、从上到下地填写 `dp` 数组。
5. **返回结果**：最终 `dp[text1.length()][text2.length()]` 就是最长公共子序列的长度。

```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)  # 获取两个字符串的长度
    # 初始化动态规划数组，多出的一行一列是为了方便处理边界情况
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    # 遍历两个字符串
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            # 当前字符匹配时，最长公共子序列长度加1
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                # 当前字符不匹配时，取上方和左方的最大值作为当前值
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    # 返回右下角的值，即为最长公共子序列的长度
    return dp[m][n]
```

**复杂度分析**：

- 时间复杂度：`O(mn)`，其中 `m` 和 `n` 分别是 `text1` 和 `text2` 的长度。我们需要填充一个 `m * n` 的二维数组。
- 空间复杂度：`O(mn)`，用于存储整个 `dp` 数组。

**常见错误**：

- 忘记初始化 `dp` 数组的第一行和第一列为 `0`。
- 在填充 `dp` 数组时，下标处理不当，导致数组越界或者错误的状态转移。
- 未能正确处理字符匹配和不匹配的情况，导致状态转移方程错误。

---

### [1035.不相交的线](https://leetcode.com/problems/uncrossed-lines/description/)

在两条独立的水平线上按给定的顺序写下 `nums1` 和 `nums2` 中的整数。

现在，可以绘制一些连接两个数字 `nums1[i]` 和 `nums2[j]` 的直线，这些直线需要同时满足满足：

- `nums1[i] == nums2[j]`
- 且绘制的直线不与任何其他连线（非水平线）相交。

请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。

以这种方法绘制线条，并返回可以绘制的最大连线数。

**示例 1：**

![Image.png](https://assets.leetcode.com/uploads/2019/04/26/142.png)

输入：nums1 = [1,4,2], nums2 = [1,2,4]

输出：2

解释：可以画出两条不交叉的线，如上图所示。

但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。

**示例 2：**

输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]

输出：3

**示例 3：**

输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]

输出：2

**提示：**

- `1 <= nums1.length, nums2.length <= 500`
- `1 <= nums1[i], nums2[j] <= 2000`

#### 解题思路：

问题 "1035. 不相交的线" 实际上可以转换为 "最长公共子序列（LCS）" 的问题。在给定的两个序列中，我们要找到最长的一组相同的数，这组数在两个序列中的顺序是一样的，但不需要连续。这和LCS的定义完全一致。

解题步骤和之前讨论的最长公共子序列问题类似：

1. **定义动态规划数组**：`dp[i][j]` 表示 `nums1` 中前 `i` 个元素和 `nums2` 中前 `j` 个元素的最长公共子序列的长度。
2. **初始化**：`dp` 数组的大小为 `(len(nums1) + 1) x (len(nums2) + 1)`，`dp[0][j]` 和 `dp[i][0]` 为 `0`，因为任何数组和一个长度为 `0` 的数组的最长公共子序列长度为 `0`。
3. **状态转移方程**：
   - 如果 `nums1[i - 1] == nums2[j - 1]`，则 `dp[i][j] = dp[i - 1][j - 1] + 1`；
   - 否则，`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])`。
4. **遍历填表**：按照状态转移方程，从小到大遍历 `i` 和 `j` 填充 `dp` 表。
5. **返回结果**：`dp[len(nums1)][len(nums2)]` 即为最长公共子序列的长度，也是可以绘制的最大连线数。

```python
def maxUncrossedLines(nums1, nums2):
    m, n = len(nums1), len(nums2)  # m 和 n 分别为 nums1 和 nums2 的长度
    # 初始化动态规划数组 dp，多出的一行一列是为了方便处理边界情况，即没有元素的情况
    dp = [[0] * (n + 1) for _ in range(m + 1)]

    # 遍历 nums1 和 nums2
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            # 如果当前元素相等，说明可以在这对元素之间画一条线，且不会与其他线相交
            if nums1[i - 1] == nums2[j - 1]:
                # 当前位置的最大连线数等于左上角的最大连线数加1
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                # 如果当前元素不相等，那么当前位置的最大连线数等于左边和上边的最大值
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    # 返回整个 dp 数组的最后一个元素，即为最大连线数
    return dp[m][n]
```

**复杂度分析**：

- 时间复杂度：`O(mn)`，其中 `m` 和 `n` 分别是 `nums1` 和 `nums2` 的长度。需要遍历整个 `dp` 表一次。
- 空间复杂度：`O(mn)`，用于存储 `dp` 表。如果空间是一个考虑因素，可以通过滚动数组的方式将空间复杂度优化到 `O(min(m,n))`。

---

### [53. 最大子序和  动态规划](https://leetcode.com/problems/maximum-subarray/description/)

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

**示例 1：**

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]

输出：6

解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

**示例 2：**

输入：nums = [1]

输出：1

**示例 3：**

输入：nums = [5,4,-1,7,8]

输出：23

**提示：**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

进阶：如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。

#### 解题思路：

解决最大子序和问题，动态规划是一个非常直观且有效的方法。我们可以通过以下步骤来设计一个动态规划的解法：

1. **定义状态**：定义 `dp[i]` 表示以 `nums[i]` 结尾的最大子序和。这里的关键是“以 `nums[i]` 结尾”，这意味着每个子序列都是以 `nums[i]` 为结尾元素的。
2. **状态转移方程**：考虑到一个子序列要么包含 `nums[i-1]` 要么不包含。如果 `dp[i-1]` 表示的以 `nums[i-1]` 结尾的最大子序和对 `dp[i]` 有贡献（即 `dp[i-1]` 是正数），我们就将 `nums[i]` 加入到这个子序列中；否则，我们就从 `nums[i]` 开始一个新的子序列。因此，状态转移方程为：`dp[i] = max(nums[i], dp[i-1] + nums[i])`。
3. **初始化**：`dp[0] = nums[0]`，因为当数组只有一个元素时，最大子序和就是这个元素本身。
4. **遍历填表**：根据状态转移方程，从 `i = 1` 开始遍历数组，计算每个 `dp[i]`。
5. **获取结果**：由于我们只对最大子序和感兴趣，而不是这个最大和是以哪个元素结尾的，因此最终答案是 `dp` 数组中的最大值。

```python
def maxSubArray(nums):
    n = len(nums)
    # 初始化 dp 数组
    dp = [0] * n
    dp[0] = nums[0]  # base case
    # 遍历数组，填充 dp 表
    for i in range(1, n):
        # 状态转移方程
        dp[i] = max(nums[i], dp[i-1] + nums[i])
    # 返回 dp 数组中的最大值
    return max(dp)
```

#### 代码优化

实际上，我们不需要维护整个 `dp` 数组来解决这个问题，因为每次状态转移只依赖于前一个状态。因此，我们可以只用一个变量来存储前一个状态的值，从而将空间复杂度从 `O(n)` 降低到 `O(1)`。

#### 优化后的代码

```python
def maxSubArray(nums):
    n = len(nums)
    # 初始化当前最大子序和为数组的第一个元素
    curMax = nums[0]
    # 初始化全局最大子序和同样为数组的第一个元素
    globalMax = nums[0]
    # 遍历数组，更新 curMax 和 globalMax
    for i in range(1, n):
        # 如果 curMax 小于 0，就从当前元素重新开始计数
        curMax = max(nums[i], curMax + nums[i])
        # 更新全局最大子序和
        globalMax = max(globalMax, curMax)
    return globalMax
```

**复杂度分析**：

- 时间复杂度：`O(n)`，其中 `n` 是数组 `nums` 的长度。我们只需要遍历一遍数组即可计算出结果。
- 空间复杂度：`O(1)`，我们只使用了常数级别的额外空间。

#### 代码随想录算法训练营第五十五天 | 392.判断子序列，115.不同的子序列

#### ● day 55 任务以及具体安排：[第九章 动态规划part15](https://docs.qq.com/doc/DUGtwYWlEZVZSVXdF) (2.5)

# 第九章 动态规划part15

●  392.判断子序列

●  115.不同的子序列

## 详细布置

### 392.判断子序列

这道题目算是 编辑距离问题 的入门题目（毕竟这里只是涉及到减法），慢慢的，后面就要来解决真正的 编辑距离问题了

[代码随想录](https://programmercarl.com/0392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html)

### 115.不同的子序列

但相对于刚讲过 392.判断子序列，本题 就有难度了 ，感受一下本题和  392.判断子序列 的区别。

[代码随想录](https://programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html)

[ChatGPT](https://chat.openai.com/share/976f6ba6-cd71-45a1-a5f5-b7c18fb28100)

---

### [392.判断子序列](https://leetcode.com/problems/is-subsequence/description/)

给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。

**进阶：**

如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

**示例 1：**

输入：s = "abc", t = "ahbgdc"

输出：true

**示例 2：**

输入：s = "axc", t = "ahbgdc"

输出：false

**提示：**

- `0 <= s.length <= 100`
- `0 <= t.length <= 10^4`
- 两个字符串都只由小写字符组成。

#### 解题思路：

要使用动态规划解决判断子序列问题（LeetCode 392），我们可以考虑以下步骤：

#### 问题概述

给定两个字符串`s`和`t`，我们需要判断`s`是否为`t`的子序列。子序列是指可以通过删除某些字符但不干扰其他字符顺序的方式从`t`中得到的字符串。

#### 动态规划解题思路

1. **定义状态**：`dp[i][j]`表示字符串`s`到索引`i`为止的子串是否为字符串`t`到索引`j`为止的子串的子序列。
2. **状态转移方程**：
   - 如果`s[i] == t[j]`，则`dp[i][j] = dp[i-1][j-1]`，意味着当前字符匹配，我们需要查看`s`的前一个字符是否为`t`的前一个子串的子序列。
   - 如果`s[i] != t[j]`，则`dp[i][j] = dp[i][j-1]`，意味着当前`t`的字符不匹配`s[i]`，我们需要查看`s`是否为`t`的前一个子串的子序列，即忽略当前`t[j]`的影响。
3. **初始化**：
   - `dp[0][j]`应该为`True`，因为空字符串是任何字符串的子序列。
   - `dp[i][0]`应该为`False`（对于所有`i > 0`），因为非空字符串不能是空字符串的子序列。
4. **计算顺序**：我们从左到右、从上到下计算`dp`表。

```python
def isSubsequence(s, t):
    m, n = len(s), len(t)  # m 和 n 分别为字符串 s 和 t 的长度
    # 初始化 dp 数组，dp[i][j] 表示 s 的前 i 个字符是否为 t 的前 j 个字符的子序列
    dp = [[False] * (n + 1) for _ in range(m + 1)]

    # 空字符串是任何字符串的子序列，所以 dp[0][j] 都为 True
    for j in range(n + 1):
        dp[0][j] = True

    # 动态规划填表
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            # 当 s 的当前字符等于 t 的当前字符时，检查 s 的前一个字符是否为 t 的前一个子串的子序列
            if s[i - 1] == t[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                # 当 s 的当前字符不等于 t 的当前字符时，检查 s 是否为 t 的前一个子串的子序列
                dp[i][j] = dp[i][j - 1]

    # dp[m][n] 表示 s 是否为 t 的子序列
    return dp[m][n]
```

#### 复杂度分析

- 时间复杂度：`O(m*n)`，其中`m`和`n`分别是字符串`s`和`t`的长度。我们需要遍历整个`dp`表。
- 空间复杂度：`O(m*n)`，因为我们需要一个二维数组来存储所有的状态。

#### 进阶问题解法

对于进阶问题，处理大量的`s`字符串判断是否为`t`的子序列时，我们可以预处理字符串`t`。为每个字符维护一个索引列表，记录该字符在`t`中出现的所有位置。然后对于每个`s`，我们用贪心算法通过这些索引列表来判断是否为子序列，这样可以将时间复杂度降低到接近`O(n)`，这里`n`是`t`的长度。

#### 常见错误

- 忽略初始化步骤，导致`dp`数组的初始状态设置错误。
- 混淆状态转移条件，尤其是在处理字符不匹配的情况时。

在代码中使用 `if s[i - 1] == t[j - 1]:` 而不是 `if s[i] == t[j]:` 的原因是数组索引的起始点和动态规划数组 `dp` 的定义方式有关。

当我们定义 `dp[i][j]` 表示字符串 `s` 的前 `i` 个字符是否为字符串 `t` 的前 `j` 个字符的子序列时，`i` 和 `j` 的取值范围是从 1 到字符串的长度。这样定义的目的是为了在动态规划数组中包含空字符串的情况，即当 `i` 或 `j` 为 0 时，表示字符串 `s` 或 `t` 是空字符串。

因此，当我们在代码中访问字符串 `s` 和 `t` 的第 `i` 和 `j` 个字符时，需要使用 `s[i - 1]` 和 `t[j - 1]`，因为字符串的索引是从 0 开始的。这样，`s[i - 1]` 实际上访问的是字符串 `s` 的第 `i` 个字符，`t[j - 1]` 访问的是字符串 `t` 的第 `j` 个字符。

这种偏移是必要的，因为我们的 `dp` 数组额外包含了空字符串的情况，使得数组的索引和字符串的实际索引之间存在一位的差距。这也是为什么当我们比较 `s` 和 `t` 中的字符是否相等时，需要使用 `s[i - 1]` 和 `t[j - 1]` 而不直接使用 `s[i]` 和 `t[j]` 的原因。

这个动态规划的方法比较直观，但实际上对于这个特定问题，有更简单的双指针方法，可以在`O(n)`时间内解决，其中`n`是字符串`t`的长度。动态规划方法在这个问题上可能有些过于复杂，但它提供了一种不同的视角来理解问题。

---

### [115.不同的子序列](https://leetcode.com/problems/distinct-subsequences/description/)

给你两个字符串 `s` 和 `t` ，统计并返回在 `s` 的 **子序列** 中 `t` 出现的个数，结果需要对 109 + 7 取模。

**示例 1：**

输入：**s = "rabbbit", t = "rabbit" `**输出**`：**`3` **解释：**

如下所示, 有 3 种可以从 s 中得到 `"rabbit" 的方案`。

`**rabb**b**it**`

`**ra**b**bbit**`

`**rab**b**bit**`

**示例 2：**

输入：**s = "babgbag", t = "bag"

`**输出**`**：**`5` **解释：**

如下所示, 有 5 种可以从 s 中得到 `"bag" 的方案`。

`**ba**b**g**bag`

`**ba**bgba**g**`

`**b**abgb**ag**`

`ba**b**gb**ag**`

`babg**bag**`

**提示：**

- `1 <= s.length, t.length <= 1000`
- `s` 和 `t` 由英文字母组成

#### 解题思路：

这道题目要求统计字符串 `s` 中作为 `t` 子序列出现的个数，是一个典型的动态规划问题。我们可以用一个二维数组 `dp[i][j]` 来表示字符串 `t` 的前 `i` 个字符作为字符串 `s` 的前 `j` 个字符的子序列出现的次数。

#### 动态规划解题思路

1. **定义状态**：
   - `dp[i][j]` 表示字符串 `t` 的前 `i` 个字符作为字符串 `s` 的前 `j` 个字符的子序列出现的次数。
2. **状态转移方程**：
   - 如果 `t[i - 1] == s[j - 1]`，则 `dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1]`。
      - `dp[i - 1][j - 1]` 表示考虑 `t[i - 1]` 和 `s[j - 1]` 匹配的情况。
      - `dp[i][j - 1]` 表示不考虑当前的 `s[j - 1]` 字符，即 `s[j - 1]` 字符不参与匹配。
   - 如果 `t[i - 1] != s[j - 1]`，则 `dp[i][j] = dp[i][j - 1]`。
      - 这种情况下，当前的 `s[j - 1]` 字符不能用于匹配 `t[i - 1]`，因此只能考虑 `s` 的前 `j - 1` 个字符。
3. **初始化**：
   - `dp[0][j]` 应该初始化为 1，因为空字符串是任何字符串的子序列。
   - `dp[i][0]`（对于所有 `i > 0`）应该初始化为 0，因为非空字符串不能是空字符串的子序列。
4. **计算顺序**：
   - 首先填充 `dp` 表的第一行和第一列。
   - 然后按行从上到下，每行从左到右计算。

```python
def numDistinct(s, t):
    MOD = 10**9 + 7  # 结果对 109 + 7 取模
    m, n = len(s), len(t)
    # 初始化 dp 数组，多出的一行一列是为了处理空字符串的情况
    dp = [[0] * (m + 1) for _ in range(n + 1)]

    # 当 t 为空字符串时，它是任何字符串的子序列，因此初始化为 1
    for j in range(m + 1):
        dp[0][j] = 1

    for i in range(1, n + 1):
        for j in range(1, m + 1):
            if t[i - 1] == s[j - 1]:
                dp[i][j] = (dp[i - 1][j - 1] + dp[i][j - 1]) % MOD
            else:
                dp[i][j] = dp[i][j - 1] % MOD

    return dp[n][m]
```

#### 复杂度分析

- 时间复杂度：`O(m*n)`，其中 `m` 和 `n` 分别是字符串 `s` 和 `t` 的长度。需要遍历整个 `dp` 表格来填充值。
- 空间复杂度：`O(m*n)`，因为我们需要一个二维数组来存储所有状态。

#### 中文注释

- `MOD = 10**9 + 7`：定义取模的值，因为结果需要对 `10^9 + 7` 取模。
- `dp[i][j]`：表示 `t` 的前 `i` 个字符作为 `s` 的前 `j` 个字符的子序列出现的次数。
- 初始化 `dp[0][j]` 为 1：因为空字符串是任何字符串的子序列。
- `if t[i - 1] == s[j - 1]`：当当前字符匹配时，当前的匹配次数等于不包括当前字符时的匹配次数加上包括当前字符时的匹配次数。
- `% MOD`：确保结果在每一步都对 `10^9 + 7` 取模，避免整数溢出。

#### 代码随想录算法训练营第五十六天 | 583. 两个字符串的删除操作，72. 编辑距离，编辑距离总结篇

#### ● day 56 任务以及具体安排：[第九章 动态规划part16](https://docs.qq.com/doc/DUEdhTmx4SW9OcVJo) (2.6)

# 第九章 动态规划part16

●  583. 两个字符串的删除操作

●  72. 编辑距离

●  编辑距离总结篇

## 详细布置

583. 两个字符串的删除操作

本题和动态规划：115.不同的子序列 相比，其实就是两个字符串都可以删除了，情况虽说复杂一些，但整体思路是不变的。

[代码随想录](https://programmercarl.com/0583.%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.html)

### 72. 编辑距离

最终我们迎来了编辑距离这道题目，之前安排题目都是为了 编辑距离做铺垫。

[代码随想录](https://programmercarl.com/0072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html)

### 编辑距离总结篇

做一个总结吧

[代码随想录](https://programmercarl.com/%E4%B8%BA%E4%BA%86%E7%BB%9D%E6%9D%80%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%8C%E5%8D%A1%E5%B0%94%E5%81%9A%E4%BA%86%E4%B8%89%E6%AD%A5%E9%93%BA%E5%9E%AB.html)

[ChatGPT](https://chat.openai.com/share/60ceb056-cee5-4299-85c8-29bc5ed3e0eb)

---

### [583. 两个字符串的删除操作](https://leetcode.com/problems/delete-operation-for-two-strings/description/)

给定两个单词 `word1` 和 `word2` ，返回使得 `word1` 和  `word2` **相同**所需的**最小步数**。

**每步** 可以删除任意一个字符串中的一个字符。

**示例 1：**

**输入:** word1 = "sea", word2 = "eat"

**输出:** 2

**解释:** 第一步将 "sea" 变为 "ea" ，第二步将 "eat "变为 "ea"

**示例  2:**

输入：word1 = "leetcode", word2 = "etco"

输出：4

**提示：**

- `1 <= word1.length, word2.length <= 500`
- `word1` 和 `word2` 只包含小写英文字母

这个问题可以通过动态规划（Dynamic Programming, DP）来解决。关键在于找到两个字符串的最长公共子序列（Longest Common Subsequence, LCS），然后根据LCS来确定需要删除的字符数量。这里的思路是，首先找到最长的公共子序列，然后剩下的不在LCS中的字符都需要被删除。

#### 解题步骤：

1. 初始化一个二维数组 `dp`，其中 `dp[i][j]` 表示 `word1` 的前 `i` 个字符和 `word2` 的前 `j` 个字符的最长公共子序列的长度。
2. 遍历两个字符串，填充这个二维数组。
   - 如果 `word1[i - 1] == word2[j - 1]`，则 `dp[i][j] = dp[i - 1][j - 1] + 1`，表示找到了一个属于最长公共子序列的字符。
   - 否则，`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])`，表示最长公共子序列来自于 `word1` 的前 `i - 1` 个字符和 `word2` 的前 `j` 个字符，或者 `word1` 的前 `i` 个字符和 `word2` 的前 `j - 1` 个字符。
3. 根据 `dp` 数组的最后一个元素 `dp[word1.length()][word2.length()]` 得到最长公共子序列的长度。
4. 最小删除步数为两个字符串长度之和减去最长公共子序列长度的两倍（因为LCS中的每个字符在两个字符串中都出现了一次）。

```python
def minDistance(word1, word2):
    m, n = len(word1), len(word2)
    # 初始化DP数组
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # 动态规划填表
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if word1[i - 1] == word2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    
    # 计算最小删除步数
    lcs = dp[m][n]  # 最长公共子序列的长度
    return m + n - 2 * lcs

# 示例
word1 = "sea"
word2 = "eat"
print(minDistance(word1, word2))  # 输出: 2

word1 = "leetcode"
word2 = "etco"
print(minDistance(word1, word2))  # 输出: 4
```

#### 复杂度分析：

- 时间复杂度：`O(mn)`，其中 `m` 和 `n` 分别是 `word1` 和 `word2` 的长度。需要遍历整个二维数组。
- 空间复杂度：`O(mn)`，用于存储动态规划表。

#### 常见错误：

- 初始化 `dp` 数组时，忘记考虑空字符串的情况，即 `dp[0][j]` 和 `dp[i][0]` 应该全部初始化为 `0`。
- 在填充 `dp` 数组时，对于字符不匹配的情况处理不当，应该取 `dp[i-1][j]` 和 `dp[i][j-1]` 的最大值。

---

### [72. 编辑距离](https://leetcode.com/problems/edit-distance/description/)

给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数*  。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

**示例 1：**

输入：word1 = "horse", word2 = "ros"

输出：3

**解释：**

horse -> rorse (将 'h' 替换为 'r')

rorse -> rose (删除 'r')

rose -> ros (删除 'e')

**示例 2：**

输入：word1 = "intention", word2 = "execution"

输出：5

**解释：**

intention -> inention (删除 't')

inention -> enention (将 'i' 替换为 'e')

enention -> exention (将 'n' 替换为 'x')

exention -> exection (将 'n' 替换为 'c')

exection -> execution (插入 'u')

**提示：**

- `0 <= word1.length, word2.length <= 500`
- `word1` 和 `word2` 由小写英文字母组成

编辑距离问题是一个典型的动态规划问题，它要求将一个字符串转换成另一个字符串所需的最少操作数。这些操作包括插入、删除和替换字符。解决这个问题的关键在于使用动态规划表来记录从字符串 `s1` 变换到字符串 `s2` 的每一步操作所需的最小操作数。

#### 解题步骤：

1. 初始化一个大小为 `(m+1) x (n+1)` 的动态规划表 `dp`，其中 `m` 和 `n` 分别是字符串 `s1` 和 `s2` 的长度。`dp[i][j]` 表示从 `s1` 的前 `i` 个字符转换到 `s2` 的前 `j` 个字符所需的最少操作数。
2. 填充动态规划表的边界值：将 `s1` 转换为一个空字符串所需的操作数就是 `s1` 的长度（即全部删除操作），将空字符串转换为 `s2` 所需的操作数就是 `s2` 的长度（即全部插入操作）。
3. 逐个填充动态规划表的剩余部分。对于 `dp[i][j]`，有以下几种情况：
   - 如果 `s1[i-1] == s2[j-1]`（注意字符串索引从 0 开始），则不需要进行任何操作，所以 `dp[i][j] = dp[i-1][j-1]`。
   - 如果 `s1[i-1] != s2[j-1]`，则需要进行插入、删除或替换操作，取这三种操作中的最小值加一作为 `dp[i][j]` 的值：
      - 插入操作：`dp[i][j-1] + 1`
      - 删除操作：`dp[i-1][j] + 1`
      - 替换操作：`dp[i-1][j-1] + 1`
4. 动态规划表的最后一个元素 `dp[m][n]` 即为将 `s1` 转换为 `s2` 所需的最少操作数。

```python
def minDistance(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # 初始化边界
    for i in range(m + 1):
        dp[i][0] = i
    for j in range(n + 1):
        dp[0][j] = j
    
    # 动态规划填表
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1]
            else:
                dp[i][j] = 1 + min(dp[i-1][j],    # 删除
                                   dp[i][j-1],    # 插入
                                   dp[i-1][j-1])  # 替换
    return dp[m][n]
```

#### 复杂度分析：

- 时间复杂度：`O(mn)`，其中 `m` 和 `n` 分别是两个字符串的长度。
- 空间复杂度：`O(mn)`，用于存储动态规划表。

#### 这道题和上一题的区别

问题583（两个字符串的删除操作）和问题72（编辑距离）之间的主要差异在于它们各自的目标和解题策略。

对于问题583，目标是通过删除操作将两个字符串转换成它们的最长公共子序列（LCS）。这里的关键是计算两个字符串的LCS长度，然后用两个字符串的总长度减去两倍LCS的长度，从而得到最少的删除步骤。因此，这个问题的动态规划解法直接关注于找到LCS，而不需要初始化动态规划数组的边界情况来表示插入或替换操作，因为问题只允许删除操作。

相比之下，问题72（编辑距离）要求通过插入、删除和替换操作将一个字符串转换为另一个字符串，并且要求操作次数尽可能少。这个问题的动态规划解法需要初始化边界情况，即dp数组的第一行和第一列，来表示将一个字符串转换为另一个字符串所需的最少操作数。这里的初始化步骤是必要的，因为它们分别表示从空字符串到达当前状态所需的操作数，包括插入、删除和替换。

总结一下，问题583不需要类似问题72中的初始设定，因为它只涉及删除操作，且直接基于最长公共子序列来解决，而问题72需要考虑三种不同的操作（插入、删除、替换），并且必须初始化dp数组的边界情况来正确地计算编辑距离【32†来源】。

---

### 编辑距离总结篇

#### 判断子序列

[动态规划：392.判断子序列 (opens new window)](https://programmercarl.com/0392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html)给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

这道题目 其实是可以用双指针或者贪心的的，但是我在开篇的时候就说了这是编辑距离的入门题目，因为从题意中我们也可以发现，只需要计算删除的情况，不用考虑增加和替换的情况。

- if (s[i - 1] == t[j - 1])
   - t中找到了一个字符在s中也出现了
- if (s[i - 1] != t[j - 1])
   - 相当于t要删除元素，继续匹配

状态转移方程：

```cpp
if (s[i - 1] == t[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;
else dp[i][j] = dp[i][j - 1];
```

#### [\#](https://programmercarl.com/%E4%B8%BA%E4%BA%86%E7%BB%9D%E6%9D%80%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%8C%E5%8D%A1%E5%B0%94%E5%81%9A%E4%BA%86%E4%B8%89%E6%AD%A5%E9%93%BA%E5%9E%AB.html#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97)不同的子序列

[动态规划：115.不同的子序列 (opens new window)](https://programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html)给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。

本题虽然也只有删除操作，不用考虑替换增加之类的，但相对于[动态规划：392.判断子序列 (opens new window)](https://programmercarl.com/0392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html)就有难度了，这道题目双指针法可就做不了。

当s[i - 1] 与 t[j - 1]相等时，dp[i][j]可以有两部分组成。

一部分是用s[i - 1]来匹配，那么个数为dp[i - 1][j - 1]。

一部分是不用s[i - 1]来匹配，个数为dp[i - 1][j]。

这里可能有同学不明白了，为什么还要考虑 不用s[i - 1]来匹配，都相同了指定要匹配啊。

例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。

当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。

所以当s[i - 1] 与 t[j - 1]相等时，dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];

当s[i - 1] 与 t[j - 1]不相等时，dp[i][j]只有一部分组成，不用s[i - 1]来匹配，即：dp[i - 1][j]

所以递推公式为：dp[i][j] = dp[i - 1][j];

状态转移方程：

```cpp
if (s[i - 1] == t[j - 1]) {
    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
} else {
    dp[i][j] = dp[i - 1][j];
}
```

#### [\#](https://programmercarl.com/%E4%B8%BA%E4%BA%86%E7%BB%9D%E6%9D%80%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%8C%E5%8D%A1%E5%B0%94%E5%81%9A%E4%BA%86%E4%B8%89%E6%AD%A5%E9%93%BA%E5%9E%AB.html#%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C)两个字符串的删除操作

[动态规划：583.两个字符串的删除操作 (opens new window)](https://programmercarl.com/0583.%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.html)给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最少步数，每步可以删除任意一个字符串中的一个字符。

本题和[动态规划：115.不同的子序列 (opens new window)](https://programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html)相比，其实就是两个字符串可以都可以删除了，情况虽说复杂一些，但整体思路是不变的。

- 当word1[i - 1] 与 word2[j - 1]相同的时候
- 当word1[i - 1] 与 word2[j - 1]不相同的时候

当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i][j] = dp[i - 1][j - 1];

当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：

情况一：删word1[i - 1]，最少操作次数为dp[i - 1][j] + 1

情况二：删word2[j - 1]，最少操作次数为dp[i][j - 1] + 1

情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1][j - 1] + 2

那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：dp[i][j] = min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});

状态转移方程：

```cpp
if (word1[i - 1] == word2[j - 1]) {
    dp[i][j] = dp[i - 1][j - 1];
} else {
    dp[i][j] = min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});
}
```

#### [\#](https://programmercarl.com/%E4%B8%BA%E4%BA%86%E7%BB%9D%E6%9D%80%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%8C%E5%8D%A1%E5%B0%94%E5%81%9A%E4%BA%86%E4%B8%89%E6%AD%A5%E9%93%BA%E5%9E%AB.html#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB)编辑距离

[动态规划：72.编辑距离 (opens new window)](https://programmercarl.com/0072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html)给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

编辑距离终于来了，**有了前面三道题目的铺垫，应该有思路了**，本题是两个字符串可以增删改，比 [动态规划：判断子序列 (opens new window)](https://programmercarl.com/0392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html)，[动态规划：不同的子序列 (opens new window)](https://programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html)，[动态规划：两个字符串的删除操作 (opens new window)](https://programmercarl.com/0583.%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.html)都要复杂的多。

在确定递推公式的时候，首先要考虑清楚编辑的几种操作，整理如下：

- if (word1[i - 1] == word2[j - 1])
   - 不操作
- if (word1[i - 1] != word2[j - 1])
   - 增
   - 删
   - 换

也就是如上四种情况。

if (word1[i - 1] == word2[j - 1]) 那么说明不用任何编辑，dp[i][j] 就应该是 dp[i - 1][j - 1]，即dp[i][j] = dp[i - 1][j - 1];

此时可能有同学有点不明白，为啥要即dp[i][j] = dp[i - 1][j - 1]呢？

那么就在回顾上面讲过的dp[i][j]的定义，word1[i - 1] 与 word2[j - 1]相等了，那么就不用编辑了，以下标i-2为结尾的字符串word1和以下标j-2为结尾的字符串word2的最近编辑距离dp[i - 1][j - 1] 就是 dp[i][j]了。

在下面的讲解中，如果哪里看不懂，就回想一下dp[i][j]的定义，就明白了。

**在整个动规的过程中，最为关键就是正确理解dp[i][j]的定义！**

if (word1[i - 1] != word2[j - 1])，此时就需要编辑了，如何编辑呢？

操作一：word1增加一个元素，使其word1[i - 1]与word2[j - 1]相同，那么就是以下标i-2为结尾的word1 与 i-1为结尾的word2的最近编辑距离 加上一个增加元素的操作。

即 dp[i][j] = dp[i - 1][j] + 1;

操作二：word2添加一个元素，使其word1[i - 1]与word2[j - 1]相同，那么就是以下标i-1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 加上一个增加元素的操作。

即 dp[i][j] = dp[i][j - 1] + 1;

这里有同学发现了，怎么都是添加元素，删除元素去哪了。

**word2添加一个元素，相当于word1删除一个元素**，例如 word1 = "ad" ，word2 = "a"，word2添加一个元素d，也就是相当于word1删除一个元素d，操作数是一样！

操作三：替换元素，word1替换word1[i - 1]，使其与word2[j - 1]相同，此时不用增加元素，那么以下标i-2为结尾的word1 与 j-2为结尾的word2的最近编辑距离 加上一个替换元素的操作。

即 dp[i][j] = dp[i - 1][j - 1] + 1;

综上，当 if (word1[i - 1] != word2[j - 1]) 时取最小的，即：dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;

递归公式代码如下：

```cpp
if (word1[i - 1] == word2[j - 1]) {
    dp[i][j] = dp[i - 1][j - 1];
}
else {
    dp[i][j] = min({dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]}) + 1;
}
```

#### [\#](https://programmercarl.com/%E4%B8%BA%E4%BA%86%E7%BB%9D%E6%9D%80%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%8C%E5%8D%A1%E5%B0%94%E5%81%9A%E4%BA%86%E4%B8%89%E6%AD%A5%E9%93%BA%E5%9E%AB.html#%E6%80%BB%E7%BB%93)总结

心思的录友应该会发现我用了三道题做铺垫，才最后引出了[动态规划：72.编辑距离 (opens new window)](https://programmercarl.com/0072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html)，Carl的良苦用心呀，你们体会到了嘛！

#### 代码随想录算法训练营第五十七天 | 647. 回文子串，516.最长回文子序列，动态规划总结篇

#### ● day 57 任务以及具体安排：[第九章 动态规划part17](https://docs.qq.com/doc/DUHNxR2VUZURGb3NN) (2.7)

# 第九章 动态规划part17

●  647. 回文子串

●  516.最长回文子序列

●  动态规划总结篇

## 详细布置

### 647. 回文子串

动态规划解决的经典题目，如果没接触过的话，别硬想 直接看题解。

[代码随想录](https://programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html)

### 516.最长回文子序列

647. 回文子串，求的是回文子串，而本题要求的是回文子序列， 大家要搞清楚两者之间的区别。

[代码随想录](https://programmercarl.com/0516.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html)

### 动态规划总结篇

[代码随想录](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93%E7%AF%87.html)

[ChatGPT](https://chat.openai.com/share/9a477ffd-9759-4f82-9703-f9940cf69730)

---

### [647. 回文子串](https://leetcode.com/problems/palindromic-substrings/description/)

给你一个字符串 `s` ，请你统计并返回这个字符串中 **回文子串** 的数目。

**回文字符串** 是正着读和倒过来读一样的字符串。

**子字符串** 是字符串中的由连续字符组成的一个序列。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

**示例 1：**

输入：s = "abc"

输出：3

解释：三个回文子串: "a", "b", "c"

**示例 2：**

输入：s = "aaa"

输出：6

解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"

**提示：**

- `1 <= s.length <= 1000`
- `s` 由小写英文字母组成

要使用动态规划解决问题647（回文子串），我们可以遵循以下步骤：

#### 解题思路：

1. **初始化状态：** 创建一个二维数组 `dp`，其中 `dp[i][j]` 表示字符串从索引 `i` 到 `j` 的子串是否为回文串。初始时，所有的 `dp[i][i]` 都应该被设置为 `True`，因为单个字符总是回文串。
2. **状态转移方程：**
   - 如果 `s[i] == s[j]`，那么需要检查 `s[i+1]...s[j-1]` 是否为回文串，即 `dp[i][j] = dp[i+1][j-1]`。但对于 `j - i < 3`（即子串长度为 2 或 3）的情况，只要 `s[i] == s[j]`，不需要检查内部子串。
   - 如果 `s[i] != s[j]`，那么 `dp[i][j] = False`。
3. **计算顺序：** 由于 `dp[i][j]` 的计算依赖于 `dp[i+1][j-1]`，我们需要从下到上、从左到右地填充 `dp` 表格。
4. **统计回文子串：** 遍历 `dp` 表，每遇到一个 `dp[i][j] == True`，就增加回文子串的计数。

```python
def countSubstrings(s):
    n = len(s)  # 字符串的长度
    dp = [[False] * n for _ in range(n)]  # 初始化动态规划表格，False 表示非回文，True 表示回文
    count = 0  # 回文子串的数量

    # 初始化单字符回文
    for i in range(n):
        dp[i][i] = True
        count += 1  # 每个单独的字符都是回文子串

    # 动态规划填表
    for i in range(n-1, -1, -1):  # 从下到上遍历
        for j in range(i+1, n):  # 从左到右遍历
            if s[i] == s[j]:
                if j - i == 1 or dp[i+1][j-1]:  # 当子串长度为2或3时，只要首尾字符相同即为回文子串
                    dp[i][j] = True
                    count += 1  # 找到一个回文子串，计数加1
            else:
                dp[i][j] = False  # 首尾字符不相同，不是回文子串

    return count
```

#### 复杂度分析：

- 时间复杂度：O(n^2)，其中 n 是字符串的长度。需要双层循环遍历字符串。
- 空间复杂度：O(n^2)，用于存储 `dp` 表。

#### 常见错误：

- 未正确初始化 `dp` 表格中的单字符回文。
- 状态转移方程的边界条件处理不当，特别是当子串长度为 2 或 3 时。
- 计算顺序错误，导致依赖的状态尚未计算。

---

### [516.最长回文子序列](https://leetcode.com/problems/longest-palindromic-subsequence/description/)

给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

**示例 1：**

输入：s = "bbbab"

输出：4

解释：一个可能的最长回文子序列为 "bbbb" 。

**示例 2：**

输入：s = "cbbd"

输出：2

解释：一个可能的最长回文子序列为 "bb" 。

**提示：**

- `1 <= s.length <= 1000`
- `s` 仅由小写英文字母组成

#### 解题思路：

1. **初始化状态：** 创建一个二维数组 `dp`，其中 `dp[i][j]` 表示字符串从索引 `i` 到 `j` 子串的最长回文子序列的长度。初始时，所有的 `dp[i][i]` 都应该被设置为 `1`，因为单个字符的子串自然是一个长度为1的回文子序列。
2. **状态转移方程：**
   - 如果 `s[i] == s[j]`，那么 `dp[i][j] = dp[i+1][j-1] + 2`。这意味着如果当前考虑的两个字符相等，它们可以形成回文子序列，我们在内部子序列的基础上加2（即两端的字符）。
   - 如果 `s[i] != s[j]`，那么 `dp[i][j] = max(dp[i+1][j], dp[i][j-1])`。这意味着我们要么跳过左边的字符，要么跳过右边的字符，并求它们的最大值，因为我们不能同时使用两端的字符。
3. **计算顺序：** 由于 `dp[i][j]` 的计算依赖于它的下方和左方的值，我们需要从下到上、从左到右地填充 `dp` 表格。
4. **最终答案：** `dp[0][n-1]` 将会是整个字符串的最长回文子序列的长度，其中 `n` 是字符串 `s` 的长度。

```python
def longestPalindromeSubseq(s):
    n = len(s)  # 字符串长度
    dp = [[0] * n for _ in range(n)]  # 初始化dp数组，所有值为0

    for i in range(n-1, -1, -1):  # 从字符串末尾开始向前遍历
        dp[i][i] = 1  # 单个字符是回文子序列，长度为1
        for j in range(i+1, n):  # 从i+1到字符串末尾
            if s[i] == s[j]:  # 如果两端字符相等
                dp[i][j] = dp[i+1][j-1] + 2  # 内部子序列长度+2
            else:  # 如果两端字符不等
                dp[i][j] = max(dp[i+1][j], dp[i][j-1])  # 取左边或上边的最大值

    return dp[0][n-1]  # 返回整个字符串的最长回文子序列长度
```

#### 复杂度分析：

- **时间复杂度：** O(n^2)，其中 n 是字符串的长度。需要双层循环遍历字符串。
- **空间复杂度：** O(n^2)，用于存储 `dp` 表。

---

### 动态规划总结篇

动规五部曲分别为：

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

动规五部曲里，哪一部没想清楚，这道题目基本就做不出来，即使做出来了也没有想清楚，而是朦朦胧胧的就把题目过了。

- 如果想不清楚dp数组的具体含义，递归公式从何谈起，甚至初始化的时候就写错了。
- 例如[动态规划：不同路径还不够，要有障碍！ (opens new window)](https://programmercarl.com/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.html)在这道题目中，初始化才是重头戏
- 如果看过背包系列，特别是完全背包，那么两层for循环先后顺序绝对可以搞懵很多人，反而递归公式是简单的。
- 至于推导dp数组的重要性，动规专题里几乎每篇Carl都反复强调，当程序结果不对的时候，一定要自己推导公式，看看和程序打印的日志是否一样。

#### [\#](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93%E7%AF%87.html#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80)动态规划基础

- [关于动态规划，你该了解这些！(opens new window)](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)
- [动态规划：斐波那契数(opens new window)](https://programmercarl.com/0509.%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.html)
- [动态规划：爬楼梯(opens new window)](https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF.html)
- [动态规划：使用最小花费爬楼梯(opens new window)](https://programmercarl.com/0746.%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF.html)
- [动态规划：不同路径(opens new window)](https://programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html)
- [动态规划：不同路径还不够，要有障碍！(opens new window)](https://programmercarl.com/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.html)
- [动态规划：整数拆分，你要怎么拆？(opens new window)](https://programmercarl.com/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html)
- [动态规划：不同的二叉搜索树(opens new window)](https://programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html)

#### [\#](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93%E7%AF%87.html#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97)背包问题系列

![Image.png](https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.png)

- [动态规划：关于01背包问题，你该了解这些！(opens new window)](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html)
- [动态规划：关于01背包问题，你该了解这些！（滚动数组）(opens new window)](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html)
- [动态规划：分割等和子集可以用01背包！(opens new window)](https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html)
- [动态规划：最后一块石头的重量 II(opens new window)](https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html)
- [动态规划：目标和！(opens new window)](https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html)
- [动态规划：一和零！(opens new window)](https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html)
- [动态规划：关于完全背包，你该了解这些！(opens new window)](https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html)
- [动态规划：给你一些零钱，你要怎么凑？(opens new window)](https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html)
- [动态规划：Carl称它为排列总和！(opens new window)](https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html)
- [动态规划：以前我没得选，现在我选择再爬一次！(opens new window)](https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html)
- [动态规划： 给我个机会，我再兑换一次零钱(opens new window)](https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html)
- [动态规划：一样的套路，再求一次完全平方数(opens new window)](https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html)
- [动态规划：单词拆分(opens new window)](https://programmercarl.com/0139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.html)
- [动态规划：关于多重背包，你该了解这些！(opens new window)](https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85.html)
- [听说背包问题很难？ 这篇总结篇来拯救你了(opens new window)](https://programmercarl.com/%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93%E7%AF%87.html)

#### [\#](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E7%B3%BB%E5%88%97)打家劫舍系列

- [动态规划：开始打家劫舍！(opens new window)](https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html)
- [动态规划：继续打家劫舍！(opens new window)](https://programmercarl.com/0213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII.html)
- [动态规划：还要打家劫舍！(opens new window)](https://programmercarl.com/0337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII.html)

#### [\#](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93%E7%AF%87.html#%E8%82%A1%E7%A5%A8%E7%B3%BB%E5%88%97)股票系列

![Image.jpg](https://code-thinking.cdn.bcebos.com/pics/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.jpg)

- [动态规划：买卖股票的最佳时机(opens new window)](https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html)
- [动态规划：本周我们都讲了这些（系列六）(opens new window)](https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20210225%E5%8A%A8%E8%A7%84%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html)
- [动态规划：买卖股票的最佳时机II(opens new window)](https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html)
- [动态规划：买卖股票的最佳时机III(opens new window)](https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html)
- [动态规划：买卖股票的最佳时机IV(opens new window)](https://programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html)
- [动态规划：最佳买卖股票时机含冷冻期(opens new window)](https://programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html)
- [动态规划：本周我们都讲了这些（系列七）(opens new window)](https://programmercarl.com/%E5%91%A8%E6%80%BB%E7%BB%93/20210304%E5%8A%A8%E8%A7%84%E5%91%A8%E6%9C%AB%E6%80%BB%E7%BB%93.html)
- [动态规划：买卖股票的最佳时机含手续费(opens new window)](https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html)
- [动态规划：股票系列总结篇(opens new window)](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E7%AF%87.html)

#### [\#](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93%E7%AF%87.html#%E5%AD%90%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97)子序列系列

![Image.jpg](https://code-thinking.cdn.bcebos.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%AD%90%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.jpg)

- [动态规划：最长递增子序列(opens new window)](https://programmercarl.com/0300.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html)
- [动态规划：最长连续递增序列(opens new window)](https://programmercarl.com/0674.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97.html)
- [动态规划：最长重复子数组(opens new window)](https://programmercarl.com/0718.%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.html)
- [动态规划：最长公共子序列(opens new window)](https://programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html)
- [动态规划：不相交的线(opens new window)](https://programmercarl.com/1035.%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF.html)
- [动态规划：最大子序和(opens new window)](https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html)
- [动态规划：判断子序列(opens new window)](https://programmercarl.com/0392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html)
- [动态规划：不同的子序列(opens new window)](https://programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html)
- [动态规划：两个字符串的删除操作(opens new window)](https://programmercarl.com/0583.%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.html)
- [动态规划：编辑距离(opens new window)](https://programmercarl.com/0072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html)
- [为了绝杀编辑距离，我做了三步铺垫，你都知道么？(opens new window)](https://programmercarl.com/%E4%B8%BA%E4%BA%86%E7%BB%9D%E6%9D%80%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%EF%BC%8C%E5%8D%A1%E5%B0%94%E5%81%9A%E4%BA%86%E4%B8%89%E6%AD%A5%E9%93%BA%E5%9E%AB.html)
- [动态规划：回文子串(opens new window)](https://programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html)
- [动态规划：最长回文子序列(opens new window)](https://programmercarl.com/0516.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html)

#### [\#](https://programmercarl.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93%E7%AF%87.html#%E5%8A%A8%E8%A7%84%E7%BB%93%E6%9D%9F%E8%AF%AD)动规结束语

关于动规，还有 树形DP（打家劫舍系列里有一道），数位DP，区间DP ，概率型DP，博弈型DP，状态压缩dp等等等，这些我就不去做讲解了，面试中出现的概率非常低。

能把本篇中列举的题目都研究通透的话，你的动规水平就已经非常高了。 对付面试已经足够！

![Image.png](https://kstar-1253855093.cos.ap-nanjing.myqcloud.com/baguwenpdf/_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE_%E9%9D%92.png)

### 第十章：单调栈

#### 代码随想录算法训练营第五十八天 | 739. 每日温度，496.下一个更大元素 I

#### ● day 58 任务以及具体安排：[第十章 单调栈part01](https://docs.qq.com/doc/DUEJTT1BoS29NTGRD) (2.8)

# 第十章 单调栈part01

●  739. 每日温度

●  496.下一个更大元素 I

## 详细布置

### 739. 每日温度

今天正式开始单调栈，这是单调栈一篇扫盲题目，也是经典题。

大家可以读题，思考暴力的解法，然后在看单调栈的解法。 就能感受出单调栈的巧妙

[代码随想录](https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html)

### 496.下一个更大元素 I

本题和 739. 每日温度 看似差不多，其实 有加了点难度。

[代码随想录](https://programmercarl.com/0496.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I.html)

[ChatGPT](https://chat.openai.com/share/638292cb-4868-44fa-a3a0-227447174928)

---

### [739. 每日温度](https://leetcode.com/problems/daily-temperatures/description/)

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

**示例 1:**

**输入:** `temperatures` = [73,74,75,71,69,72,76,73]

**输出:** [1,1,4,2,1,1,0,0]

**示例 2:**

**输入:** temperatures = [30,40,50,60]

**输出:** [1,1,1,0]

**示例 3:**

**输入:** temperatures = [30,60,90]

**输出:** [1,1,0]

**提示：**

- `1 <= temperatures.length <= 105`
- `30 <= temperatures[i] <= 100`

要解决这个问题，我们可以使用一个叫做"单调栈"的数据结构。单调栈是一种特别的栈，用于解决一类特定的问题，其中我们需要找到数组中元素右边或左边第一个比它大或小的元素。在这个问题中，我们需要找到每个温度右边第一个比它高的温度，这正是单调栈擅长的。

#### 解题步骤：

1. 初始化一个栈，用于存储温度的索引，而不是温度值本身。这样做是为了能够计算索引之间的距离，即天数差。
2. 初始化一个和输入数组`temperatures`等长的数组`answer`，用于存储结果，初始值全为0。
3. 遍历数组`temperatures`，对于每个元素：
   - 当栈不为空，并且当前温度大于栈顶索引对应的温度时，说明找到了栈顶索引对应的天数的下一个更高温度。此时：
      - 将栈顶元素弹出，这个弹出的索引表示的是之前某天的温度。
      - 计算当前索引与弹出索引之间的距离（即天数差），并将该距离存储在`answer`数组的弹出索引位置。
   - 将当前索引压入栈中。
4. 对于栈中剩余的索引，它们对应的天数直到数组末尾都没有遇到更高的温度，根据题目要求，它们在`answer`数组中的值应该保持为0（初始化时已经设定）。

```python
def dailyTemperatures(temperatures):
    answer = [0] * len(temperatures)  # 初始化结果数组
    stack = []  # 使用列表模拟栈
    for i, temp in enumerate(temperatures):
        while stack and temperatures[stack[-1]] < temp:
            prev_index = stack.pop()  # 弹出栈顶元素，即之前某天的索引
            answer[prev_index] = i - prev_index  # 计算索引（天数）差
        stack.append(i)  # 当前天的索引入栈
    return answer
```

#### 复杂度分析：

- 时间复杂度：O(N)，其中N是数组`temperatures`的长度。虽然有一个嵌套循环，但每个元素最多入栈和出栈一次，因此总的操作次数是线性的。
- 空间复杂度：O(N)，最坏情况下栈中可能包含所有元素的索引。

#### 常见错误：

- 忘记在找到更高温度时从栈中移除索引。
- 错误地存储温度值而不是索引到栈中，导致无法计算天数差。

---

### [496.下一个更大元素 I](https://leetcode.com/problems/next-greater-element-i/description/)

`nums1` 中数字 `x` 的 **下一个更大元素** 是指 `x` 在 `nums2` 中对应位置 **右侧** 的 **第一个** 比 `x` 大的元素。

给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，下标从 **0** 开始计数，其中`nums1` 是 `nums2` 的子集。

对于每个 `0 <= i < nums1.length` ，找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，并且在 `nums2` 确定 `nums2[j]` 的 **下一个更大元素** 。如果不存在下一个更大元素，那么本次查询的答案是 `-1` 。

返回一个长度为 `nums1.length` 的数组 `ans` 作为答案，满足 `ans[i]` 是如上所述的 **下一个更大元素** 。

**示例 1：**

输入：nums1 = [4,1,2], nums2 = [1,3,4,2].

**输出：**[-1,3,-1]

解释：nums1 中每个值的下一个更大元素如下所述：

- 4 ，用加粗斜体标识，nums2 = [1,3,**4**,2]。不存在下一个更大元素，所以答案是 -1 。
- 1 ，用加粗斜体标识，nums2 = [***1***,3,4,2]。下一个更大元素是 3 。
- 2 ，用加粗斜体标识，nums2 = [1,3,4,***2***]。不存在下一个更大元素，所以答案是 -1 。

**示例 2：**

输入：nums1 = [2,4], nums2 = [1,2,3,4].

**输出：**[3,-1]

解释：nums1 中每个值的下一个更大元素如下所述：

- 2 ，用加粗斜体标识，nums2 = [1,***2***,3,4]。下一个更大元素是 3 。
- 4 ，用加粗斜体标识，nums2 = [1,2,3,***4***]。不存在下一个更大元素，所以答案是 -1 。

#### 解题思路：

解决"下一个更大元素 I"问题，我们可以使用单调栈加哈希表的方法，步骤如下：

1. 首先遍历数组`nums2`，使用单调栈找出每个元素右边第一个更大的元素。单调栈的特点是栈顶到栈底元素是单调递减的。遍历过程中，对于每个元素，如果它比栈顶元素大，说明我们找到了栈顶元素右边第一个更大的元素，将栈顶元素弹出，并记录这个关系。
2. 将`nums2`中元素与其右边第一个更大元素的关系存储在哈希表中，键是`nums2`中的元素，值是该元素右边的第一个更大元素。如果没有更大的元素，则不在哈希表中记录。
3. 遍历数组`nums1`，对于`nums1`中的每个元素，直接从哈希表中查询该元素对应的下一个更大元素，如果哈希表中没有这个元素的记录，说明该元素没有更大的元素，结果为-1。

```python
def nextGreaterElement(nums1, nums2):
    stack = []  # 使用列表模拟栈
    greater_map = {}  # 存储nums2中每个元素的下一个更大元素的哈希表

    # 遍历nums2，使用单调栈找出每个元素的下一个更大元素
    for num in nums2:
        while stack and stack[-1] < num:
            smaller = stack.pop()
            greater_map[smaller] = num
        stack.append(num)

    # 根据哈希表，获取nums1中每个元素的下一个更大元素
    res = [greater_map.get(num, -1) for num in nums1]
    return res
```

#### 复杂度分析：

- 时间复杂度：O(N+M)，其中N和M分别是数组`nums1`和`nums2`的长度。`nums2`被遍历一次用于填充哈希表，`nums1`被遍历一次用于构建结果数组。
- 空间复杂度：O(M)，用于存储`nums2`中元素的单调栈和哈希表。

#### 代码随想录算法训练营第五十九天 | 503.下一个更大元素II，42. 接雨水

#### ● day 64 任务以及具体安排：[第十章 单调栈part02](https://docs.qq.com/doc/DUHhnTHZUSGpHZ0Z2) (2.14)

# 第十章 单调栈part02

●  503.下一个更大元素II

●  42. 接雨水

## 详细布置

### 503.下一个更大元素II

这道题和 739. 每日温度 几乎如出一辙，可以自己尝试做一做

[代码随想录](https://programmercarl.com/0503.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II.html)

### 42. 接雨水

接雨水这道题目是 面试中特别高频的一道题，也是单调栈 应用的题目，大家好好做做。

建议是掌握 双指针 和单调栈，因为在面试中 写出单调栈可能 有点难度，但双指针思路更直接一些。

在时间紧张的情况有，能写出双指针法也是不错的，然后可以和面试官在慢慢讨论如何优化。

[代码随想录](https://programmercarl.com/0042.%E6%8E%A5%E9%9B%A8%E6%B0%B4.html)

[Just a moment...](https://chat.openai.com/share/8fee2398-81f6-4602-a706-ae6d3becf595)

---

### [503.下一个更大元素II](https://leetcode.com/problems/next-greater-element-ii/description/)

给定一个循环数组 `nums` （ `nums[nums.length - 1]` 的下一个元素是 `nums[0]` ），返回 `nums` *中每个元素的 **下一个更大元素*** 。

数字 `x` 的 **下一个更大的元素** 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 `-1` 。

**示例 1:**

**输入:** nums = [1,2,1]

**输出:** [2,-1,2]

**解释:** 第一个 1 的下一个更大的数是 2；

数字 2 找不到下一个更大的数；

第二个 1 的下一个最大的数需要循环搜索，结果也是 2。

**示例 2:**

**输入:** nums = [1,2,3,4,3]

**输出:** [2,3,4,-1,4]

**提示:**

- `1 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`

#### 解题思路：

对于循环数组的情况，我们可以将数组“虚拟”地扩展为两倍长度，以模拟循环的效果。具体步骤如下：

1. 初始化一个栈和一个结果数组，结果数组的长度与输入数组相同，初始值全部为-1。
2. 遍历输入数组两次，第二次遍历是为了模拟循环的效果。在每次遍历中，使用索引 `i % n` 来访问数组元素，其中 `n` 是数组的长度。
3. 对于每个元素，当栈不为空且当前元素大于栈顶索引对应的元素时，表示找到了栈顶元素的下一个更大元素。将当前元素作为栈顶元素的下一个更大元素记录在结果数组中，并弹出栈顶元素。
4. 将当前索引入栈（注意是索引而不是元素值），这样在之后的遍历中可以通过索引来获取元素值。
5. 完成遍历后，结果数组中已经记录了每个元素的下一个更大元素，直接返回结果数组。

```python
def nextGreaterElements(nums):
    n = len(nums)
    res = [-1] * n  # 初始化结果数组
    stack = []  # 初始化单调栈，存储索引
    for i in range(2 * n):  # 循环数组，遍历两次
        while stack and nums[stack[-1]] < nums[i % n]:  # 当前元素大于栈顶元素
            res[stack.pop()] = nums[i % n]  # 更新栈顶元素的下一个更大元素
        if i < n:  # 只有在第一次遍历时才将索引入栈
            stack.append(i)
    return res
```

#### 时空复杂度：

时间复杂度分析：

- 遍历数组两次，时间复杂度为O(2n)，简化为O(n)。
- 每个元素最多入栈和出栈一次，栈操作的总时间复杂度也为O(n)。

空间复杂度分析：

- 使用了一个栈和一个结果数组，空间复杂度为O(n)。

#### 常见错误或难点：

- 忘记模拟循环数组，即不进行两倍长度的遍历。
- 在更新结果数组时使用元素值而不是索引，或者在栈中存储元素值而不是索引。
- 忘记在只有在第一次遍历时才将索引入栈，导致结果错误。

---

### [42. 接雨水](https://leetcode.com/problems/trapping-rain-water/description/)

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**

![Image.png](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]

输出：6

解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。

**示例 2：**

输入：height = [4,2,0,3,2,5]

输出：9

**提示：**

- `n == height.length`
- `1 <= n <= 2 * 104`
- `0 <= height[i] <= 105`

#### 解题思路：

解决接雨水问题的基本思路是通过计算每个位置能够接到的雨水量来求解总的雨水量。具体步骤如下：

1. 对于数组中的每个元素，找出其左边和右边最高的柱子，这两个柱子与当前元素构成的容器可能会接到雨水。
2. 对于每个元素，它能接的雨水量等于其左右两边最高的柱子的较小者与当前元素高度的差值。如果这个差值是正数，那么就是当前位置能接到的雨水量；如果是负数或0，表示当前位置不会接到雨水。
3. 遍历数组，累加每个位置能接到的雨水量，得到最终结果。

```python
class Solution:
    def trap(self, height):
        if not height:
            return 0

        n = len(height)
        l_max = [0] * n
        r_max = [0] * n

        # 从左向右计算l_max
        l_max[0] = height[0]
        for i in range(1, n):
            l_max[i] = max(height[i], l_max[i - 1])

        # 从右向左计算r_max
        r_max[n - 1] = height[n - 1]
        for i in range(n - 2, -1, -1):
            r_max[i] = max(height[i], r_max[i + 1])

        # 计算答案
        res = 0
        for i in range(1, n - 1):
            res += min(l_max[i], r_max[i]) - height[i]

        return res
```

#### 时间复杂度分析：

- 初始化l_max和r_max数组的时间复杂度为O(n)。
- 第一次遍历计算l_max的时间复杂度为O(n)。
- 第二次遍历计算r_max的时间复杂度为O(n)。
- 第三次遍历计算每个位置的积水量，时间复杂度也为O(n)。
- 所以总的时间复杂度为O(n)。

#### 空间复杂度分析：

- 需要额外的空间来存储左侧和右侧的最大值数组，空间复杂度为O(n)。

#### 代码随想录算法训练营第六十天 | 84.柱状图中最大的矩形

#### ● day 65 任务以及具体安排：[第十章 单调栈part03](https://docs.qq.com/doc/DUFJEbG5uTHV2a1hC) (2.15)

# 第十章 单调栈part03

有了之前单调栈的铺垫，这道题目就不难了。

●  84.柱状图中最大的矩形

[代码随想录](https://programmercarl.com/0084.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.html)

今天是训练营最后一天，恭喜坚持两个月的录友们，接下来可以写一篇自己 代码随想录一刷的总结。好好回顾一下，这两个月自己的博客内容，以及自己的收获。

[Just a moment...](https://chat.openai.com/share/0a552cfa-ec03-4ba5-99bb-fdd8108fb65b)

---

### [84.柱状图中最大的矩形](https://leetcode.com/problems/largest-rectangle-in-histogram/description/)

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

**示例 1:**

![Image.jpg](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)

输入：heights = [2,1,5,6,2,3]

输出：10

解释：最大的矩形为图中红色区域，面积为 10

**示例 2：**

![Image.jpg](https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg)

**输入：** heights = [2,4]

**输出：** 4

**提示：**

- `1 <= heights.length <=105`
- `0 <= heights[i] <= 104`

#### 解题思路：

要解决这个问题，我们可以使用一个栈来维护柱状图中的高度序列。基本思想是遍历每个柱子，以当前柱子高度作为矩形的高，向左右扩展，直到遇到比当前柱子矮的柱子，这样就能找到以当前柱子为高的最大矩形面积。使用栈的目的是为了记录每个柱子左边和右边第一个比它矮的柱子的位置。

步骤如下：

1. 创建一个栈，用于存储柱状图中柱子的索引。
2. 从左到右遍历柱状图中的每一个柱子。
   - 当栈为空或当前柱子的高度大于栈顶柱子索引对应的高度时，将当前柱子的索引入栈。
   - 如果当前柱子的高度小于栈顶柱子索引对应的高度，说明找到了栈顶柱子右边第一个比它矮的柱子，此时可以计算栈顶柱子的最大矩形面积。弹出栈顶元素，以弹出元素对应的高度作为矩形的高，以当前索引与栈顶新的索引之间的距离（如果栈为空，则以当前索引+1）作为矩形的宽，计算面积，并更新最大面积。重复此过程直到栈为空或当前柱子的高度大于栈顶柱子索引对应的高度。
3. 遍历结束后，栈中可能还有一些索引。这些索引对应的柱子右边没有比它们更矮的柱子，需要分别计算这些柱子的最大矩形面积。依次弹出栈中的索引，并按照上述方法计算面积，更新最大面积。

```python
def largestRectangleArea(heights):
    stack = []  # 创建一个空栈，用于存储柱子的索引
    max_area = 0  # 初始化最大面积为0
    for i, h in enumerate(heights):
        # 当栈不为空且当前柱子的高度小于栈顶柱子的高度时，计算面积
        while stack and heights[stack[-1]] > h:
            height = heights[stack.pop()]  # 弹出栈顶元素，并获取对应的高度
            # 如果栈为空，则宽度为当前索引i；如果栈不为空，则宽度为当前索引i减去新的栈顶索引减1
            width = i if not stack else i - stack[-1] - 1
            max_area = max(max_area, height * width)  # 更新最大面积
        stack.append(i)  # 将当前柱子的索引入栈
    
    # 处理栈中剩余的柱子
    while stack:
        height = heights[stack.pop()]  # 弹出栈顶元素，并获取对应的高度
        # 如果栈为空，则宽度为柱状图的总宽度；如果栈不为空，则宽度为柱状图的总宽度减去新的栈顶索引减1
        width = len(heights) if not stack else len(heights) - stack[-1] - 1
        max_area = max(max_area, height * width)  # 更新最大面积
    
    return max_area  # 返回最大面积
```

### 复杂度分析

- 时间复杂度：O(n)，其中 n 是柱状图中柱子的数量。每个柱子被压入和弹出栈各一次。
- 空间复杂度：O(n)，用于存储栈中的索引。

### 常见错误

- 不正确地处理栈为空的情况，导致计算宽度时出错。
- 在循环中没有更新最大面积，或者在计算面积时使用了错误的宽度或高度。

?descriptionFromFileType=function+toLocaleUpperCase()+{+[native+code]+}+File&mimeType=application/octet-stream&fileName=算法训练营.md&fileType=undefined&fileExtension=md